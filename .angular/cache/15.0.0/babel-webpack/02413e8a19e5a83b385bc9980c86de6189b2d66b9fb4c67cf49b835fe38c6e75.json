{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.PickFirstLoadBalancer = exports.PickFirstLoadBalancingConfig = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst picker_1 = require(\"./picker\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst TRACER_NAME = 'pick_first';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'pick_first';\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n  constructor() {}\n  toJsonObject() {\n    return {\n      [TYPE_NAME]: {}\n    };\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj) {\n    return new PickFirstLoadBalancingConfig();\n  }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker {\n  constructor(subchannel) {\n    this.subchannel = subchannel;\n  }\n  pick(pickArgs) {\n    return {\n      pickResultType: picker_1.PickResultType.COMPLETE,\n      subchannel: this.subchannel,\n      status: null,\n      extraFilterFactories: [],\n      onCallStarted: null\n    };\n  }\n}\nclass PickFirstLoadBalancer {\n  /**\n   * Load balancer that attempts to connect to each backend in the address list\n   * in order, and picks the first one that connects, using it for every\n   * request.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   */\n  constructor(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n    /**\n     * The list of backend addresses most recently passed to `updateAddressList`.\n     */\n    this.latestAddressList = [];\n    /**\n     * The list of subchannels this load balancer is currently attempting to\n     * connect to.\n     */\n    this.subchannels = [];\n    /**\n     * The current connectivity state of the load balancer.\n     */\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The index within the `subchannels` array of the subchannel with the most\n     * recently started connection attempt.\n     */\n    this.currentSubchannelIndex = 0;\n    /**\n     * The currently picked subchannel used for making calls. Populated if\n     * and only if the load balancer's current state is READY. In that case,\n     * the subchannel's current state is also READY.\n     */\n    this.currentPick = null;\n    this.triedAllSubchannels = false;\n    this.subchannelStateCounts = {\n      [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n      [connectivity_state_1.ConnectivityState.IDLE]: 0,\n      [connectivity_state_1.ConnectivityState.READY]: 0,\n      [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n      [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n    this.subchannelStateListener = (subchannel, previousState, newState) => {\n      this.subchannelStateCounts[previousState] -= 1;\n      this.subchannelStateCounts[newState] += 1;\n      /* If the subchannel we most recently attempted to start connecting\n       * to goes into TRANSIENT_FAILURE, immediately try to start\n       * connecting to the next one instead of waiting for the connection\n       * delay timer. */\n      if (subchannel === this.subchannels[this.currentSubchannelIndex] && newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        this.startNextSubchannelConnecting();\n      }\n      if (newState === connectivity_state_1.ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        return;\n      } else {\n        if (this.triedAllSubchannels && this.subchannelStateCounts[connectivity_state_1.ConnectivityState.IDLE] === this.subchannels.length) {\n          /* If all of the subchannels are IDLE we should go back to a\n           * basic IDLE state where there is no subchannel list to avoid\n           * holding unused resources. We do not reset triedAllSubchannels\n           * because that is a reminder to request reresolution the next time\n           * this LB policy needs to connect. */\n          this.resetSubchannelList(false);\n          this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n          return;\n        }\n        if (this.currentPick === null) {\n          if (this.triedAllSubchannels) {\n            let newLBState;\n            if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n              newLBState = connectivity_state_1.ConnectivityState.CONNECTING;\n            } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n              newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n            } else {\n              newLBState = connectivity_state_1.ConnectivityState.IDLE;\n            }\n            if (newLBState !== this.currentState) {\n              if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                this.updateState(newLBState, new picker_1.UnavailablePicker());\n              } else {\n                this.updateState(newLBState, new picker_1.QueuePicker(this));\n              }\n            }\n          } else {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n          }\n        }\n      }\n    };\n    this.pickedSubchannelStateListener = (subchannel, previousState, newState) => {\n      if (newState !== connectivity_state_1.ConnectivityState.READY) {\n        this.currentPick = null;\n        subchannel.unref();\n        subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n        this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        if (this.subchannels.length > 0) {\n          if (this.triedAllSubchannels) {\n            let newLBState;\n            if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n              newLBState = connectivity_state_1.ConnectivityState.CONNECTING;\n            } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n              newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n            } else {\n              newLBState = connectivity_state_1.ConnectivityState.IDLE;\n            }\n            if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n              this.updateState(newLBState, new picker_1.UnavailablePicker());\n            } else {\n              this.updateState(newLBState, new picker_1.QueuePicker(this));\n            }\n          } else {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n          }\n        } else {\n          /* We don't need to backoff here because this only happens if a\n           * subchannel successfully connects then disconnects, so it will not\n           * create a loop of attempting to connect to an unreachable backend\n           */\n          this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        }\n      }\n    };\n    this.connectionDelayTimeout = setTimeout(() => {}, 0);\n    clearTimeout(this.connectionDelayTimeout);\n  }\n  startNextSubchannelConnecting() {\n    if (this.triedAllSubchannels) {\n      return;\n    }\n    for (const [index, subchannel] of this.subchannels.entries()) {\n      if (index > this.currentSubchannelIndex) {\n        const subchannelState = subchannel.getConnectivityState();\n        if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n          this.startConnecting(index);\n          return;\n        }\n      }\n    }\n    this.triedAllSubchannels = true;\n  }\n  /**\n   * Have a single subchannel in the `subchannels` list start connecting.\n   * @param subchannelIndex The index into the `subchannels` list.\n   */\n  startConnecting(subchannelIndex) {\n    clearTimeout(this.connectionDelayTimeout);\n    this.currentSubchannelIndex = subchannelIndex;\n    if (this.subchannels[subchannelIndex].getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n      trace('Start connecting to subchannel with address ' + this.subchannels[subchannelIndex].getAddress());\n      process.nextTick(() => {\n        this.subchannels[subchannelIndex].startConnecting();\n      });\n    }\n    this.connectionDelayTimeout = setTimeout(() => {\n      this.startNextSubchannelConnecting();\n    }, CONNECTION_DELAY_INTERVAL_MS);\n  }\n  pickSubchannel(subchannel) {\n    trace('Pick subchannel with address ' + subchannel.getAddress());\n    if (this.currentPick !== null) {\n      this.currentPick.unref();\n      this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n    }\n    this.currentPick = subchannel;\n    this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(subchannel));\n    subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);\n    subchannel.ref();\n    this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    this.resetSubchannelList();\n    clearTimeout(this.connectionDelayTimeout);\n  }\n  updateState(newState, picker) {\n    trace(connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n  resetSubchannelList(resetTriedAllSubchannels = true) {\n    for (const subchannel of this.subchannels) {\n      subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n    }\n    this.currentSubchannelIndex = 0;\n    this.subchannelStateCounts = {\n      [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n      [connectivity_state_1.ConnectivityState.IDLE]: 0,\n      [connectivity_state_1.ConnectivityState.READY]: 0,\n      [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n      [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n    this.subchannels = [];\n    if (resetTriedAllSubchannels) {\n      this.triedAllSubchannels = false;\n    }\n  }\n  /**\n   * Start connecting to the address list most recently passed to\n   * `updateAddressList`.\n   */\n  connectToAddressList() {\n    this.resetSubchannelList();\n    trace('Connect to address list ' + this.latestAddressList.map(address => subchannel_address_1.subchannelAddressToString(address)));\n    this.subchannels = this.latestAddressList.map(address => this.channelControlHelper.createSubchannel(address, {}));\n    for (const subchannel of this.subchannels) {\n      subchannel.ref();\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    }\n    for (const subchannel of this.subchannels) {\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n      this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;\n      if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        this.resetSubchannelList();\n        return;\n      }\n    }\n    for (const [index, subchannel] of this.subchannels.entries()) {\n      const subchannelState = subchannel.getConnectivityState();\n      if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n        this.startConnecting(index);\n        if (this.currentPick === null) {\n          this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n        return;\n      }\n    }\n    // If the code reaches this point, every subchannel must be in TRANSIENT_FAILURE\n    if (this.currentPick === null) {\n      this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n    }\n  }\n  updateAddressList(addressList, lbConfig) {\n    // lbConfig has no useful information for pick first load balancing\n    /* To avoid unnecessary churn, we only do something with this address list\n     * if we're not currently trying to establish a connection, or if the new\n     * address list is different from the existing one */\n    if (this.subchannels.length === 0 || !this.latestAddressList.every((value, index) => addressList[index] === value)) {\n      this.latestAddressList = addressList;\n      this.connectToAddressList();\n    }\n  }\n  exitIdle() {\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.triedAllSubchannels) {\n      this.channelControlHelper.requestReresolution();\n    }\n    for (const subchannel of this.subchannels) {\n      subchannel.startConnecting();\n    }\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n      if (this.latestAddressList.length > 0) {\n        this.connectToAddressList();\n      }\n    }\n  }\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n  destroy() {\n    this.resetSubchannelList();\n    if (this.currentPick !== null) {\n      /* Unref can cause a state change, which can cause a change in the value\n       * of this.currentPick, so we hold a local reference to make sure that\n       * does not impact this function. */\n      const currentPick = this.currentPick;\n      currentPick.unref();\n      currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n      this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());\n    }\n  }\n  getTypeName() {\n    return TYPE_NAME;\n  }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nfunction setup() {\n  load_balancer_1.registerLoadBalancerType(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n  load_balancer_1.registerDefaultLoadBalancerType(TYPE_NAME);\n}\nexports.setup = setup;","map":{"version":3,"names":["Object","defineProperty","exports","value","setup","PickFirstLoadBalancer","PickFirstLoadBalancingConfig","load_balancer_1","require","connectivity_state_1","picker_1","subchannel_address_1","logging","constants_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","TYPE_NAME","CONNECTION_DELAY_INTERVAL_MS","getLoadBalancerName","constructor","toJsonObject","createFromJson","obj","PickFirstPicker","subchannel","pick","pickArgs","pickResultType","PickResultType","COMPLETE","status","extraFilterFactories","onCallStarted","channelControlHelper","latestAddressList","subchannels","currentState","ConnectivityState","IDLE","currentSubchannelIndex","currentPick","triedAllSubchannels","subchannelStateCounts","CONNECTING","READY","SHUTDOWN","TRANSIENT_FAILURE","subchannelStateListener","previousState","newState","startNextSubchannelConnecting","pickSubchannel","length","resetSubchannelList","updateState","QueuePicker","newLBState","UnavailablePicker","pickedSubchannelStateListener","unref","removeConnectivityStateListener","removeChannelzChild","getChannelzRef","connectionDelayTimeout","setTimeout","clearTimeout","index","entries","subchannelState","getConnectivityState","startConnecting","subchannelIndex","getAddress","process","nextTick","addConnectivityStateListener","ref","addChannelzChild","picker","resetTriedAllSubchannels","connectToAddressList","map","address","subchannelAddressToString","createSubchannel","updateAddressList","addressList","lbConfig","every","exitIdle","requestReresolution","resetBackoff","destroy","getTypeName","registerLoadBalancerType","registerDefaultLoadBalancerType"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setup = exports.PickFirstLoadBalancer = exports.PickFirstLoadBalancingConfig = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst picker_1 = require(\"./picker\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst TRACER_NAME = 'pick_first';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'pick_first';\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    constructor() { }\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {},\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        return new PickFirstLoadBalancingConfig();\n    }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker {\n    constructor(subchannel) {\n        this.subchannel = subchannel;\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: this.subchannel,\n            status: null,\n            extraFilterFactories: [],\n            onCallStarted: null,\n        };\n    }\n}\nclass PickFirstLoadBalancer {\n    /**\n     * Load balancer that attempts to connect to each backend in the address list\n     * in order, and picks the first one that connects, using it for every\n     * request.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     */\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        /**\n         * The list of backend addresses most recently passed to `updateAddressList`.\n         */\n        this.latestAddressList = [];\n        /**\n         * The list of subchannels this load balancer is currently attempting to\n         * connect to.\n         */\n        this.subchannels = [];\n        /**\n         * The current connectivity state of the load balancer.\n         */\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The index within the `subchannels` array of the subchannel with the most\n         * recently started connection attempt.\n         */\n        this.currentSubchannelIndex = 0;\n        /**\n         * The currently picked subchannel used for making calls. Populated if\n         * and only if the load balancer's current state is READY. In that case,\n         * the subchannel's current state is also READY.\n         */\n        this.currentPick = null;\n        this.triedAllSubchannels = false;\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0,\n        };\n        this.subchannelStateListener = (subchannel, previousState, newState) => {\n            this.subchannelStateCounts[previousState] -= 1;\n            this.subchannelStateCounts[newState] += 1;\n            /* If the subchannel we most recently attempted to start connecting\n             * to goes into TRANSIENT_FAILURE, immediately try to start\n             * connecting to the next one instead of waiting for the connection\n             * delay timer. */\n            if (subchannel === this.subchannels[this.currentSubchannelIndex] &&\n                newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                this.startNextSubchannelConnecting();\n            }\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                return;\n            }\n            else {\n                if (this.triedAllSubchannels &&\n                    this.subchannelStateCounts[connectivity_state_1.ConnectivityState.IDLE] ===\n                        this.subchannels.length) {\n                    /* If all of the subchannels are IDLE we should go back to a\n                     * basic IDLE state where there is no subchannel list to avoid\n                     * holding unused resources. We do not reset triedAllSubchannels\n                     * because that is a reminder to request reresolution the next time\n                     * this LB policy needs to connect. */\n                    this.resetSubchannelList(false);\n                    this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n                    return;\n                }\n                if (this.currentPick === null) {\n                    if (this.triedAllSubchannels) {\n                        let newLBState;\n                        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n                            newLBState = connectivity_state_1.ConnectivityState.CONNECTING;\n                        }\n                        else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] >\n                            0) {\n                            newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n                        }\n                        else {\n                            newLBState = connectivity_state_1.ConnectivityState.IDLE;\n                        }\n                        if (newLBState !== this.currentState) {\n                            if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                                this.updateState(newLBState, new picker_1.UnavailablePicker());\n                            }\n                            else {\n                                this.updateState(newLBState, new picker_1.QueuePicker(this));\n                            }\n                        }\n                    }\n                    else {\n                        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n                    }\n                }\n            }\n        };\n        this.pickedSubchannelStateListener = (subchannel, previousState, newState) => {\n            if (newState !== connectivity_state_1.ConnectivityState.READY) {\n                this.currentPick = null;\n                subchannel.unref();\n                subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n                this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n                if (this.subchannels.length > 0) {\n                    if (this.triedAllSubchannels) {\n                        let newLBState;\n                        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n                            newLBState = connectivity_state_1.ConnectivityState.CONNECTING;\n                        }\n                        else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] >\n                            0) {\n                            newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n                        }\n                        else {\n                            newLBState = connectivity_state_1.ConnectivityState.IDLE;\n                        }\n                        if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                            this.updateState(newLBState, new picker_1.UnavailablePicker());\n                        }\n                        else {\n                            this.updateState(newLBState, new picker_1.QueuePicker(this));\n                        }\n                    }\n                    else {\n                        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n                    }\n                }\n                else {\n                    /* We don't need to backoff here because this only happens if a\n                     * subchannel successfully connects then disconnects, so it will not\n                     * create a loop of attempting to connect to an unreachable backend\n                     */\n                    this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n                }\n            }\n        };\n        this.connectionDelayTimeout = setTimeout(() => { }, 0);\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    startNextSubchannelConnecting() {\n        if (this.triedAllSubchannels) {\n            return;\n        }\n        for (const [index, subchannel] of this.subchannels.entries()) {\n            if (index > this.currentSubchannelIndex) {\n                const subchannelState = subchannel.getConnectivityState();\n                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||\n                    subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                    this.startConnecting(index);\n                    return;\n                }\n            }\n        }\n        this.triedAllSubchannels = true;\n    }\n    /**\n     * Have a single subchannel in the `subchannels` list start connecting.\n     * @param subchannelIndex The index into the `subchannels` list.\n     */\n    startConnecting(subchannelIndex) {\n        clearTimeout(this.connectionDelayTimeout);\n        this.currentSubchannelIndex = subchannelIndex;\n        if (this.subchannels[subchannelIndex].getConnectivityState() ===\n            connectivity_state_1.ConnectivityState.IDLE) {\n            trace('Start connecting to subchannel with address ' +\n                this.subchannels[subchannelIndex].getAddress());\n            process.nextTick(() => {\n                this.subchannels[subchannelIndex].startConnecting();\n            });\n        }\n        this.connectionDelayTimeout = setTimeout(() => {\n            this.startNextSubchannelConnecting();\n        }, CONNECTION_DELAY_INTERVAL_MS);\n    }\n    pickSubchannel(subchannel) {\n        trace('Pick subchannel with address ' + subchannel.getAddress());\n        if (this.currentPick !== null) {\n            this.currentPick.unref();\n            this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n        }\n        this.currentPick = subchannel;\n        this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(subchannel));\n        subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);\n        subchannel.ref();\n        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        this.resetSubchannelList();\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList(resetTriedAllSubchannels = true) {\n        for (const subchannel of this.subchannels) {\n            subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        }\n        this.currentSubchannelIndex = 0;\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0,\n        };\n        this.subchannels = [];\n        if (resetTriedAllSubchannels) {\n            this.triedAllSubchannels = false;\n        }\n    }\n    /**\n     * Start connecting to the address list most recently passed to\n     * `updateAddressList`.\n     */\n    connectToAddressList() {\n        this.resetSubchannelList();\n        trace('Connect to address list ' +\n            this.latestAddressList.map((address) => subchannel_address_1.subchannelAddressToString(address)));\n        this.subchannels = this.latestAddressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));\n        for (const subchannel of this.subchannels) {\n            subchannel.ref();\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        }\n        for (const subchannel of this.subchannels) {\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;\n            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                this.resetSubchannelList();\n                return;\n            }\n        }\n        for (const [index, subchannel] of this.subchannels.entries()) {\n            const subchannelState = subchannel.getConnectivityState();\n            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||\n                subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                this.startConnecting(index);\n                if (this.currentPick === null) {\n                    this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n                }\n                return;\n            }\n        }\n        // If the code reaches this point, every subchannel must be in TRANSIENT_FAILURE\n        if (this.currentPick === null) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n        }\n    }\n    updateAddressList(addressList, lbConfig) {\n        // lbConfig has no useful information for pick first load balancing\n        /* To avoid unnecessary churn, we only do something with this address list\n         * if we're not currently trying to establish a connection, or if the new\n         * address list is different from the existing one */\n        if (this.subchannels.length === 0 ||\n            !this.latestAddressList.every((value, index) => addressList[index] === value)) {\n            this.latestAddressList = addressList;\n            this.connectToAddressList();\n        }\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE ||\n            this.triedAllSubchannels) {\n            this.channelControlHelper.requestReresolution();\n        }\n        for (const subchannel of this.subchannels) {\n            subchannel.startConnecting();\n        }\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n            if (this.latestAddressList.length > 0) {\n                this.connectToAddressList();\n            }\n        }\n    }\n    resetBackoff() {\n        /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */\n    }\n    destroy() {\n        this.resetSubchannelList();\n        if (this.currentPick !== null) {\n            /* Unref can cause a state change, which can cause a change in the value\n             * of this.currentPick, so we hold a local reference to make sure that\n             * does not impact this function. */\n            const currentPick = this.currentPick;\n            currentPick.unref();\n            currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n            this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());\n        }\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nfunction setup() {\n    load_balancer_1.registerLoadBalancerType(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n    load_balancer_1.registerDefaultLoadBalancerType(TYPE_NAME);\n}\nexports.setup = setup;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}