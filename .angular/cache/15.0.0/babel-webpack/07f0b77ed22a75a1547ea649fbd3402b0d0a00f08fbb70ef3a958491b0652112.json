{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.isAnyExtension = exports.Long = void 0;\nconst camelCase = require(\"lodash.camelcase\");\nconst Protobuf = require(\"protobufjs\");\nconst descriptor = require(\"protobufjs/ext/descriptor\");\nconst util_1 = require(\"./util\");\nconst Long = require(\"long\");\nexports.Long = Long;\nfunction isAnyExtension(obj) {\n  return '@type' in obj && typeof obj['@type'] === 'string';\n}\nexports.isAnyExtension = isAnyExtension;\nconst descriptorOptions = {\n  longs: String,\n  enums: String,\n  bytes: String,\n  defaults: true,\n  oneofs: true,\n  json: true\n};\nfunction joinName(baseName, name) {\n  if (baseName === '') {\n    return name;\n  } else {\n    return baseName + '.' + name;\n  }\n}\nfunction isHandledReflectionObject(obj) {\n  return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;\n}\nfunction isNamespaceBase(obj) {\n  return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n  const objName = joinName(parentName, obj.name);\n  if (isHandledReflectionObject(obj)) {\n    return [[objName, obj]];\n  } else {\n    if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {\n      return Object.keys(obj.nested).map(name => {\n        return getAllHandledReflectionObjects(obj.nested[name], objName);\n      }).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n    }\n  }\n  return [];\n}\nfunction createDeserializer(cls, options) {\n  return function deserialize(argBuf) {\n    return cls.toObject(cls.decode(argBuf), options);\n  };\n}\nfunction createSerializer(cls) {\n  return function serialize(arg) {\n    if (Array.isArray(arg)) {\n      throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\n    }\n    const message = cls.fromObject(arg);\n    return cls.encode(message).finish();\n  };\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n  /* This is only ever called after the corresponding root.resolveAll(), so we\n   * can assume that the resolved request and response types are non-null */\n  const requestType = method.resolvedRequestType;\n  const responseType = method.resolvedResponseType;\n  return {\n    path: '/' + serviceName + '/' + method.name,\n    requestStream: !!method.requestStream,\n    responseStream: !!method.responseStream,\n    requestSerialize: createSerializer(requestType),\n    requestDeserialize: createDeserializer(requestType, options),\n    responseSerialize: createSerializer(responseType),\n    responseDeserialize: createDeserializer(responseType, options),\n    // TODO(murgatroid99): Find a better way to handle this\n    originalName: camelCase(method.name),\n    requestType: createMessageDefinition(requestType, fileDescriptors),\n    responseType: createMessageDefinition(responseType, fileDescriptors)\n  };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n  const def = {};\n  for (const method of service.methodsArray) {\n    def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n  }\n  return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n  const messageDescriptor = message.toDescriptor('proto3');\n  return {\n    format: 'Protocol Buffer 3 DescriptorProto',\n    type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n    fileDescriptorProtos: fileDescriptors\n  };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n  const enumDescriptor = enumType.toDescriptor('proto3');\n  return {\n    format: 'Protocol Buffer 3 EnumDescriptorProto',\n    type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n    fileDescriptorProtos: fileDescriptors\n  };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */\nfunction createDefinition(obj, name, options, fileDescriptors) {\n  if (obj instanceof Protobuf.Service) {\n    return createServiceDefinition(obj, name, options, fileDescriptors);\n  } else if (obj instanceof Protobuf.Type) {\n    return createMessageDefinition(obj, fileDescriptors);\n  } else if (obj instanceof Protobuf.Enum) {\n    return createEnumDefinition(obj, fileDescriptors);\n  } else {\n    throw new Error('Type mismatch in reflection object handling');\n  }\n}\nfunction createPackageDefinition(root, options) {\n  const def = {};\n  root.resolveAll();\n  const descriptorList = root.toDescriptor('proto3').file;\n  const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n  for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {\n    def[name] = createDefinition(obj, name, options, bufferList);\n  }\n  return def;\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n  options = options || {};\n  const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n  root.resolveAll();\n  return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.json Represent Infinity and NaN as strings in float fields,\n *     and automatically decode google.protobuf.Any values.\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\nfunction load(filename, options) {\n  return (0, util_1.loadProtosWithOptions)(filename, options).then(loadedRoot => {\n    return createPackageDefinition(loadedRoot, options);\n  });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n  const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);\n  return createPackageDefinition(loadedRoot, options);\n}\nexports.loadSync = loadSync;\nfunction fromJSON(json, options) {\n  options = options || {};\n  const loadedRoot = Protobuf.Root.fromJSON(json);\n  loadedRoot.resolveAll();\n  return createPackageDefinition(loadedRoot, options);\n}\nexports.fromJSON = fromJSON;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n  const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n  return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n  const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n  return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\n(0, util_1.addCommonProtos)();\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}