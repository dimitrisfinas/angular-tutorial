{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResolvingLoadBalancer = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst service_config_1 = require(\"./service-config\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst resolver_1 = require(\"./resolver\");\nconst picker_1 = require(\"./picker\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst load_balancer_child_handler_1 = require(\"./load-balancer-child-handler\");\nconst TRACER_NAME = 'resolving_load_balancer';\nfunction trace(text) {\n  logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst DEFAULT_LOAD_BALANCER_NAME = 'pick_first';\nfunction getDefaultConfigSelector(serviceConfig) {\n  return function defaultConfigSelector(methodName, metadata) {\n    var _a, _b;\n    const splitName = methodName.split('/').filter(x => x.length > 0);\n    const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';\n    const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';\n    if (serviceConfig && serviceConfig.methodConfig) {\n      for (const methodConfig of serviceConfig.methodConfig) {\n        for (const name of methodConfig.name) {\n          if (name.service === service && (name.method === undefined || name.method === method)) {\n            return {\n              methodConfig: methodConfig,\n              pickInformation: {},\n              status: constants_1.Status.OK,\n              dynamicFilterFactories: []\n            };\n          }\n        }\n      }\n    }\n    return {\n      methodConfig: {\n        name: []\n      },\n      pickInformation: {},\n      status: constants_1.Status.OK,\n      dynamicFilterFactories: []\n    };\n  };\n}\nclass ResolvingLoadBalancer {\n  /**\n   * Wrapper class that behaves like a `LoadBalancer` and also handles name\n   * resolution internally.\n   * @param target The address of the backend to connect to.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   * @param defaultServiceConfig The default service configuration to be used\n   *     if none is provided by the name resolver. A `null` value indicates\n   *     that the default behavior should be the default unconfigured behavior.\n   *     In practice, that means using the \"pick first\" load balancer\n   *     implmentation\n   */\n  constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {\n    this.target = target;\n    this.channelControlHelper = channelControlHelper;\n    this.channelOptions = channelOptions;\n    this.onSuccessfulResolution = onSuccessfulResolution;\n    this.onFailedResolution = onFailedResolution;\n    this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n    this.latestChildPicker = new picker_1.QueuePicker(this);\n    /**\n     * This resolving load balancer's current connectivity state.\n     */\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The service config object from the last successful resolution, if\n     * available. A value of null indicates that we have not yet received a valid\n     * service config from the resolver.\n     */\n    this.previousServiceConfig = null;\n    /**\n     * Indicates whether we should attempt to resolve again after the backoff\n     * timer runs out.\n     */\n    this.continueResolving = false;\n    if (channelOptions['grpc.service_config']) {\n      this.defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(channelOptions['grpc.service_config']));\n    } else {\n      this.defaultServiceConfig = {\n        loadBalancingConfig: [],\n        methodConfig: []\n      };\n    }\n    this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n      createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n      requestReresolution: () => {\n        /* If the backoffTimeout is running, we're still backing off from\n         * making resolve requests, so we shouldn't make another one here.\n         * In that case, the backoff timer callback will call\n         * updateResolution */\n        if (this.backoffTimeout.isRunning()) {\n          this.continueResolving = true;\n        } else {\n          this.updateResolution();\n        }\n      },\n      updateState: (newState, picker) => {\n        this.latestChildState = newState;\n        this.latestChildPicker = picker;\n        this.updateState(newState, picker);\n      },\n      addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\n      removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)\n    });\n    this.innerResolver = resolver_1.createResolver(target, {\n      onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {\n        var _a;\n        let workingServiceConfig = null;\n        /* This first group of conditionals implements the algorithm described\n         * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n         * in the section called \"Behavior on receiving a new gRPC Config\".\n         */\n        if (serviceConfig === null) {\n          // Step 4 and 5\n          if (serviceConfigError === null) {\n            // Step 5\n            this.previousServiceConfig = null;\n            workingServiceConfig = this.defaultServiceConfig;\n          } else {\n            // Step 4\n            if (this.previousServiceConfig === null) {\n              // Step 4.ii\n              this.handleResolutionFailure(serviceConfigError);\n            } else {\n              // Step 4.i\n              workingServiceConfig = this.previousServiceConfig;\n            }\n          }\n        } else {\n          // Step 3\n          workingServiceConfig = serviceConfig;\n          this.previousServiceConfig = serviceConfig;\n        }\n        const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n        const loadBalancingConfig = load_balancer_1.getFirstUsableConfig(workingConfigList, true);\n        if (loadBalancingConfig === null) {\n          // There were load balancing configs but none are supported. This counts as a resolution failure\n          this.handleResolutionFailure({\n            code: constants_1.Status.UNAVAILABLE,\n            details: 'All load balancer options in service config are not compatible',\n            metadata: new metadata_1.Metadata()\n          });\n          return;\n        }\n        this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);\n        const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\n        this.onSuccessfulResolution(configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\n      },\n      onError: error => {\n        this.handleResolutionFailure(error);\n      }\n    }, channelOptions);\n    const backoffOptions = {\n      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      if (this.continueResolving) {\n        this.updateResolution();\n        this.continueResolving = false;\n      } else {\n        this.updateState(this.latestChildState, this.latestChildPicker);\n      }\n    }, backoffOptions);\n    this.backoffTimeout.unref();\n  }\n  updateResolution() {\n    this.innerResolver.updateResolution();\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n      this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n    }\n    this.backoffTimeout.runOnce();\n  }\n  updateState(connectivityState, picker) {\n    trace(uri_parser_1.uriToString(this.target) + ' ' + connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[connectivityState]);\n    // Ensure that this.exitIdle() is called by the picker\n    if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\n      picker = new picker_1.QueuePicker(this);\n    }\n    this.currentState = connectivityState;\n    this.channelControlHelper.updateState(connectivityState, picker);\n  }\n  handleResolutionFailure(error) {\n    if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\n      this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n      this.onFailedResolution(error);\n    }\n  }\n  exitIdle() {\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n      if (this.backoffTimeout.isRunning()) {\n        this.continueResolving = true;\n      } else {\n        this.updateResolution();\n      }\n    }\n    this.childLoadBalancer.exitIdle();\n  }\n  updateAddressList(addressList, lbConfig) {\n    throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n  }\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.childLoadBalancer.resetBackoff();\n  }\n  destroy() {\n    this.childLoadBalancer.destroy();\n    this.innerResolver.destroy();\n    this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());\n  }\n  getTypeName() {\n    return 'resolving_load_balancer';\n  }\n}\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;\n//# sourceMappingURL=resolving-load-balancer.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}