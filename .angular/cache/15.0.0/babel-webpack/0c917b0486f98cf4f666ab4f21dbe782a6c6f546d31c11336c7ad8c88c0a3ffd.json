{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Metadata = void 0;\nconst logging_1 = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\nfunction isLegalKey(key) {\n  return LEGAL_KEY_REGEX.test(key);\n}\nfunction isLegalNonBinaryValue(value) {\n  return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\nfunction isBinaryKey(key) {\n  return key.endsWith('-bin');\n}\nfunction isCustomMetadata(key) {\n  return !key.startsWith('grpc-');\n}\nfunction normalizeKey(key) {\n  return key.toLowerCase();\n}\nfunction validate(key, value) {\n  if (!isLegalKey(key)) {\n    throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n  }\n  if (value !== null && value !== undefined) {\n    if (isBinaryKey(key)) {\n      if (!Buffer.isBuffer(value)) {\n        throw new Error(\"keys that end with '-bin' must have Buffer values\");\n      }\n    } else {\n      if (Buffer.isBuffer(value)) {\n        throw new Error(\"keys that don't end with '-bin' must have String values\");\n      }\n      if (!isLegalNonBinaryValue(value)) {\n        throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n      }\n    }\n  }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\nclass Metadata {\n  constructor(options = {}) {\n    this.internalRepr = new Map();\n    this.options = options;\n  }\n  /**\n   * Sets the given value for the given key by replacing any other values\n   * associated with that key. Normalizes the key.\n   * @param key The key to whose value should be set.\n   * @param value The value to set. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n  set(key, value) {\n    key = normalizeKey(key);\n    validate(key, value);\n    this.internalRepr.set(key, [value]);\n  }\n  /**\n   * Adds the given value for the given key by appending to a list of previous\n   * values associated with that key. Normalizes the key.\n   * @param key The key for which a new value should be appended.\n   * @param value The value to add. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n  add(key, value) {\n    key = normalizeKey(key);\n    validate(key, value);\n    const existingValue = this.internalRepr.get(key);\n    if (existingValue === undefined) {\n      this.internalRepr.set(key, [value]);\n    } else {\n      existingValue.push(value);\n    }\n  }\n  /**\n   * Removes the given key and any associated values. Normalizes the key.\n   * @param key The key whose values should be removed.\n   */\n  remove(key) {\n    key = normalizeKey(key);\n    // validate(key);\n    this.internalRepr.delete(key);\n  }\n  /**\n   * Gets a list of all values associated with the key. Normalizes the key.\n   * @param key The key whose value should be retrieved.\n   * @return A list of values associated with the given key.\n   */\n  get(key) {\n    key = normalizeKey(key);\n    // validate(key);\n    return this.internalRepr.get(key) || [];\n  }\n  /**\n   * Gets a plain object mapping each key to the first value associated with it.\n   * This reflects the most common way that people will want to see metadata.\n   * @return A key/value mapping of the metadata.\n   */\n  getMap() {\n    const result = {};\n    for (const [key, values] of this.internalRepr) {\n      if (values.length > 0) {\n        const v = values[0];\n        result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\n      }\n    }\n    return result;\n  }\n  /**\n   * Clones the metadata object.\n   * @return The newly cloned object.\n   */\n  clone() {\n    const newMetadata = new Metadata(this.options);\n    const newInternalRepr = newMetadata.internalRepr;\n    for (const [key, value] of this.internalRepr) {\n      const clonedValue = value.map(v => {\n        if (Buffer.isBuffer(v)) {\n          return Buffer.from(v);\n        } else {\n          return v;\n        }\n      });\n      newInternalRepr.set(key, clonedValue);\n    }\n    return newMetadata;\n  }\n  /**\n   * Merges all key-value pairs from a given Metadata object into this one.\n   * If both this object and the given object have values in the same key,\n   * values from the other Metadata object will be appended to this object's\n   * values.\n   * @param other A Metadata object.\n   */\n  merge(other) {\n    for (const [key, values] of other.internalRepr) {\n      const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n      this.internalRepr.set(key, mergedValue);\n    }\n  }\n  setOptions(options) {\n    this.options = options;\n  }\n  getOptions() {\n    return this.options;\n  }\n  /**\n   * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n   */\n  toHttp2Headers() {\n    // NOTE: Node <8.9 formats http2 headers incorrectly.\n    const result = {};\n    for (const [key, values] of this.internalRepr) {\n      // We assume that the user's interaction with this object is limited to\n      // through its public API (i.e. keys and values are already validated).\n      result[key] = values.map(bufToString);\n    }\n    return result;\n  }\n  // For compatibility with the other Metadata implementation\n  _getCoreRepresentation() {\n    return this.internalRepr;\n  }\n  /**\n   * This modifies the behavior of JSON.stringify to show an object\n   * representation of the metadata map.\n   */\n  toJSON() {\n    const result = {};\n    for (const [key, values] of this.internalRepr) {\n      result[key] = values;\n    }\n    return result;\n  }\n  /**\n   * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n   * object.\n   * @param headers An IncomingHttpHeaders object.\n   */\n  static fromHttp2Headers(headers) {\n    const result = new Metadata();\n    for (const key of Object.keys(headers)) {\n      // Reserved headers (beginning with `:`) are not valid keys.\n      if (key.charAt(0) === ':') {\n        continue;\n      }\n      const values = headers[key];\n      try {\n        if (isBinaryKey(key)) {\n          if (Array.isArray(values)) {\n            values.forEach(value => {\n              result.add(key, Buffer.from(value, 'base64'));\n            });\n          } else if (values !== undefined) {\n            if (isCustomMetadata(key)) {\n              values.split(',').forEach(v => {\n                result.add(key, Buffer.from(v.trim(), 'base64'));\n              });\n            } else {\n              result.add(key, Buffer.from(values, 'base64'));\n            }\n          }\n        } else {\n          if (Array.isArray(values)) {\n            values.forEach(value => {\n              result.add(key, value);\n            });\n          } else if (values !== undefined) {\n            result.add(key, values);\n          }\n        }\n      } catch (error) {\n        const message = `Failed to add metadata entry ${key}: ${values}. ${error.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n        logging_1.log(constants_1.LogVerbosity.ERROR, message);\n      }\n    }\n    return result;\n  }\n}\nexports.Metadata = Metadata;\nconst bufToString = val => {\n  return Buffer.isBuffer(val) ? val.toString('base64') : val;\n};\n//# sourceMappingURL=metadata.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}