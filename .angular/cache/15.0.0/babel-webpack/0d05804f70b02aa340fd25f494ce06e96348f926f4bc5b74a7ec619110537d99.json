{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport * as api from '@opentelemetry/api';\nimport { isWrapped, InstrumentationBase, safeExecuteInTheMiddle } from '@opentelemetry/instrumentation';\nimport { hrTime, isUrlIgnored, otperformance } from '@opentelemetry/core';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { addSpanNetworkEvents, getResource, PerformanceTimingNames as PTN, shouldPropagateTraceHeaders, parseUrl } from '@opentelemetry/sdk-trace-web';\nimport { EventNames } from './enums/EventNames';\nimport { VERSION } from './version';\nimport { AttributeNames } from './enums/AttributeNames';\n// how long to wait for observer to collect information about resources\n// this is needed as event \"load\" is called before observer\n// hard to say how long it should really wait, seems like 300ms is\n// safe enough\nvar OBSERVER_WAIT_TIME_MS = 300;\n/**\n * This class represents a XMLHttpRequest plugin for auto instrumentation\n */\nvar XMLHttpRequestInstrumentation = /** @class */function (_super) {\n  __extends(XMLHttpRequestInstrumentation, _super);\n  function XMLHttpRequestInstrumentation(config) {\n    var _this = _super.call(this, '@opentelemetry/instrumentation-xml-http-request', VERSION, config) || this;\n    _this.component = 'xml-http-request';\n    _this.version = VERSION;\n    _this.moduleName = _this.component;\n    _this._tasksCount = 0;\n    _this._xhrMem = new WeakMap();\n    _this._usedResources = new WeakSet();\n    return _this;\n  }\n  XMLHttpRequestInstrumentation.prototype.init = function () {};\n  XMLHttpRequestInstrumentation.prototype._getConfig = function () {\n    return this._config;\n  };\n  /**\n   * Adds custom headers to XMLHttpRequest\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._addHeaders = function (xhr, spanUrl) {\n    var url = parseUrl(spanUrl).href;\n    if (!shouldPropagateTraceHeaders(url, this._getConfig().propagateTraceHeaderCorsUrls)) {\n      var headers_1 = {};\n      api.propagation.inject(api.context.active(), headers_1);\n      if (Object.keys(headers_1).length > 0) {\n        this._diag.debug('headers inject skipped due to CORS policy');\n      }\n      return;\n    }\n    var headers = {};\n    api.propagation.inject(api.context.active(), headers);\n    Object.keys(headers).forEach(function (key) {\n      xhr.setRequestHeader(key, String(headers[key]));\n    });\n  };\n  /**\n   * Add cors pre flight child span\n   * @param span\n   * @param corsPreFlightRequest\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._addChildSpan = function (span, corsPreFlightRequest) {\n    var _this = this;\n    api.context.with(api.trace.setSpan(api.context.active(), span), function () {\n      var childSpan = _this.tracer.startSpan('CORS Preflight', {\n        startTime: corsPreFlightRequest[PTN.FETCH_START]\n      });\n      addSpanNetworkEvents(childSpan, corsPreFlightRequest);\n      childSpan.end(corsPreFlightRequest[PTN.RESPONSE_END]);\n    });\n  };\n  /**\n   * Add attributes when span is going to end\n   * @param span\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._addFinalSpanAttributes = function (span, xhrMem, spanUrl) {\n    if (typeof spanUrl === 'string') {\n      var parsedUrl = parseUrl(spanUrl);\n      if (xhrMem.status !== undefined) {\n        span.setAttribute(SemanticAttributes.HTTP_STATUS_CODE, xhrMem.status);\n      }\n      if (xhrMem.statusText !== undefined) {\n        span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, xhrMem.statusText);\n      }\n      span.setAttribute(SemanticAttributes.HTTP_HOST, parsedUrl.host);\n      span.setAttribute(SemanticAttributes.HTTP_SCHEME, parsedUrl.protocol.replace(':', ''));\n      // @TODO do we want to collect this or it will be collected earlier once only or\n      //    maybe when parent span is not available ?\n      span.setAttribute(SemanticAttributes.HTTP_USER_AGENT, navigator.userAgent);\n    }\n  };\n  XMLHttpRequestInstrumentation.prototype._applyAttributesAfterXHR = function (span, xhr) {\n    var _this = this;\n    var applyCustomAttributesOnSpan = this._getConfig().applyCustomAttributesOnSpan;\n    if (typeof applyCustomAttributesOnSpan === 'function') {\n      safeExecuteInTheMiddle(function () {\n        return applyCustomAttributesOnSpan(span, xhr);\n      }, function (error) {\n        if (!error) {\n          return;\n        }\n        _this._diag.error('applyCustomAttributesOnSpan', error);\n      }, true);\n    }\n  };\n  /**\n   * will collect information about all resources created\n   * between \"send\" and \"end\" with additional waiting for main resource\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._addResourceObserver = function (xhr, spanUrl) {\n    var xhrMem = this._xhrMem.get(xhr);\n    if (!xhrMem || typeof PerformanceObserver !== 'function' || typeof PerformanceResourceTiming !== 'function') {\n      return;\n    }\n    xhrMem.createdResources = {\n      observer: new PerformanceObserver(function (list) {\n        var entries = list.getEntries();\n        var parsedUrl = parseUrl(spanUrl);\n        entries.forEach(function (entry) {\n          if (entry.initiatorType === 'xmlhttprequest' && entry.name === parsedUrl.href) {\n            if (xhrMem.createdResources) {\n              xhrMem.createdResources.entries.push(entry);\n            }\n          }\n        });\n      }),\n      entries: []\n    };\n    xhrMem.createdResources.observer.observe({\n      entryTypes: ['resource']\n    });\n  };\n  /**\n   * Clears the resource timings and all resources assigned with spans\n   *     when {@link XMLHttpRequestInstrumentationConfig.clearTimingResources} is\n   *     set to true (default false)\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._clearResources = function () {\n    if (this._tasksCount === 0 && this._getConfig().clearTimingResources) {\n      otperformance.clearResourceTimings();\n      this._xhrMem = new WeakMap();\n      this._usedResources = new WeakSet();\n    }\n  };\n  /**\n   * Finds appropriate resource and add network events to the span\n   * @param span\n   */\n  XMLHttpRequestInstrumentation.prototype._findResourceAndAddNetworkEvents = function (xhrMem, span, spanUrl, startTime, endTime) {\n    if (!spanUrl || !startTime || !endTime || !xhrMem.createdResources) {\n      return;\n    }\n    var resources = xhrMem.createdResources.entries;\n    if (!resources || !resources.length) {\n      // fallback - either Observer is not available or it took longer\n      // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough\n      // information\n      // ts thinks this is the perf_hooks module, but it is the browser performance api\n      resources = otperformance.getEntriesByType('resource');\n    }\n    var resource = getResource(parseUrl(spanUrl).href, startTime, endTime, resources, this._usedResources);\n    if (resource.mainRequest) {\n      var mainRequest = resource.mainRequest;\n      this._markResourceAsUsed(mainRequest);\n      var corsPreFlightRequest = resource.corsPreFlightRequest;\n      if (corsPreFlightRequest) {\n        this._addChildSpan(span, corsPreFlightRequest);\n        this._markResourceAsUsed(corsPreFlightRequest);\n      }\n      addSpanNetworkEvents(span, mainRequest);\n    }\n  };\n  /**\n   * Removes the previous information about span.\n   * This might happened when the same xhr is used again.\n   * @param xhr\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._cleanPreviousSpanInformation = function (xhr) {\n    var xhrMem = this._xhrMem.get(xhr);\n    if (xhrMem) {\n      var callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;\n      if (callbackToRemoveEvents) {\n        callbackToRemoveEvents();\n      }\n      this._xhrMem.delete(xhr);\n    }\n  };\n  /**\n   * Creates a new span when method \"open\" is called\n   * @param xhr\n   * @param url\n   * @param method\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._createSpan = function (xhr, url, method) {\n    var _a;\n    if (isUrlIgnored(url, this._getConfig().ignoreUrls)) {\n      this._diag.debug('ignoring span as url matches ignored url');\n      return;\n    }\n    var spanName = \"HTTP \" + method.toUpperCase();\n    var currentSpan = this.tracer.startSpan(spanName, {\n      kind: api.SpanKind.CLIENT,\n      attributes: (_a = {}, _a[SemanticAttributes.HTTP_METHOD] = method, _a[SemanticAttributes.HTTP_URL] = url, _a)\n    });\n    currentSpan.addEvent(EventNames.METHOD_OPEN);\n    this._cleanPreviousSpanInformation(xhr);\n    this._xhrMem.set(xhr, {\n      span: currentSpan,\n      spanUrl: url\n    });\n    return currentSpan;\n  };\n  /**\n   * Marks certain [resource]{@link PerformanceResourceTiming} when information\n   * from this is used to add events to span.\n   * This is done to avoid reusing the same resource again for next span\n   * @param resource\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._markResourceAsUsed = function (resource) {\n    this._usedResources.add(resource);\n  };\n  /**\n   * Patches the method open\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._patchOpen = function () {\n    var _this = this;\n    return function (original) {\n      var plugin = _this;\n      return function patchOpen() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var method = args[0];\n        var url = args[1];\n        plugin._createSpan(this, url, method);\n        return original.apply(this, args);\n      };\n    };\n  };\n  /**\n   * Patches the method send\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._patchSend = function () {\n    var plugin = this;\n    function endSpanTimeout(eventName, xhrMem, endTime) {\n      var callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;\n      if (typeof callbackToRemoveEvents === 'function') {\n        callbackToRemoveEvents();\n      }\n      var span = xhrMem.span,\n        spanUrl = xhrMem.spanUrl,\n        sendStartTime = xhrMem.sendStartTime;\n      if (span) {\n        plugin._findResourceAndAddNetworkEvents(xhrMem, span, spanUrl, sendStartTime, endTime);\n        span.addEvent(eventName, endTime);\n        plugin._addFinalSpanAttributes(span, xhrMem, spanUrl);\n        span.end(endTime);\n        plugin._tasksCount--;\n      }\n      plugin._clearResources();\n    }\n    function endSpan(eventName, xhr) {\n      var xhrMem = plugin._xhrMem.get(xhr);\n      if (!xhrMem) {\n        return;\n      }\n      xhrMem.status = xhr.status;\n      xhrMem.statusText = xhr.statusText;\n      plugin._xhrMem.delete(xhr);\n      if (xhrMem.span) {\n        plugin._applyAttributesAfterXHR(xhrMem.span, xhr);\n      }\n      var endTime = hrTime();\n      // the timeout is needed as observer doesn't have yet information\n      // when event \"load\" is called. Also the time may differ depends on\n      // browser and speed of computer\n      setTimeout(function () {\n        endSpanTimeout(eventName, xhrMem, endTime);\n      }, OBSERVER_WAIT_TIME_MS);\n    }\n    function onError() {\n      endSpan(EventNames.EVENT_ERROR, this);\n    }\n    function onAbort() {\n      endSpan(EventNames.EVENT_ABORT, this);\n    }\n    function onTimeout() {\n      endSpan(EventNames.EVENT_TIMEOUT, this);\n    }\n    function onLoad() {\n      if (this.status < 299) {\n        endSpan(EventNames.EVENT_LOAD, this);\n      } else {\n        endSpan(EventNames.EVENT_ERROR, this);\n      }\n    }\n    function unregister(xhr) {\n      xhr.removeEventListener('abort', onAbort);\n      xhr.removeEventListener('error', onError);\n      xhr.removeEventListener('load', onLoad);\n      xhr.removeEventListener('timeout', onTimeout);\n      var xhrMem = plugin._xhrMem.get(xhr);\n      if (xhrMem) {\n        xhrMem.callbackToRemoveEvents = undefined;\n      }\n    }\n    return function (original) {\n      return function patchSend() {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var xhrMem = plugin._xhrMem.get(this);\n        if (!xhrMem) {\n          return original.apply(this, args);\n        }\n        var currentSpan = xhrMem.span;\n        var spanUrl = xhrMem.spanUrl;\n        if (currentSpan && spanUrl) {\n          api.context.with(api.trace.setSpan(api.context.active(), currentSpan), function () {\n            plugin._tasksCount++;\n            xhrMem.sendStartTime = hrTime();\n            currentSpan.addEvent(EventNames.METHOD_SEND);\n            _this.addEventListener('abort', onAbort);\n            _this.addEventListener('error', onError);\n            _this.addEventListener('load', onLoad);\n            _this.addEventListener('timeout', onTimeout);\n            xhrMem.callbackToRemoveEvents = function () {\n              unregister(_this);\n              if (xhrMem.createdResources) {\n                xhrMem.createdResources.observer.disconnect();\n              }\n            };\n            plugin._addHeaders(_this, spanUrl);\n            plugin._addResourceObserver(_this, spanUrl);\n          });\n        }\n        return original.apply(this, args);\n      };\n    };\n  };\n  /**\n   * implements enable function\n   */\n  XMLHttpRequestInstrumentation.prototype.enable = function () {\n    this._diag.debug('applying patch to', this.moduleName, this.version);\n    if (isWrapped(XMLHttpRequest.prototype.open)) {\n      this._unwrap(XMLHttpRequest.prototype, 'open');\n      this._diag.debug('removing previous patch from method open');\n    }\n    if (isWrapped(XMLHttpRequest.prototype.send)) {\n      this._unwrap(XMLHttpRequest.prototype, 'send');\n      this._diag.debug('removing previous patch from method send');\n    }\n    this._wrap(XMLHttpRequest.prototype, 'open', this._patchOpen());\n    this._wrap(XMLHttpRequest.prototype, 'send', this._patchSend());\n  };\n  /**\n   * implements disable function\n   */\n  XMLHttpRequestInstrumentation.prototype.disable = function () {\n    this._diag.debug('removing patch from', this.moduleName, this.version);\n    this._unwrap(XMLHttpRequest.prototype, 'open');\n    this._unwrap(XMLHttpRequest.prototype, 'send');\n    this._tasksCount = 0;\n    this._xhrMem = new WeakMap();\n    this._usedResources = new WeakSet();\n  };\n  return XMLHttpRequestInstrumentation;\n}(InstrumentationBase);\nexport { XMLHttpRequestInstrumentation };\n//# sourceMappingURL=xhr.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}