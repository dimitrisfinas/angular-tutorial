{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTracker = exports.ChannelzChildrenTracker = exports.ChannelzTrace = void 0;\nconst net_1 = require(\"net\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst constants_1 = require(\"./constants\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst admin_1 = require(\"./admin\");\nconst make_client_1 = require(\"./make-client\");\nfunction channelRefToMessage(ref) {\n  return {\n    channel_id: ref.id,\n    name: ref.name\n  };\n}\nfunction subchannelRefToMessage(ref) {\n  return {\n    subchannel_id: ref.id,\n    name: ref.name\n  };\n}\nfunction serverRefToMessage(ref) {\n  return {\n    server_id: ref.id\n  };\n}\nfunction socketRefToMessage(ref) {\n  return {\n    socket_id: ref.id,\n    name: ref.name\n  };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\nconst TARGET_RETAINED_TRACES = 32;\nclass ChannelzTrace {\n  constructor() {\n    this.events = [];\n    this.eventsLogged = 0;\n    this.creationTimestamp = new Date();\n  }\n  addTrace(severity, description, child) {\n    const timestamp = new Date();\n    this.events.push({\n      description: description,\n      severity: severity,\n      timestamp: timestamp,\n      childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,\n      childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined\n    });\n    // Whenever the trace array gets too large, discard the first half\n    if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n      this.events = this.events.slice(TARGET_RETAINED_TRACES);\n    }\n    this.eventsLogged += 1;\n  }\n  getTraceMessage() {\n    return {\n      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n      num_events_logged: this.eventsLogged,\n      events: this.events.map(event => {\n        return {\n          description: event.description,\n          severity: event.severity,\n          timestamp: dateToProtoTimestamp(event.timestamp),\n          channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n          subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n        };\n      })\n    };\n  }\n}\nexports.ChannelzTrace = ChannelzTrace;\nclass ChannelzChildrenTracker {\n  constructor() {\n    this.channelChildren = new Map();\n    this.subchannelChildren = new Map();\n    this.socketChildren = new Map();\n  }\n  refChild(child) {\n    var _a, _b, _c;\n    switch (child.kind) {\n      case 'channel':\n        {\n          let trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : {\n            ref: child,\n            count: 0\n          };\n          trackedChild.count += 1;\n          this.channelChildren.set(child.id, trackedChild);\n          break;\n        }\n      case 'subchannel':\n        {\n          let trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : {\n            ref: child,\n            count: 0\n          };\n          trackedChild.count += 1;\n          this.subchannelChildren.set(child.id, trackedChild);\n          break;\n        }\n      case 'socket':\n        {\n          let trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : {\n            ref: child,\n            count: 0\n          };\n          trackedChild.count += 1;\n          this.socketChildren.set(child.id, trackedChild);\n          break;\n        }\n    }\n  }\n  unrefChild(child) {\n    switch (child.kind) {\n      case 'channel':\n        {\n          let trackedChild = this.channelChildren.get(child.id);\n          if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n            if (trackedChild.count === 0) {\n              this.channelChildren.delete(child.id);\n            } else {\n              this.channelChildren.set(child.id, trackedChild);\n            }\n          }\n          break;\n        }\n      case 'subchannel':\n        {\n          let trackedChild = this.subchannelChildren.get(child.id);\n          if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n            if (trackedChild.count === 0) {\n              this.subchannelChildren.delete(child.id);\n            } else {\n              this.subchannelChildren.set(child.id, trackedChild);\n            }\n          }\n          break;\n        }\n      case 'socket':\n        {\n          let trackedChild = this.socketChildren.get(child.id);\n          if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n            if (trackedChild.count === 0) {\n              this.socketChildren.delete(child.id);\n            } else {\n              this.socketChildren.set(child.id, trackedChild);\n            }\n          }\n          break;\n        }\n    }\n  }\n  getChildLists() {\n    const channels = [];\n    for (const {\n      ref\n    } of this.channelChildren.values()) {\n      channels.push(ref);\n    }\n    const subchannels = [];\n    for (const {\n      ref\n    } of this.subchannelChildren.values()) {\n      subchannels.push(ref);\n    }\n    const sockets = [];\n    for (const {\n      ref\n    } of this.socketChildren.values()) {\n      sockets.push(ref);\n    }\n    return {\n      channels,\n      subchannels,\n      sockets\n    };\n  }\n}\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\nclass ChannelzCallTracker {\n  constructor() {\n    this.callsStarted = 0;\n    this.callsSucceeded = 0;\n    this.callsFailed = 0;\n    this.lastCallStartedTimestamp = null;\n  }\n  addCallStarted() {\n    this.callsStarted += 1;\n    this.lastCallStartedTimestamp = new Date();\n  }\n  addCallSucceeded() {\n    this.callsSucceeded += 1;\n  }\n  addCallFailed() {\n    this.callsFailed += 1;\n  }\n}\nexports.ChannelzCallTracker = ChannelzCallTracker;\nlet nextId = 1;\nfunction getNextId() {\n  return nextId++;\n}\nconst channels = [];\nconst subchannels = [];\nconst servers = [];\nconst sockets = [];\nfunction registerChannelzChannel(name, getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    name,\n    kind: 'channel'\n  };\n  if (channelzEnabled) {\n    channels[id] = {\n      ref,\n      getInfo\n    };\n  }\n  return ref;\n}\nexports.registerChannelzChannel = registerChannelzChannel;\nfunction registerChannelzSubchannel(name, getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    name,\n    kind: 'subchannel'\n  };\n  if (channelzEnabled) {\n    subchannels[id] = {\n      ref,\n      getInfo\n    };\n  }\n  return ref;\n}\nexports.registerChannelzSubchannel = registerChannelzSubchannel;\nfunction registerChannelzServer(getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    kind: 'server'\n  };\n  if (channelzEnabled) {\n    servers[id] = {\n      ref,\n      getInfo\n    };\n  }\n  return ref;\n}\nexports.registerChannelzServer = registerChannelzServer;\nfunction registerChannelzSocket(name, getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    name,\n    kind: 'socket'\n  };\n  if (channelzEnabled) {\n    sockets[id] = {\n      ref,\n      getInfo\n    };\n  }\n  return ref;\n}\nexports.registerChannelzSocket = registerChannelzSocket;\nfunction unregisterChannelzRef(ref) {\n  switch (ref.kind) {\n    case 'channel':\n      delete channels[ref.id];\n      return;\n    case 'subchannel':\n      delete subchannels[ref.id];\n      return;\n    case 'server':\n      delete servers[ref.id];\n      return;\n    case 'socket':\n      delete sockets[ref.id];\n      return;\n  }\n}\nexports.unregisterChannelzRef = unregisterChannelzRef;\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\nfunction parseIPv6Section(addressSection) {\n  const numberValue = Number.parseInt(addressSection, 16);\n  return [numberValue / 256 | 0, numberValue % 256];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\nfunction parseIPv6Chunk(addressChunk) {\n  if (addressChunk === '') {\n    return [];\n  }\n  const bytePairs = addressChunk.split(':').map(section => parseIPv6Section(section));\n  const result = [];\n  return result.concat(...bytePairs);\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */\nfunction ipAddressStringToBuffer(ipAddress) {\n  if (net_1.isIPv4(ipAddress)) {\n    return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\n  } else if (net_1.isIPv6(ipAddress)) {\n    let leftSection;\n    let rightSection;\n    const doubleColonIndex = ipAddress.indexOf('::');\n    if (doubleColonIndex === -1) {\n      leftSection = ipAddress;\n      rightSection = '';\n    } else {\n      leftSection = ipAddress.substring(0, doubleColonIndex);\n      rightSection = ipAddress.substring(doubleColonIndex + 2);\n    }\n    const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n    const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n    const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n    return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n  } else {\n    return null;\n  }\n}\nfunction connectivityStateToMessage(state) {\n  switch (state) {\n    case connectivity_state_1.ConnectivityState.CONNECTING:\n      return {\n        state: 'CONNECTING'\n      };\n    case connectivity_state_1.ConnectivityState.IDLE:\n      return {\n        state: 'IDLE'\n      };\n    case connectivity_state_1.ConnectivityState.READY:\n      return {\n        state: 'READY'\n      };\n    case connectivity_state_1.ConnectivityState.SHUTDOWN:\n      return {\n        state: 'SHUTDOWN'\n      };\n    case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n      return {\n        state: 'TRANSIENT_FAILURE'\n      };\n    default:\n      return {\n        state: 'UNKNOWN'\n      };\n  }\n}\nfunction dateToProtoTimestamp(date) {\n  if (!date) {\n    return null;\n  }\n  const millisSinceEpoch = date.getTime();\n  return {\n    seconds: millisSinceEpoch / 1000 | 0,\n    nanos: millisSinceEpoch % 1000 * 1000000\n  };\n}\nfunction getChannelMessage(channelEntry) {\n  const resolvedInfo = channelEntry.getInfo();\n  return {\n    ref: channelRefToMessage(channelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    channel_ref: resolvedInfo.children.channels.map(ref => channelRefToMessage(ref)),\n    subchannel_ref: resolvedInfo.children.subchannels.map(ref => subchannelRefToMessage(ref))\n  };\n}\nfunction GetChannel(call, callback) {\n  const channelId = Number.parseInt(call.request.channel_id);\n  const channelEntry = channels[channelId];\n  if (channelEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No channel data found for id ' + channelId\n    });\n    return;\n  }\n  callback(null, {\n    channel: getChannelMessage(channelEntry)\n  });\n}\nfunction GetTopChannels(call, callback) {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList = [];\n  let i = Number.parseInt(call.request.start_channel_id);\n  for (; i < channels.length; i++) {\n    const channelEntry = channels[i];\n    if (channelEntry === undefined) {\n      continue;\n    }\n    resultList.push(getChannelMessage(channelEntry));\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n  callback(null, {\n    channel: resultList,\n    end: i >= servers.length\n  });\n}\nfunction getServerMessage(serverEntry) {\n  const resolvedInfo = serverEntry.getInfo();\n  return {\n    ref: serverRefToMessage(serverEntry.ref),\n    data: {\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    listen_socket: resolvedInfo.listenerChildren.sockets.map(ref => socketRefToMessage(ref))\n  };\n}\nfunction GetServer(call, callback) {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n  if (serverEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n  callback(null, {\n    server: getServerMessage(serverEntry)\n  });\n}\nfunction GetServers(call, callback) {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList = [];\n  let i = Number.parseInt(call.request.start_server_id);\n  for (; i < servers.length; i++) {\n    const serverEntry = servers[i];\n    if (serverEntry === undefined) {\n      continue;\n    }\n    resultList.push(getServerMessage(serverEntry));\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n  callback(null, {\n    server: resultList,\n    end: i >= servers.length\n  });\n}\nfunction GetSubchannel(call, callback) {\n  const subchannelId = Number.parseInt(call.request.subchannel_id);\n  const subchannelEntry = subchannels[subchannelId];\n  if (subchannelEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No subchannel data found for id ' + subchannelId\n    });\n    return;\n  }\n  const resolvedInfo = subchannelEntry.getInfo();\n  const subchannelMessage = {\n    ref: subchannelRefToMessage(subchannelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    socket_ref: resolvedInfo.children.sockets.map(ref => socketRefToMessage(ref))\n  };\n  callback(null, {\n    subchannel: subchannelMessage\n  });\n}\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n  var _a;\n  if (subchannel_address_1.isTcpSubchannelAddress(subchannelAddress)) {\n    return {\n      address: 'tcpip_address',\n      tcpip_address: {\n        ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n        port: subchannelAddress.port\n      }\n    };\n  } else {\n    return {\n      address: 'uds_address',\n      uds_address: {\n        filename: subchannelAddress.path\n      }\n    };\n  }\n}\nfunction GetSocket(call, callback) {\n  var _a, _b, _c, _d, _e;\n  const socketId = Number.parseInt(call.request.socket_id);\n  const socketEntry = sockets[socketId];\n  if (socketEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No socket data found for id ' + socketId\n    });\n    return;\n  }\n  const resolvedInfo = socketEntry.getInfo();\n  const securityMessage = resolvedInfo.security ? {\n    model: 'tls',\n    tls: {\n      cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? 'standard_name' : 'other_name',\n      standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n      other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n      local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n      remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined\n    }\n  } : null;\n  const socketMessage = {\n    ref: socketRefToMessage(socketEntry.ref),\n    local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n    remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n    remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n    security: securityMessage,\n    data: {\n      keep_alives_sent: resolvedInfo.keepAlivesSent,\n      streams_started: resolvedInfo.streamsStarted,\n      streams_succeeded: resolvedInfo.streamsSucceeded,\n      streams_failed: resolvedInfo.streamsFailed,\n      last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n      last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n      messages_received: resolvedInfo.messagesReceived,\n      messages_sent: resolvedInfo.messagesSent,\n      last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n      last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n      local_flow_control_window: resolvedInfo.localFlowControlWindow ? {\n        value: resolvedInfo.localFlowControlWindow\n      } : null,\n      remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? {\n        value: resolvedInfo.remoteFlowControlWindow\n      } : null\n    }\n  };\n  callback(null, {\n    socket: socketMessage\n  });\n}\nfunction GetServerSockets(call, callback) {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n  if (serverEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n  const startId = Number.parseInt(call.request.start_socket_id);\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resolvedInfo = serverEntry.getInfo();\n  // If we wanted to include listener sockets in the result, this line would\n  // instead say\n  // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n  const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);\n  const resultList = [];\n  let i = 0;\n  for (; i < allSockets.length; i++) {\n    if (allSockets[i].id >= startId) {\n      resultList.push(socketRefToMessage(allSockets[i]));\n      if (resultList.length >= maxResults) {\n        break;\n      }\n    }\n  }\n  callback(null, {\n    socket_ref: resultList,\n    end: i >= allSockets.length\n  });\n}\nfunction getChannelzHandlers() {\n  return {\n    GetChannel,\n    GetTopChannels,\n    GetServer,\n    GetServers,\n    GetSubchannel,\n    GetSocket,\n    GetServerSockets\n  };\n}\nexports.getChannelzHandlers = getChannelzHandlers;\nlet loadedChannelzDefinition = null;\nfunction getChannelzServiceDefinition() {\n  if (loadedChannelzDefinition) {\n    return loadedChannelzDefinition;\n  }\n  /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n   * runtime for users who will not use/enable channelz. */\n  const loaderLoadSync = require('@grpc/proto-loader').loadSync;\n  const loadedProto = loaderLoadSync('channelz.proto', {\n    keepCase: true,\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: true,\n    includeDirs: [`${__dirname}/../../proto`]\n  });\n  const channelzGrpcObject = make_client_1.loadPackageDefinition(loadedProto);\n  loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n  return loadedChannelzDefinition;\n}\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\nfunction setup() {\n  admin_1.registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);\n}\nexports.setup = setup;\n//# sourceMappingURL=channelz.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}