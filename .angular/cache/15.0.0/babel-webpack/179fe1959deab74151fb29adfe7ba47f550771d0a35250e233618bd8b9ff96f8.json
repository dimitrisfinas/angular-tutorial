{"ast":null,"code":"\"use strict\";\n\nvar $protobuf = require(\"../..\");\nmodule.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(require(\"../../google/protobuf/descriptor.json\")).lookup(\".google.protobuf\");\nvar Namespace = $protobuf.Namespace,\n  Root = $protobuf.Root,\n  Enum = $protobuf.Enum,\n  Type = $protobuf.Type,\n  Field = $protobuf.Field,\n  MapField = $protobuf.MapField,\n  OneOf = $protobuf.OneOf,\n  Service = $protobuf.Service,\n  Method = $protobuf.Method;\n\n// --- Root ---\n\n/**\n * Properties of a FileDescriptorSet message.\n * @interface IFileDescriptorSet\n * @property {IFileDescriptorProto[]} file Files\n */\n\n/**\n * Properties of a FileDescriptorProto message.\n * @interface IFileDescriptorProto\n * @property {string} [name] File name\n * @property {string} [package] Package\n * @property {*} [dependency] Not supported\n * @property {*} [publicDependency] Not supported\n * @property {*} [weakDependency] Not supported\n * @property {IDescriptorProto[]} [messageType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IServiceDescriptorProto[]} [service] Nested services\n * @property {IFieldDescriptorProto[]} [extension] Nested extension fields\n * @property {IFileOptions} [options] Options\n * @property {*} [sourceCodeInfo] Not supported\n * @property {string} [syntax=\"proto2\"] Syntax\n */\n\n/**\n * Properties of a FileOptions message.\n * @interface IFileOptions\n * @property {string} [javaPackage]\n * @property {string} [javaOuterClassname]\n * @property {boolean} [javaMultipleFiles]\n * @property {boolean} [javaGenerateEqualsAndHash]\n * @property {boolean} [javaStringCheckUtf8]\n * @property {IFileOptionsOptimizeMode} [optimizeFor=1]\n * @property {string} [goPackage]\n * @property {boolean} [ccGenericServices]\n * @property {boolean} [javaGenericServices]\n * @property {boolean} [pyGenericServices]\n * @property {boolean} [deprecated]\n * @property {boolean} [ccEnableArenas]\n * @property {string} [objcClassPrefix]\n * @property {string} [csharpNamespace]\n */\n\n/**\n * Values of he FileOptions.OptimizeMode enum.\n * @typedef IFileOptionsOptimizeMode\n * @type {number}\n * @property {number} SPEED=1\n * @property {number} CODE_SIZE=2\n * @property {number} LITE_RUNTIME=3\n */\n\n/**\n * Creates a root from a descriptor set.\n * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor\n * @returns {Root} Root instance\n */\nRoot.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.FileDescriptorSet.decode(descriptor);\n  var root = new Root();\n  if (descriptor.file) {\n    var fileDescriptor, filePackage;\n    for (var j = 0, i; j < descriptor.file.length; ++j) {\n      filePackage = root;\n      if ((fileDescriptor = descriptor.file[j])[\"package\"] && fileDescriptor[\"package\"].length) filePackage = root.define(fileDescriptor[\"package\"]);\n      if (fileDescriptor.name && fileDescriptor.name.length) root.files.push(filePackage.filename = fileDescriptor.name);\n      if (fileDescriptor.messageType) for (i = 0; i < fileDescriptor.messageType.length; ++i) filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));\n      if (fileDescriptor.enumType) for (i = 0; i < fileDescriptor.enumType.length; ++i) filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));\n      if (fileDescriptor.extension) for (i = 0; i < fileDescriptor.extension.length; ++i) filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));\n      if (fileDescriptor.service) for (i = 0; i < fileDescriptor.service.length; ++i) filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));\n      var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);\n      if (opts) {\n        var ks = Object.keys(opts);\n        for (i = 0; i < ks.length; ++i) filePackage.setOption(ks[i], opts[ks[i]]);\n      }\n    }\n  }\n  return root;\n};\n\n/**\n * Converts a root to a descriptor set.\n * @returns {Message<IFileDescriptorSet>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\nRoot.prototype.toDescriptor = function toDescriptor(syntax) {\n  var set = exports.FileDescriptorSet.create();\n  Root_toDescriptorRecursive(this, set.file, syntax);\n  return set;\n};\n\n// Traverses a namespace and assembles the descriptor set\nfunction Root_toDescriptorRecursive(ns, files, syntax) {\n  // Create a new file\n  var file = exports.FileDescriptorProto.create({\n    name: ns.filename || (ns.fullName.substring(1).replace(/\\./g, \"_\") || \"root\") + \".proto\"\n  });\n  if (syntax) file.syntax = syntax;\n  if (!(ns instanceof Root)) file[\"package\"] = ns.fullName.substring(1);\n\n  // Add nested types\n  for (var i = 0, nested; i < ns.nestedArray.length; ++i) if ((nested = ns._nestedArray[i]) instanceof Type) file.messageType.push(nested.toDescriptor(syntax));else if (nested instanceof Enum) file.enumType.push(nested.toDescriptor());else if (nested instanceof Field) file.extension.push(nested.toDescriptor(syntax));else if (nested instanceof Service) file.service.push(nested.toDescriptor());else if (nested instanceof /* plain */Namespace) Root_toDescriptorRecursive(nested, files, syntax); // requires new file\n\n  // Keep package-level options\n  file.options = toDescriptorOptions(ns.options, exports.FileOptions);\n\n  // And keep the file only if there is at least one nested object\n  if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length) files.push(file);\n}\n\n// --- Type ---\n\n/**\n * Properties of a DescriptorProto message.\n * @interface IDescriptorProto\n * @property {string} [name] Message type name\n * @property {IFieldDescriptorProto[]} [field] Fields\n * @property {IFieldDescriptorProto[]} [extension] Extension fields\n * @property {IDescriptorProto[]} [nestedType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges\n * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs\n * @property {IMessageOptions} [options] Not supported\n * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges\n * @property {string[]} [reservedName] Reserved names\n */\n\n/**\n * Properties of a MessageOptions message.\n * @interface IMessageOptions\n * @property {boolean} [mapEntry=false] Whether this message is a map entry\n */\n\n/**\n * Properties of an ExtensionRange message.\n * @interface IDescriptorProtoExtensionRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */\n\n/**\n * Properties of a ReservedRange message.\n * @interface IDescriptorProtoReservedRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */\n\nvar unnamedMessageIndex = 0;\n\n/**\n * Creates a type from a descriptor.\n * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Type} Type instance\n */\nType.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor);\n\n  // Create the message type\n  var type = new Type(descriptor.name.length ? descriptor.name : \"Type\" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)),\n    i;\n\n  /* Oneofs */\n  if (descriptor.oneofDecl) for (i = 0; i < descriptor.oneofDecl.length; ++i) type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));\n  /* Fields */\n  if (descriptor.field) for (i = 0; i < descriptor.field.length; ++i) {\n    var field = Field.fromDescriptor(descriptor.field[i], syntax);\n    type.add(field);\n    if (descriptor.field[i].hasOwnProperty(\"oneofIndex\"))\n      // eslint-disable-line no-prototype-builtins\n      type.oneofsArray[descriptor.field[i].oneofIndex].add(field);\n  }\n  /* Extension fields */\n  if (descriptor.extension) for (i = 0; i < descriptor.extension.length; ++i) type.add(Field.fromDescriptor(descriptor.extension[i], syntax));\n  /* Nested types */\n  if (descriptor.nestedType) for (i = 0; i < descriptor.nestedType.length; ++i) {\n    type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));\n    if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry) type.setOption(\"map_entry\", true);\n  }\n  /* Nested enums */\n  if (descriptor.enumType) for (i = 0; i < descriptor.enumType.length; ++i) type.add(Enum.fromDescriptor(descriptor.enumType[i]));\n  /* Extension ranges */\n  if (descriptor.extensionRange && descriptor.extensionRange.length) {\n    type.extensions = [];\n    for (i = 0; i < descriptor.extensionRange.length; ++i) type.extensions.push([descriptor.extensionRange[i].start, descriptor.extensionRange[i].end]);\n  }\n  /* Reserved... */\n  if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {\n    type.reserved = [];\n    /* Ranges */\n    if (descriptor.reservedRange) for (i = 0; i < descriptor.reservedRange.length; ++i) type.reserved.push([descriptor.reservedRange[i].start, descriptor.reservedRange[i].end]);\n    /* Names */\n    if (descriptor.reservedName) for (i = 0; i < descriptor.reservedName.length; ++i) type.reserved.push(descriptor.reservedName[i]);\n  }\n  return type;\n};\n\n/**\n * Converts a type to a descriptor.\n * @returns {Message<IDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\nType.prototype.toDescriptor = function toDescriptor(syntax) {\n  var descriptor = exports.DescriptorProto.create({\n      name: this.name\n    }),\n    i;\n\n  /* Fields */\n  for (i = 0; i < this.fieldsArray.length; ++i) {\n    var fieldDescriptor;\n    descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));\n    if (this._fieldsArray[i] instanceof MapField) {\n      // map fields are repeated FieldNameEntry\n      var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType),\n        valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType),\n        valueTypeName = valueType === /* type */11 || valueType === /* enum */14 ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type : undefined;\n      descriptor.nestedType.push(exports.DescriptorProto.create({\n        name: fieldDescriptor.typeName,\n        field: [exports.FieldDescriptorProto.create({\n          name: \"key\",\n          number: 1,\n          label: 1,\n          type: keyType\n        }),\n        // can't reference a type or enum\n        exports.FieldDescriptorProto.create({\n          name: \"value\",\n          number: 2,\n          label: 1,\n          type: valueType,\n          typeName: valueTypeName\n        })],\n        options: exports.MessageOptions.create({\n          mapEntry: true\n        })\n      }));\n    }\n  }\n  /* Oneofs */\n  for (i = 0; i < this.oneofsArray.length; ++i) descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());\n  /* Nested... */\n  for (i = 0; i < this.nestedArray.length; ++i) {\n    /* Extension fields */if (this._nestedArray[i] instanceof Field) descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));\n    /* Types */else if (this._nestedArray[i] instanceof Type) descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));\n    /* Enums */else if (this._nestedArray[i] instanceof Enum) descriptor.enumType.push(this._nestedArray[i].toDescriptor());\n    // plain nested namespaces become packages instead in Root#toDescriptor\n  }\n  /* Extension ranges */\n  if (this.extensions) for (i = 0; i < this.extensions.length; ++i) descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({\n    start: this.extensions[i][0],\n    end: this.extensions[i][1]\n  }));\n  /* Reserved... */\n  if (this.reserved) for (i = 0; i < this.reserved.length; ++i) /* Names */if (typeof this.reserved[i] === \"string\") descriptor.reservedName.push(this.reserved[i]);\n  /* Ranges */else descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({\n    start: this.reserved[i][0],\n    end: this.reserved[i][1]\n  }));\n  descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);\n  return descriptor;\n};\n\n// --- Field ---\n\n/**\n * Properties of a FieldDescriptorProto message.\n * @interface IFieldDescriptorProto\n * @property {string} [name] Field name\n * @property {number} [number] Field id\n * @property {IFieldDescriptorProtoLabel} [label] Field rule\n * @property {IFieldDescriptorProtoType} [type] Field basic type\n * @property {string} [typeName] Field type name\n * @property {string} [extendee] Extended type name\n * @property {string} [defaultValue] Literal default value\n * @property {number} [oneofIndex] Oneof index if part of a oneof\n * @property {*} [jsonName] Not supported\n * @property {IFieldOptions} [options] Field options\n */\n\n/**\n * Values of the FieldDescriptorProto.Label enum.\n * @typedef IFieldDescriptorProtoLabel\n * @type {number}\n * @property {number} LABEL_OPTIONAL=1\n * @property {number} LABEL_REQUIRED=2\n * @property {number} LABEL_REPEATED=3\n */\n\n/**\n * Values of the FieldDescriptorProto.Type enum.\n * @typedef IFieldDescriptorProtoType\n * @type {number}\n * @property {number} TYPE_DOUBLE=1\n * @property {number} TYPE_FLOAT=2\n * @property {number} TYPE_INT64=3\n * @property {number} TYPE_UINT64=4\n * @property {number} TYPE_INT32=5\n * @property {number} TYPE_FIXED64=6\n * @property {number} TYPE_FIXED32=7\n * @property {number} TYPE_BOOL=8\n * @property {number} TYPE_STRING=9\n * @property {number} TYPE_GROUP=10\n * @property {number} TYPE_MESSAGE=11\n * @property {number} TYPE_BYTES=12\n * @property {number} TYPE_UINT32=13\n * @property {number} TYPE_ENUM=14\n * @property {number} TYPE_SFIXED32=15\n * @property {number} TYPE_SFIXED64=16\n * @property {number} TYPE_SINT32=17\n * @property {number} TYPE_SINT64=18\n */\n\n/**\n * Properties of a FieldOptions message.\n * @interface IFieldOptions\n * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)\n * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)\n */\n\n/**\n * Values of the FieldOptions.JSType enum.\n * @typedef IFieldOptionsJSType\n * @type {number}\n * @property {number} JS_NORMAL=0\n * @property {number} JS_STRING=1\n * @property {number} JS_NUMBER=2\n */\n\n// copied here from parse.js\nvar numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;\n\n/**\n * Creates a field from a descriptor.\n * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Field} Field instance\n */\nField.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor);\n  if (typeof descriptor.number !== \"number\") throw Error(\"missing field id\");\n\n  // Rewire field type\n  var fieldType;\n  if (descriptor.typeName && descriptor.typeName.length) fieldType = descriptor.typeName;else fieldType = fromDescriptorType(descriptor.type);\n\n  // Rewire field rule\n  var fieldRule;\n  switch (descriptor.label) {\n    // 0 is reserved for errors\n    case 1:\n      fieldRule = undefined;\n      break;\n    case 2:\n      fieldRule = \"required\";\n      break;\n    case 3:\n      fieldRule = \"repeated\";\n      break;\n    default:\n      throw Error(\"illegal label: \" + descriptor.label);\n  }\n  var extendee = descriptor.extendee;\n  if (descriptor.extendee !== undefined) {\n    extendee = extendee.length ? extendee : undefined;\n  }\n  var field = new Field(descriptor.name.length ? descriptor.name : \"field\" + descriptor.number, descriptor.number, fieldType, fieldRule, extendee);\n  field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);\n  if (descriptor.defaultValue && descriptor.defaultValue.length) {\n    var defaultValue = descriptor.defaultValue;\n    switch (defaultValue) {\n      case \"true\":\n      case \"TRUE\":\n        defaultValue = true;\n        break;\n      case \"false\":\n      case \"FALSE\":\n        defaultValue = false;\n        break;\n      default:\n        var match = numberRe.exec(defaultValue);\n        if (match) defaultValue = parseInt(defaultValue); // eslint-disable-line radix\n        break;\n    }\n    field.setOption(\"default\", defaultValue);\n  }\n  if (packableDescriptorType(descriptor.type)) {\n    if (syntax === \"proto3\") {\n      // defaults to packed=true (internal preset is packed=true)\n      if (descriptor.options && !descriptor.options.packed) field.setOption(\"packed\", false);\n    } else if (!(descriptor.options && descriptor.options.packed))\n      // defaults to packed=false\n      field.setOption(\"packed\", false);\n  }\n  return field;\n};\n\n/**\n * Converts a field to a descriptor.\n * @returns {Message<IFieldDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\nField.prototype.toDescriptor = function toDescriptor(syntax) {\n  var descriptor = exports.FieldDescriptorProto.create({\n    name: this.name,\n    number: this.id\n  });\n  if (this.map) {\n    descriptor.type = 11; // message\n    descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)\n    descriptor.label = 3; // repeated\n  } else {\n    // Rewire field type\n    switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {\n      case 10: // group\n      case 11: // type\n      case 14:\n        // enum\n        descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;\n        break;\n    }\n\n    // Rewire field rule\n    switch (this.rule) {\n      case \"repeated\":\n        descriptor.label = 3;\n        break;\n      case \"required\":\n        descriptor.label = 2;\n        break;\n      default:\n        descriptor.label = 1;\n        break;\n    }\n  }\n\n  // Handle extension field\n  descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;\n\n  // Handle part of oneof\n  if (this.partOf) if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0) throw Error(\"missing oneof\");\n  if (this.options) {\n    descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);\n    if (this.options[\"default\"] != null) descriptor.defaultValue = String(this.options[\"default\"]);\n  }\n  if (syntax === \"proto3\") {\n    // defaults to packed=true\n    if (!this.packed) (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;\n  } else if (this.packed)\n    // defaults to packed=false\n    (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;\n  return descriptor;\n};\n\n// --- Enum ---\n\n/**\n * Properties of an EnumDescriptorProto message.\n * @interface IEnumDescriptorProto\n * @property {string} [name] Enum name\n * @property {IEnumValueDescriptorProto[]} [value] Enum values\n * @property {IEnumOptions} [options] Enum options\n */\n\n/**\n * Properties of an EnumValueDescriptorProto message.\n * @interface IEnumValueDescriptorProto\n * @property {string} [name] Name\n * @property {number} [number] Value\n * @property {*} [options] Not supported\n */\n\n/**\n * Properties of an EnumOptions message.\n * @interface IEnumOptions\n * @property {boolean} [allowAlias] Whether aliases are allowed\n * @property {boolean} [deprecated]\n */\n\nvar unnamedEnumIndex = 0;\n\n/**\n * Creates an enum from a descriptor.\n * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Enum} Enum instance\n */\nEnum.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.EnumDescriptorProto.decode(descriptor);\n\n  // Construct values object\n  var values = {};\n  if (descriptor.value) for (var i = 0; i < descriptor.value.length; ++i) {\n    var name = descriptor.value[i].name,\n      value = descriptor.value[i].number || 0;\n    values[name && name.length ? name : \"NAME\" + value] = value;\n  }\n  return new Enum(descriptor.name && descriptor.name.length ? descriptor.name : \"Enum\" + unnamedEnumIndex++, values, fromDescriptorOptions(descriptor.options, exports.EnumOptions));\n};\n\n/**\n * Converts an enum to a descriptor.\n * @returns {Message<IEnumDescriptorProto>} Descriptor\n */\nEnum.prototype.toDescriptor = function toDescriptor() {\n  // Values\n  var values = [];\n  for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i) values.push(exports.EnumValueDescriptorProto.create({\n    name: ks[i],\n    number: this.values[ks[i]]\n  }));\n  return exports.EnumDescriptorProto.create({\n    name: this.name,\n    value: values,\n    options: toDescriptorOptions(this.options, exports.EnumOptions)\n  });\n};\n\n// --- OneOf ---\n\n/**\n * Properties of a OneofDescriptorProto message.\n * @interface IOneofDescriptorProto\n * @property {string} [name] Oneof name\n * @property {*} [options] Not supported\n */\n\nvar unnamedOneofIndex = 0;\n\n/**\n * Creates a oneof from a descriptor.\n * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {OneOf} OneOf instance\n */\nOneOf.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.OneofDescriptorProto.decode(descriptor);\n  return new OneOf(\n  // unnamedOneOfIndex is global, not per type, because we have no ref to a type here\n  descriptor.name && descriptor.name.length ? descriptor.name : \"oneof\" + unnamedOneofIndex++\n  // fromDescriptorOptions(descriptor.options, exports.OneofOptions) - only uninterpreted_option\n  );\n};\n\n/**\n * Converts a oneof to a descriptor.\n * @returns {Message<IOneofDescriptorProto>} Descriptor\n */\nOneOf.prototype.toDescriptor = function toDescriptor() {\n  return exports.OneofDescriptorProto.create({\n    name: this.name\n    // options: toDescriptorOptions(this.options, exports.OneofOptions) - only uninterpreted_option\n  });\n};\n\n// --- Service ---\n\n/**\n * Properties of a ServiceDescriptorProto message.\n * @interface IServiceDescriptorProto\n * @property {string} [name] Service name\n * @property {IMethodDescriptorProto[]} [method] Methods\n * @property {IServiceOptions} [options] Options\n */\n\n/**\n * Properties of a ServiceOptions message.\n * @interface IServiceOptions\n * @property {boolean} [deprecated]\n */\n\nvar unnamedServiceIndex = 0;\n\n/**\n * Creates a service from a descriptor.\n * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Service} Service instance\n */\nService.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.ServiceDescriptorProto.decode(descriptor);\n  var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : \"Service\" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));\n  if (descriptor.method) for (var i = 0; i < descriptor.method.length; ++i) service.add(Method.fromDescriptor(descriptor.method[i]));\n  return service;\n};\n\n/**\n * Converts a service to a descriptor.\n * @returns {Message<IServiceDescriptorProto>} Descriptor\n */\nService.prototype.toDescriptor = function toDescriptor() {\n  // Methods\n  var methods = [];\n  for (var i = 0; i < this.methodsArray.length; ++i) methods.push(this._methodsArray[i].toDescriptor());\n  return exports.ServiceDescriptorProto.create({\n    name: this.name,\n    method: methods,\n    options: toDescriptorOptions(this.options, exports.ServiceOptions)\n  });\n};\n\n// --- Method ---\n\n/**\n * Properties of a MethodDescriptorProto message.\n * @interface IMethodDescriptorProto\n * @property {string} [name] Method name\n * @property {string} [inputType] Request type name\n * @property {string} [outputType] Response type name\n * @property {IMethodOptions} [options] Not supported\n * @property {boolean} [clientStreaming=false] Whether requests are streamed\n * @property {boolean} [serverStreaming=false] Whether responses are streamed\n */\n\n/**\n * Properties of a MethodOptions message.\n * @interface IMethodOptions\n * @property {boolean} [deprecated]\n */\n\nvar unnamedMethodIndex = 0;\n\n/**\n * Creates a method from a descriptor.\n * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Method} Reflected method instance\n */\nMethod.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.MethodDescriptorProto.decode(descriptor);\n  return new Method(\n  // unnamedMethodIndex is global, not per service, because we have no ref to a service here\n  descriptor.name && descriptor.name.length ? descriptor.name : \"Method\" + unnamedMethodIndex++, \"rpc\", descriptor.inputType, descriptor.outputType, Boolean(descriptor.clientStreaming), Boolean(descriptor.serverStreaming), fromDescriptorOptions(descriptor.options, exports.MethodOptions));\n};\n\n/**\n * Converts a method to a descriptor.\n * @returns {Message<IMethodDescriptorProto>} Descriptor\n */\nMethod.prototype.toDescriptor = function toDescriptor() {\n  return exports.MethodDescriptorProto.create({\n    name: this.name,\n    inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,\n    outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,\n    clientStreaming: this.requestStream,\n    serverStreaming: this.responseStream,\n    options: toDescriptorOptions(this.options, exports.MethodOptions)\n  });\n};\n\n// --- utility ---\n\n// Converts a descriptor type to a protobuf.js basic type\nfunction fromDescriptorType(type) {\n  switch (type) {\n    // 0 is reserved for errors\n    case 1:\n      return \"double\";\n    case 2:\n      return \"float\";\n    case 3:\n      return \"int64\";\n    case 4:\n      return \"uint64\";\n    case 5:\n      return \"int32\";\n    case 6:\n      return \"fixed64\";\n    case 7:\n      return \"fixed32\";\n    case 8:\n      return \"bool\";\n    case 9:\n      return \"string\";\n    case 12:\n      return \"bytes\";\n    case 13:\n      return \"uint32\";\n    case 15:\n      return \"sfixed32\";\n    case 16:\n      return \"sfixed64\";\n    case 17:\n      return \"sint32\";\n    case 18:\n      return \"sint64\";\n  }\n  throw Error(\"illegal type: \" + type);\n}\n\n// Tests if a descriptor type is packable\nfunction packableDescriptorType(type) {\n  switch (type) {\n    case 1: // double\n    case 2: // float\n    case 3: // int64\n    case 4: // uint64\n    case 5: // int32\n    case 6: // fixed64\n    case 7: // fixed32\n    case 8: // bool\n    case 13: // uint32\n    case 14: // enum (!)\n    case 15: // sfixed32\n    case 16: // sfixed64\n    case 17: // sint32\n    case 18:\n      // sint64\n      return true;\n  }\n  return false;\n}\n\n// Converts a protobuf.js basic type to a descriptor type\nfunction toDescriptorType(type, resolvedType) {\n  switch (type) {\n    // 0 is reserved for errors\n    case \"double\":\n      return 1;\n    case \"float\":\n      return 2;\n    case \"int64\":\n      return 3;\n    case \"uint64\":\n      return 4;\n    case \"int32\":\n      return 5;\n    case \"fixed64\":\n      return 6;\n    case \"fixed32\":\n      return 7;\n    case \"bool\":\n      return 8;\n    case \"string\":\n      return 9;\n    case \"bytes\":\n      return 12;\n    case \"uint32\":\n      return 13;\n    case \"sfixed32\":\n      return 15;\n    case \"sfixed64\":\n      return 16;\n    case \"sint32\":\n      return 17;\n    case \"sint64\":\n      return 18;\n  }\n  if (resolvedType instanceof Enum) return 14;\n  if (resolvedType instanceof Type) return resolvedType.group ? 10 : 11;\n  throw Error(\"illegal type: \" + type);\n}\n\n// Converts descriptor options to an options object\nfunction fromDescriptorOptions(options, type) {\n  if (!options) return undefined;\n  var out = [];\n  for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i) if ((key = (field = type._fieldsArray[i]).name) !== \"uninterpretedOption\") if (options.hasOwnProperty(key)) {\n    // eslint-disable-line no-prototype-builtins\n    val = options[key];\n    if (field.resolvedType instanceof Enum && typeof val === \"number\" && field.resolvedType.valuesById[val] !== undefined) val = field.resolvedType.valuesById[val];\n    out.push(underScore(key), val);\n  }\n  return out.length ? $protobuf.util.toObject(out) : undefined;\n}\n\n// Converts an options object to descriptor options\nfunction toDescriptorOptions(options, type) {\n  if (!options) return undefined;\n  var out = [];\n  for (var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i) {\n    val = options[key = ks[i]];\n    if (key === \"default\") continue;\n    var field = type.fields[key];\n    if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)])) continue;\n    out.push(key, val);\n  }\n  return out.length ? type.fromObject($protobuf.util.toObject(out)) : undefined;\n}\n\n// Calculates the shortest relative path from `from` to `to`.\nfunction shortname(from, to) {\n  var fromPath = from.fullName.split(\".\"),\n    toPath = to.fullName.split(\".\"),\n    i = 0,\n    j = 0,\n    k = toPath.length - 1;\n  if (!(from instanceof Root) && to instanceof Namespace) while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {\n    var other = to.lookup(fromPath[i++], true);\n    if (other !== null && other !== to) break;\n    ++j;\n  } else for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j);\n  return toPath.slice(j).join(\".\");\n}\n\n// copied here from cli/targets/proto.js\nfunction underScore(str) {\n  return str.substring(0, 1) + str.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function ($0, $1) {\n    return \"_\" + $1.toLowerCase();\n  });\n}\n\n// --- exports ---\n\n/**\n * Reflected file descriptor set.\n * @name FileDescriptorSet\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected file descriptor proto.\n * @name FileDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected descriptor proto.\n * @name DescriptorProto\n * @type {Type}\n * @property {Type} ExtensionRange\n * @property {Type} ReservedRange\n * @const\n * @tstype $protobuf.Type & {\n *     ExtensionRange: $protobuf.Type,\n *     ReservedRange: $protobuf.Type\n * }\n */\n\n/**\n * Reflected field descriptor proto.\n * @name FieldDescriptorProto\n * @type {Type}\n * @property {Enum} Label\n * @property {Enum} Type\n * @const\n * @tstype $protobuf.Type & {\n *     Label: $protobuf.Enum,\n *     Type: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected oneof descriptor proto.\n * @name OneofDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum descriptor proto.\n * @name EnumDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected service descriptor proto.\n * @name ServiceDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum value descriptor proto.\n * @name EnumValueDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected method descriptor proto.\n * @name MethodDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected file options.\n * @name FileOptions\n * @type {Type}\n * @property {Enum} OptimizeMode\n * @const\n * @tstype $protobuf.Type & {\n *     OptimizeMode: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected message options.\n * @name MessageOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected field options.\n * @name FieldOptions\n * @type {Type}\n * @property {Enum} CType\n * @property {Enum} JSType\n * @const\n * @tstype $protobuf.Type & {\n *     CType: $protobuf.Enum,\n *     JSType: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected oneof options.\n * @name OneofOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum options.\n * @name EnumOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum value options.\n * @name EnumValueOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected service options.\n * @name ServiceOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected method options.\n * @name MethodOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected uninterpretet option.\n * @name UninterpretedOption\n * @type {Type}\n * @property {Type} NamePart\n * @const\n * @tstype $protobuf.Type & {\n *     NamePart: $protobuf.Type\n * }\n */\n\n/**\n * Reflected source code info.\n * @name SourceCodeInfo\n * @type {Type}\n * @property {Type} Location\n * @const\n * @tstype $protobuf.Type & {\n *     Location: $protobuf.Type\n * }\n */\n\n/**\n * Reflected generated code info.\n * @name GeneratedCodeInfo\n * @type {Type}\n * @property {Type} Annotation\n * @const\n * @tstype $protobuf.Type & {\n *     Annotation: $protobuf.Type\n * }\n */","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}