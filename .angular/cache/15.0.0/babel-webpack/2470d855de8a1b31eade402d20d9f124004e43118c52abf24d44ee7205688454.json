{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Server = void 0;\nconst http2 = require(\"http2\");\nconst constants_1 = require(\"./constants\");\nconst server_call_1 = require(\"./server-call\");\nconst server_credentials_1 = require(\"./server-credentials\");\nconst resolver_1 = require(\"./resolver\");\nconst logging = require(\"./logging\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst channelz_1 = require(\"./channelz\");\nconst {\n  HTTP2_HEADER_PATH\n} = http2.constants;\nconst TRACER_NAME = 'server';\nfunction noop() {}\nfunction getUnimplementedStatusResponse(methodName) {\n  return {\n    code: constants_1.Status.UNIMPLEMENTED,\n    details: `The server does not implement the method ${methodName}`\n  };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n  const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n  switch (handlerType) {\n    case 'unary':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n    case 'clientStream':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n    case 'serverStream':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    case 'bidi':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    default:\n      throw new Error(`Invalid handlerType ${handlerType}`);\n  }\n}\nclass Server {\n  constructor(options) {\n    this.http2ServerList = [];\n    this.handlers = new Map();\n    this.sessions = new Map();\n    this.started = false;\n    this.serverAddressString = 'null';\n    // Channelz Info\n    this.channelzEnabled = true;\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n    this.options = options !== null && options !== void 0 ? options : {};\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzRef = channelz_1.registerChannelzServer(() => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Server created');\n    }\n    this.trace('Server constructed');\n  }\n  getChannelzInfo() {\n    return {\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      listenerChildren: this.listenerChildrenTracker.getChildLists(),\n      sessionChildren: this.sessionChildrenTracker.getChildLists()\n    };\n  }\n  getChannelzSessionInfoGetter(session) {\n    return () => {\n      var _a, _b, _c;\n      const sessionInfo = this.sessions.get(session);\n      const sessionSocket = session.socket;\n      const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n      const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n      let tlsInfo;\n      if (session.encrypted) {\n        const tlsSocket = sessionSocket;\n        const cipherInfo = tlsSocket.getCipher();\n        const certificate = tlsSocket.getCertificate();\n        const peerCertificate = tlsSocket.getPeerCertificate();\n        tlsInfo = {\n          cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n          cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n          localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n          remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n        };\n      } else {\n        tlsInfo = null;\n      }\n      const socketInfo = {\n        remoteAddress: remoteAddress,\n        localAddress: localAddress,\n        security: tlsInfo,\n        remoteName: null,\n        streamsStarted: sessionInfo.streamTracker.callsStarted,\n        streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n        streamsFailed: sessionInfo.streamTracker.callsFailed,\n        messagesSent: sessionInfo.messagesSent,\n        messagesReceived: sessionInfo.messagesReceived,\n        keepAlivesSent: 0,\n        lastLocalStreamCreatedTimestamp: null,\n        lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n        lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n        lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n        localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n        remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n      };\n      return socketInfo;\n    };\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);\n  }\n  addProtoService() {\n    throw new Error('Not implemented. Use addService() instead');\n  }\n  addService(service, implementation) {\n    if (service === null || typeof service !== 'object' || implementation === null || typeof implementation !== 'object') {\n      throw new Error('addService() requires two objects as arguments');\n    }\n    const serviceKeys = Object.keys(service);\n    if (serviceKeys.length === 0) {\n      throw new Error('Cannot add an empty service to a server');\n    }\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      let methodType;\n      if (attrs.requestStream) {\n        if (attrs.responseStream) {\n          methodType = 'bidi';\n        } else {\n          methodType = 'clientStream';\n        }\n      } else {\n        if (attrs.responseStream) {\n          methodType = 'serverStream';\n        } else {\n          methodType = 'unary';\n        }\n      }\n      let implFn = implementation[name];\n      let impl;\n      if (implFn === undefined && typeof attrs.originalName === 'string') {\n        implFn = implementation[attrs.originalName];\n      }\n      if (implFn !== undefined) {\n        impl = implFn.bind(implementation);\n      } else {\n        impl = getDefaultHandler(methodType, name);\n      }\n      const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n      if (success === false) {\n        throw new Error(`Method handler for ${attrs.path} already provided.`);\n      }\n    });\n  }\n  removeService(service) {\n    if (service === null || typeof service !== 'object') {\n      throw new Error('removeService() requires object as argument');\n    }\n    const serviceKeys = Object.keys(service);\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      this.unregister(attrs.path);\n    });\n  }\n  bind(port, creds) {\n    throw new Error('Not implemented. Use bindAsync() instead');\n  }\n  bindAsync(port, creds, callback) {\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n    if (typeof port !== 'string') {\n      throw new TypeError('port must be a string');\n    }\n    if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n      throw new TypeError('creds must be a ServerCredentials object');\n    }\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n    const initialPortUri = uri_parser_1.parseUri(port);\n    if (initialPortUri === null) {\n      throw new Error(`Could not parse port \"${port}\"`);\n    }\n    const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);\n    if (portUri === null) {\n      throw new Error(`Could not get a default scheme for port \"${port}\"`);\n    }\n    const serverOptions = {\n      maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n    };\n    if ('grpc-node.max_session_memory' in this.options) {\n      serverOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n    } else {\n      /* By default, set a very large max session memory limit, to effectively\n       * disable enforcement of the limit. Some testing indicates that Node's\n       * behavior degrades badly when this limit is reached, so we solve that\n       * by disabling the check entirely. */\n      serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n    }\n    if ('grpc.max_concurrent_streams' in this.options) {\n      serverOptions.settings = {\n        maxConcurrentStreams: this.options['grpc.max_concurrent_streams']\n      };\n    }\n    const deferredCallback = (error, port) => {\n      process.nextTick(() => callback(error, port));\n    };\n    const setupServer = () => {\n      let http2Server;\n      if (creds._isSecure()) {\n        const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n        http2Server = http2.createSecureServer(secureServerOptions);\n        http2Server.on('secureConnection', socket => {\n          /* These errors need to be handled by the user of Http2SecureServer,\n           * according to https://github.com/nodejs/node/issues/35824 */\n          socket.on('error', e => {\n            this.trace('An incoming TLS connection closed with error: ' + e.message);\n          });\n        });\n      } else {\n        http2Server = http2.createServer(serverOptions);\n      }\n      http2Server.setTimeout(0, noop);\n      this._setupHandlers(http2Server);\n      return http2Server;\n    };\n    const bindSpecificPort = (addressList, portNum, previousCount) => {\n      if (addressList.length === 0) {\n        return Promise.resolve({\n          port: portNum,\n          count: previousCount\n        });\n      }\n      return Promise.all(addressList.map(address => {\n        this.trace('Attempting to bind ' + subchannel_address_1.subchannelAddressToString(address));\n        let addr;\n        if (subchannel_address_1.isTcpSubchannelAddress(address)) {\n          addr = {\n            host: address.host,\n            port: portNum\n          };\n        } else {\n          addr = address;\n        }\n        const http2Server = setupServer();\n        return new Promise((resolve, reject) => {\n          const onError = err => {\n            this.trace('Failed to bind ' + subchannel_address_1.subchannelAddressToString(address) + ' with error ' + err.message);\n            resolve(err);\n          };\n          http2Server.once('error', onError);\n          http2Server.listen(addr, () => {\n            const boundAddress = http2Server.address();\n            let boundSubchannelAddress;\n            if (typeof boundAddress === 'string') {\n              boundSubchannelAddress = {\n                path: boundAddress\n              };\n            } else {\n              boundSubchannelAddress = {\n                host: boundAddress.address,\n                port: boundAddress.port\n              };\n            }\n            let channelzRef;\n            channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), () => {\n              return {\n                localAddress: boundSubchannelAddress,\n                remoteAddress: null,\n                security: null,\n                remoteName: null,\n                streamsStarted: 0,\n                streamsSucceeded: 0,\n                streamsFailed: 0,\n                messagesSent: 0,\n                messagesReceived: 0,\n                keepAlivesSent: 0,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: null,\n                lastMessageSentTimestamp: null,\n                lastMessageReceivedTimestamp: null,\n                localFlowControlWindow: null,\n                remoteFlowControlWindow: null\n              };\n            }, this.channelzEnabled);\n            if (this.channelzEnabled) {\n              this.listenerChildrenTracker.refChild(channelzRef);\n            }\n            this.http2ServerList.push({\n              server: http2Server,\n              channelzRef: channelzRef\n            });\n            this.trace('Successfully bound ' + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));\n            resolve('port' in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);\n            http2Server.removeListener('error', onError);\n          });\n        });\n      })).then(results => {\n        let count = 0;\n        for (const result of results) {\n          if (typeof result === 'number') {\n            count += 1;\n            if (result !== portNum) {\n              throw new Error('Invalid state: multiple port numbers added from single address');\n            }\n          }\n        }\n        return {\n          port: portNum,\n          count: count + previousCount\n        };\n      });\n    };\n    const bindWildcardPort = addressList => {\n      if (addressList.length === 0) {\n        return Promise.resolve({\n          port: 0,\n          count: 0\n        });\n      }\n      const address = addressList[0];\n      const http2Server = setupServer();\n      return new Promise((resolve, reject) => {\n        const onError = err => {\n          this.trace('Failed to bind ' + subchannel_address_1.subchannelAddressToString(address) + ' with error ' + err.message);\n          resolve(bindWildcardPort(addressList.slice(1)));\n        };\n        http2Server.once('error', onError);\n        http2Server.listen(address, () => {\n          const boundAddress = http2Server.address();\n          const boundSubchannelAddress = {\n            host: boundAddress.address,\n            port: boundAddress.port\n          };\n          let channelzRef;\n          channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), () => {\n            return {\n              localAddress: boundSubchannelAddress,\n              remoteAddress: null,\n              security: null,\n              remoteName: null,\n              streamsStarted: 0,\n              streamsSucceeded: 0,\n              streamsFailed: 0,\n              messagesSent: 0,\n              messagesReceived: 0,\n              keepAlivesSent: 0,\n              lastLocalStreamCreatedTimestamp: null,\n              lastRemoteStreamCreatedTimestamp: null,\n              lastMessageSentTimestamp: null,\n              lastMessageReceivedTimestamp: null,\n              localFlowControlWindow: null,\n              remoteFlowControlWindow: null\n            };\n          }, this.channelzEnabled);\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.refChild(channelzRef);\n          }\n          this.http2ServerList.push({\n            server: http2Server,\n            channelzRef: channelzRef\n          });\n          this.trace('Successfully bound ' + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));\n          resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));\n          http2Server.removeListener('error', onError);\n        });\n      });\n    };\n    const resolverListener = {\n      onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {\n        // We only want one resolution result. Discard all future results\n        resolverListener.onSuccessfulResolution = () => {};\n        if (addressList.length === 0) {\n          deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);\n          return;\n        }\n        let bindResultPromise;\n        if (subchannel_address_1.isTcpSubchannelAddress(addressList[0])) {\n          if (addressList[0].port === 0) {\n            bindResultPromise = bindWildcardPort(addressList);\n          } else {\n            bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n          }\n        } else {\n          // Use an arbitrary non-zero port for non-TCP addresses\n          bindResultPromise = bindSpecificPort(addressList, 1, 0);\n        }\n        bindResultPromise.then(bindResult => {\n          if (bindResult.count === 0) {\n            const errorString = `No address added out of total ${addressList.length} resolved`;\n            logging.log(constants_1.LogVerbosity.ERROR, errorString);\n            deferredCallback(new Error(errorString), 0);\n          } else {\n            if (bindResult.count < addressList.length) {\n              logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n            }\n            deferredCallback(null, bindResult.port);\n          }\n        }, error => {\n          const errorString = `No address added out of total ${addressList.length} resolved`;\n          logging.log(constants_1.LogVerbosity.ERROR, errorString);\n          deferredCallback(new Error(errorString), 0);\n        });\n      },\n      onError: error => {\n        deferredCallback(new Error(error.details), 0);\n      }\n    };\n    const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);\n    resolver.updateResolution();\n  }\n  forceShutdown() {\n    // Close the server if it is still running.\n    for (const {\n      server: http2Server,\n      channelzRef: ref\n    } of this.http2ServerList) {\n      if (http2Server.listening) {\n        http2Server.close(() => {\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.unrefChild(ref);\n            channelz_1.unregisterChannelzRef(ref);\n          }\n        });\n      }\n    }\n    this.started = false;\n    // Always destroy any available sessions. It's possible that one or more\n    // tryShutdown() calls are in progress. Don't wait on them to finish.\n    this.sessions.forEach((channelzInfo, session) => {\n      // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n      // recognize destroy(code) as a valid signature.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      session.destroy(http2.constants.NGHTTP2_CANCEL);\n    });\n    this.sessions.clear();\n    if (this.channelzEnabled) {\n      channelz_1.unregisterChannelzRef(this.channelzRef);\n    }\n  }\n  register(name, handler, serialize, deserialize, type) {\n    if (this.handlers.has(name)) {\n      return false;\n    }\n    this.handlers.set(name, {\n      func: handler,\n      serialize,\n      deserialize,\n      type,\n      path: name\n    });\n    return true;\n  }\n  unregister(name) {\n    return this.handlers.delete(name);\n  }\n  start() {\n    if (this.http2ServerList.length === 0 || this.http2ServerList.every(({\n      server: http2Server\n    }) => http2Server.listening !== true)) {\n      throw new Error('server must be bound in order to start');\n    }\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Starting');\n    }\n    this.started = true;\n  }\n  tryShutdown(callback) {\n    const wrappedCallback = error => {\n      if (this.channelzEnabled) {\n        channelz_1.unregisterChannelzRef(this.channelzRef);\n      }\n      callback(error);\n    };\n    let pendingChecks = 0;\n    function maybeCallback() {\n      pendingChecks--;\n      if (pendingChecks === 0) {\n        wrappedCallback();\n      }\n    }\n    // Close the server if necessary.\n    this.started = false;\n    for (const {\n      server: http2Server,\n      channelzRef: ref\n    } of this.http2ServerList) {\n      if (http2Server.listening) {\n        pendingChecks++;\n        http2Server.close(() => {\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.unrefChild(ref);\n            channelz_1.unregisterChannelzRef(ref);\n          }\n          maybeCallback();\n        });\n      }\n    }\n    this.sessions.forEach((channelzInfo, session) => {\n      if (!session.closed) {\n        pendingChecks += 1;\n        session.close(maybeCallback);\n      }\n    });\n    if (pendingChecks === 0) {\n      wrappedCallback();\n    }\n  }\n  addHttp2Port() {\n    throw new Error('Not yet implemented');\n  }\n  /**\n   * Get the channelz reference object for this server. The returned value is\n   * garbage if channelz is disabled for this server.\n   * @returns\n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  _verifyContentType(stream, headers) {\n    const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n    if (typeof contentType !== 'string' || !contentType.startsWith('application/grpc')) {\n      stream.respond({\n        [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n      }, {\n        endStream: true\n      });\n      return false;\n    }\n    return true;\n  }\n  _retrieveHandler(headers) {\n    const path = headers[HTTP2_HEADER_PATH];\n    this.trace('Received call to method ' + path + ' at address ' + this.serverAddressString);\n    const handler = this.handlers.get(path);\n    if (handler === undefined) {\n      this.trace('No handler registered for method ' + path + '. Sending UNIMPLEMENTED status.');\n      throw getUnimplementedStatusResponse(path);\n    }\n    return handler;\n  }\n  _respondWithError(err, stream, channelzSessionInfo = null) {\n    const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n    if (err.code === undefined) {\n      err.code = constants_1.Status.INTERNAL;\n    }\n    if (this.channelzEnabled) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n    }\n    call.sendError(err);\n  }\n  _channelzHandler(stream, headers) {\n    const channelzSessionInfo = this.sessions.get(stream.session);\n    this.callTracker.addCallStarted();\n    channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n    if (!this._verifyContentType(stream, headers)) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n      return;\n    }\n    let handler;\n    try {\n      handler = this._retrieveHandler(headers);\n    } catch (err) {\n      this._respondWithError(err, stream, channelzSessionInfo);\n      return;\n    }\n    const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n    call.once('callEnd', code => {\n      if (code === constants_1.Status.OK) {\n        this.callTracker.addCallSucceeded();\n      } else {\n        this.callTracker.addCallFailed();\n      }\n    });\n    if (channelzSessionInfo) {\n      call.once('streamEnd', success => {\n        if (success) {\n          channelzSessionInfo.streamTracker.addCallSucceeded();\n        } else {\n          channelzSessionInfo.streamTracker.addCallFailed();\n        }\n      });\n      call.on('sendMessage', () => {\n        channelzSessionInfo.messagesSent += 1;\n        channelzSessionInfo.lastMessageSentTimestamp = new Date();\n      });\n      call.on('receiveMessage', () => {\n        channelzSessionInfo.messagesReceived += 1;\n        channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n      });\n    }\n    if (!this._runHandlerForCall(call, handler, headers)) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n      call.sendError({\n        code: constants_1.Status.INTERNAL,\n        details: `Unknown handler type: ${handler.type}`\n      });\n    }\n  }\n  _streamHandler(stream, headers) {\n    if (this._verifyContentType(stream, headers) !== true) {\n      return;\n    }\n    let handler;\n    try {\n      handler = this._retrieveHandler(headers);\n    } catch (err) {\n      this._respondWithError(err, stream, null);\n      return;\n    }\n    const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n    if (!this._runHandlerForCall(call, handler, headers)) {\n      call.sendError({\n        code: constants_1.Status.INTERNAL,\n        details: `Unknown handler type: ${handler.type}`\n      });\n    }\n  }\n  _runHandlerForCall(call, handler, headers) {\n    var _a;\n    const metadata = call.receiveMetadata(headers);\n    const encoding = (_a = metadata.get('grpc-encoding')[0]) !== null && _a !== void 0 ? _a : 'identity';\n    metadata.remove('grpc-encoding');\n    const {\n      type\n    } = handler;\n    if (type === 'unary') {\n      handleUnary(call, handler, metadata, encoding);\n    } else if (type === 'clientStream') {\n      handleClientStreaming(call, handler, metadata, encoding);\n    } else if (type === 'serverStream') {\n      handleServerStreaming(call, handler, metadata, encoding);\n    } else if (type === 'bidi') {\n      handleBidiStreaming(call, handler, metadata, encoding);\n    } else {\n      return false;\n    }\n    return true;\n  }\n  _setupHandlers(http2Server) {\n    if (http2Server === null) {\n      return;\n    }\n    const serverAddress = http2Server.address();\n    let serverAddressString = 'null';\n    if (serverAddress) {\n      if (typeof serverAddress === 'string') {\n        serverAddressString = serverAddress;\n      } else {\n        serverAddressString = serverAddress.address + ':' + serverAddress.port;\n      }\n    }\n    this.serverAddressString = serverAddressString;\n    const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;\n    http2Server.on('stream', handler.bind(this));\n    http2Server.on('session', session => {\n      var _a;\n      if (!this.started) {\n        session.destroy();\n        return;\n      }\n      let channelzRef;\n      channelzRef = channelz_1.registerChannelzSocket((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : 'unknown', this.getChannelzSessionInfoGetter(session), this.channelzEnabled);\n      const channelzSessionInfo = {\n        ref: channelzRef,\n        streamTracker: new channelz_1.ChannelzCallTracker(),\n        messagesSent: 0,\n        messagesReceived: 0,\n        lastMessageSentTimestamp: null,\n        lastMessageReceivedTimestamp: null\n      };\n      this.sessions.set(session, channelzSessionInfo);\n      const clientAddress = session.socket.remoteAddress;\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);\n        this.sessionChildrenTracker.refChild(channelzRef);\n      }\n      session.on('close', () => {\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);\n          this.sessionChildrenTracker.unrefChild(channelzRef);\n          channelz_1.unregisterChannelzRef(channelzRef);\n        }\n        this.sessions.delete(session);\n      });\n    });\n  }\n}\nexports.Server = Server;\nfunction handleUnary(call, handler, metadata, encoding) {\n  call.receiveUnaryMessage(encoding, (err, request) => {\n    if (err) {\n      call.sendError(err);\n      return;\n    }\n    if (request === undefined || call.cancelled) {\n      return;\n    }\n    const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n    handler.func(emitter, (err, value, trailer, flags) => {\n      call.sendUnaryMessage(err, value, trailer, flags);\n    });\n  });\n}\nfunction handleClientStreaming(call, handler, metadata, encoding) {\n  const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize, encoding);\n  function respond(err, value, trailer, flags) {\n    stream.destroy();\n    call.sendUnaryMessage(err, value, trailer, flags);\n  }\n  if (call.cancelled) {\n    return;\n  }\n  stream.on('error', respond);\n  handler.func(stream, respond);\n}\nfunction handleServerStreaming(call, handler, metadata, encoding) {\n  call.receiveUnaryMessage(encoding, (err, request) => {\n    if (err) {\n      call.sendError(err);\n      return;\n    }\n    if (request === undefined || call.cancelled) {\n      return;\n    }\n    const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n    handler.func(stream);\n  });\n}\nfunction handleBidiStreaming(call, handler, metadata, encoding) {\n  const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize, encoding);\n  if (call.cancelled) {\n    return;\n  }\n  handler.func(stream);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Server","http2","require","constants_1","server_call_1","server_credentials_1","resolver_1","logging","subchannel_address_1","uri_parser_1","channelz_1","HTTP2_HEADER_PATH","constants","TRACER_NAME","noop","getUnimplementedStatusResponse","methodName","code","Status","UNIMPLEMENTED","details","getDefaultHandler","handlerType","unimplementedStatusResponse","call","callback","emit","Error","constructor","options","http2ServerList","handlers","Map","sessions","started","serverAddressString","channelzEnabled","channelzTrace","ChannelzTrace","callTracker","ChannelzCallTracker","listenerChildrenTracker","ChannelzChildrenTracker","sessionChildrenTracker","channelzRef","registerChannelzServer","getChannelzInfo","addTrace","trace","listenerChildren","getChildLists","sessionChildren","getChannelzSessionInfoGetter","session","_a","_b","_c","sessionInfo","get","sessionSocket","socket","remoteAddress","stringToSubchannelAddress","remotePort","localAddress","localPort","tlsInfo","encrypted","tlsSocket","cipherInfo","getCipher","certificate","getCertificate","peerCertificate","getPeerCertificate","cipherSuiteStandardName","standardName","cipherSuiteOtherName","name","localCertificate","raw","remoteCertificate","socketInfo","security","remoteName","streamsStarted","streamTracker","callsStarted","streamsSucceeded","callsSucceeded","streamsFailed","callsFailed","messagesSent","messagesReceived","keepAlivesSent","lastLocalStreamCreatedTimestamp","lastRemoteStreamCreatedTimestamp","lastCallStartedTimestamp","lastMessageSentTimestamp","lastMessageReceivedTimestamp","localFlowControlWindow","state","localWindowSize","remoteFlowControlWindow","remoteWindowSize","text","LogVerbosity","DEBUG","id","addProtoService","addService","service","implementation","serviceKeys","keys","length","forEach","attrs","methodType","requestStream","responseStream","implFn","impl","undefined","originalName","bind","success","register","path","responseSerialize","requestDeserialize","removeService","unregister","port","creds","bindAsync","TypeError","ServerCredentials","initialPortUri","parseUri","portUri","mapUriDefaultScheme","serverOptions","maxSendHeaderBlockLength","Number","MAX_SAFE_INTEGER","maxSessionMemory","settings","maxConcurrentStreams","deferredCallback","error","process","nextTick","setupServer","http2Server","_isSecure","secureServerOptions","assign","_getSettings","createSecureServer","on","e","message","createServer","setTimeout","_setupHandlers","bindSpecificPort","addressList","portNum","previousCount","Promise","resolve","count","all","map","address","subchannelAddressToString","addr","isTcpSubchannelAddress","host","reject","onError","err","once","listen","boundAddress","boundSubchannelAddress","registerChannelzSocket","refChild","push","server","removeListener","then","results","result","bindWildcardPort","slice","resolverListener","onSuccessfulResolution","serviceConfig","serviceConfigError","bindResultPromise","bindResult","errorString","log","ERROR","INFO","resolver","createResolver","updateResolution","forceShutdown","ref","listening","close","unrefChild","unregisterChannelzRef","channelzInfo","destroy","NGHTTP2_CANCEL","clear","handler","serialize","deserialize","type","has","set","func","delete","start","every","tryShutdown","wrappedCallback","pendingChecks","maybeCallback","closed","addHttp2Port","getChannelzRef","_verifyContentType","stream","headers","contentType","HTTP2_HEADER_CONTENT_TYPE","startsWith","respond","HTTP2_HEADER_STATUS","HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE","endStream","_retrieveHandler","_respondWithError","channelzSessionInfo","Http2ServerCallStream","INTERNAL","addCallFailed","sendError","_channelzHandler","addCallStarted","OK","addCallSucceeded","Date","_runHandlerForCall","_streamHandler","metadata","receiveMetadata","encoding","remove","handleUnary","handleClientStreaming","handleServerStreaming","handleBidiStreaming","serverAddress","clientAddress","receiveUnaryMessage","request","cancelled","emitter","ServerUnaryCallImpl","trailer","flags","sendUnaryMessage","ServerReadableStreamImpl","ServerWritableStreamImpl","ServerDuplexStreamImpl"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/server.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Server = void 0;\nconst http2 = require(\"http2\");\nconst constants_1 = require(\"./constants\");\nconst server_call_1 = require(\"./server-call\");\nconst server_credentials_1 = require(\"./server-credentials\");\nconst resolver_1 = require(\"./resolver\");\nconst logging = require(\"./logging\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst channelz_1 = require(\"./channelz\");\nconst { HTTP2_HEADER_PATH } = http2.constants;\nconst TRACER_NAME = 'server';\nfunction noop() { }\nfunction getUnimplementedStatusResponse(methodName) {\n    return {\n        code: constants_1.Status.UNIMPLEMENTED,\n        details: `The server does not implement the method ${methodName}`,\n    };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n    switch (handlerType) {\n        case 'unary':\n            return (call, callback) => {\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'clientStream':\n            return (call, callback) => {\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'serverStream':\n            return (call) => {\n                call.emit('error', unimplementedStatusResponse);\n            };\n        case 'bidi':\n            return (call) => {\n                call.emit('error', unimplementedStatusResponse);\n            };\n        default:\n            throw new Error(`Invalid handlerType ${handlerType}`);\n    }\n}\nclass Server {\n    constructor(options) {\n        this.http2ServerList = [];\n        this.handlers = new Map();\n        this.sessions = new Map();\n        this.started = false;\n        this.serverAddressString = 'null';\n        // Channelz Info\n        this.channelzEnabled = true;\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.options = options !== null && options !== void 0 ? options : {};\n        if (this.options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzRef = channelz_1.registerChannelzServer(() => this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Server created');\n        }\n        this.trace('Server constructed');\n    }\n    getChannelzInfo() {\n        return {\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            listenerChildren: this.listenerChildrenTracker.getChildLists(),\n            sessionChildren: this.sessionChildrenTracker.getChildLists()\n        };\n    }\n    getChannelzSessionInfoGetter(session) {\n        return () => {\n            var _a, _b, _c;\n            const sessionInfo = this.sessions.get(session);\n            const sessionSocket = session.socket;\n            const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n            const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n            let tlsInfo;\n            if (session.encrypted) {\n                const tlsSocket = sessionSocket;\n                const cipherInfo = tlsSocket.getCipher();\n                const certificate = tlsSocket.getCertificate();\n                const peerCertificate = tlsSocket.getPeerCertificate();\n                tlsInfo = {\n                    cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                    cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                    localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,\n                    remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null\n                };\n            }\n            else {\n                tlsInfo = null;\n            }\n            const socketInfo = {\n                remoteAddress: remoteAddress,\n                localAddress: localAddress,\n                security: tlsInfo,\n                remoteName: null,\n                streamsStarted: sessionInfo.streamTracker.callsStarted,\n                streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n                streamsFailed: sessionInfo.streamTracker.callsFailed,\n                messagesSent: sessionInfo.messagesSent,\n                messagesReceived: sessionInfo.messagesReceived,\n                keepAlivesSent: 0,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n                lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n                lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n                localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n                remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n            };\n            return socketInfo;\n        };\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);\n    }\n    addProtoService() {\n        throw new Error('Not implemented. Use addService() instead');\n    }\n    addService(service, implementation) {\n        if (service === null ||\n            typeof service !== 'object' ||\n            implementation === null ||\n            typeof implementation !== 'object') {\n            throw new Error('addService() requires two objects as arguments');\n        }\n        const serviceKeys = Object.keys(service);\n        if (serviceKeys.length === 0) {\n            throw new Error('Cannot add an empty service to a server');\n        }\n        serviceKeys.forEach((name) => {\n            const attrs = service[name];\n            let methodType;\n            if (attrs.requestStream) {\n                if (attrs.responseStream) {\n                    methodType = 'bidi';\n                }\n                else {\n                    methodType = 'clientStream';\n                }\n            }\n            else {\n                if (attrs.responseStream) {\n                    methodType = 'serverStream';\n                }\n                else {\n                    methodType = 'unary';\n                }\n            }\n            let implFn = implementation[name];\n            let impl;\n            if (implFn === undefined && typeof attrs.originalName === 'string') {\n                implFn = implementation[attrs.originalName];\n            }\n            if (implFn !== undefined) {\n                impl = implFn.bind(implementation);\n            }\n            else {\n                impl = getDefaultHandler(methodType, name);\n            }\n            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n            if (success === false) {\n                throw new Error(`Method handler for ${attrs.path} already provided.`);\n            }\n        });\n    }\n    removeService(service) {\n        if (service === null || typeof service !== 'object') {\n            throw new Error('removeService() requires object as argument');\n        }\n        const serviceKeys = Object.keys(service);\n        serviceKeys.forEach((name) => {\n            const attrs = service[name];\n            this.unregister(attrs.path);\n        });\n    }\n    bind(port, creds) {\n        throw new Error('Not implemented. Use bindAsync() instead');\n    }\n    bindAsync(port, creds, callback) {\n        if (this.started === true) {\n            throw new Error('server is already started');\n        }\n        if (typeof port !== 'string') {\n            throw new TypeError('port must be a string');\n        }\n        if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n            throw new TypeError('creds must be a ServerCredentials object');\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError('callback must be a function');\n        }\n        const initialPortUri = uri_parser_1.parseUri(port);\n        if (initialPortUri === null) {\n            throw new Error(`Could not parse port \"${port}\"`);\n        }\n        const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);\n        if (portUri === null) {\n            throw new Error(`Could not get a default scheme for port \"${port}\"`);\n        }\n        const serverOptions = {\n            maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,\n        };\n        if ('grpc-node.max_session_memory' in this.options) {\n            serverOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n        }\n        else {\n            /* By default, set a very large max session memory limit, to effectively\n             * disable enforcement of the limit. Some testing indicates that Node's\n             * behavior degrades badly when this limit is reached, so we solve that\n             * by disabling the check entirely. */\n            serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n        }\n        if ('grpc.max_concurrent_streams' in this.options) {\n            serverOptions.settings = {\n                maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],\n            };\n        }\n        const deferredCallback = (error, port) => {\n            process.nextTick(() => callback(error, port));\n        };\n        const setupServer = () => {\n            let http2Server;\n            if (creds._isSecure()) {\n                const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n                http2Server = http2.createSecureServer(secureServerOptions);\n                http2Server.on('secureConnection', (socket) => {\n                    /* These errors need to be handled by the user of Http2SecureServer,\n                     * according to https://github.com/nodejs/node/issues/35824 */\n                    socket.on('error', (e) => {\n                        this.trace('An incoming TLS connection closed with error: ' + e.message);\n                    });\n                });\n            }\n            else {\n                http2Server = http2.createServer(serverOptions);\n            }\n            http2Server.setTimeout(0, noop);\n            this._setupHandlers(http2Server);\n            return http2Server;\n        };\n        const bindSpecificPort = (addressList, portNum, previousCount) => {\n            if (addressList.length === 0) {\n                return Promise.resolve({ port: portNum, count: previousCount });\n            }\n            return Promise.all(addressList.map((address) => {\n                this.trace('Attempting to bind ' + subchannel_address_1.subchannelAddressToString(address));\n                let addr;\n                if (subchannel_address_1.isTcpSubchannelAddress(address)) {\n                    addr = {\n                        host: address.host,\n                        port: portNum,\n                    };\n                }\n                else {\n                    addr = address;\n                }\n                const http2Server = setupServer();\n                return new Promise((resolve, reject) => {\n                    const onError = (err) => {\n                        this.trace('Failed to bind ' + subchannel_address_1.subchannelAddressToString(address) + ' with error ' + err.message);\n                        resolve(err);\n                    };\n                    http2Server.once('error', onError);\n                    http2Server.listen(addr, () => {\n                        const boundAddress = http2Server.address();\n                        let boundSubchannelAddress;\n                        if (typeof boundAddress === 'string') {\n                            boundSubchannelAddress = {\n                                path: boundAddress\n                            };\n                        }\n                        else {\n                            boundSubchannelAddress = {\n                                host: boundAddress.address,\n                                port: boundAddress.port\n                            };\n                        }\n                        let channelzRef;\n                        channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), () => {\n                            return {\n                                localAddress: boundSubchannelAddress,\n                                remoteAddress: null,\n                                security: null,\n                                remoteName: null,\n                                streamsStarted: 0,\n                                streamsSucceeded: 0,\n                                streamsFailed: 0,\n                                messagesSent: 0,\n                                messagesReceived: 0,\n                                keepAlivesSent: 0,\n                                lastLocalStreamCreatedTimestamp: null,\n                                lastRemoteStreamCreatedTimestamp: null,\n                                lastMessageSentTimestamp: null,\n                                lastMessageReceivedTimestamp: null,\n                                localFlowControlWindow: null,\n                                remoteFlowControlWindow: null\n                            };\n                        }, this.channelzEnabled);\n                        if (this.channelzEnabled) {\n                            this.listenerChildrenTracker.refChild(channelzRef);\n                        }\n                        this.http2ServerList.push({ server: http2Server, channelzRef: channelzRef });\n                        this.trace('Successfully bound ' + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));\n                        resolve('port' in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);\n                        http2Server.removeListener('error', onError);\n                    });\n                });\n            })).then((results) => {\n                let count = 0;\n                for (const result of results) {\n                    if (typeof result === 'number') {\n                        count += 1;\n                        if (result !== portNum) {\n                            throw new Error('Invalid state: multiple port numbers added from single address');\n                        }\n                    }\n                }\n                return {\n                    port: portNum,\n                    count: count + previousCount,\n                };\n            });\n        };\n        const bindWildcardPort = (addressList) => {\n            if (addressList.length === 0) {\n                return Promise.resolve({ port: 0, count: 0 });\n            }\n            const address = addressList[0];\n            const http2Server = setupServer();\n            return new Promise((resolve, reject) => {\n                const onError = (err) => {\n                    this.trace('Failed to bind ' + subchannel_address_1.subchannelAddressToString(address) + ' with error ' + err.message);\n                    resolve(bindWildcardPort(addressList.slice(1)));\n                };\n                http2Server.once('error', onError);\n                http2Server.listen(address, () => {\n                    const boundAddress = http2Server.address();\n                    const boundSubchannelAddress = {\n                        host: boundAddress.address,\n                        port: boundAddress.port\n                    };\n                    let channelzRef;\n                    channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), () => {\n                        return {\n                            localAddress: boundSubchannelAddress,\n                            remoteAddress: null,\n                            security: null,\n                            remoteName: null,\n                            streamsStarted: 0,\n                            streamsSucceeded: 0,\n                            streamsFailed: 0,\n                            messagesSent: 0,\n                            messagesReceived: 0,\n                            keepAlivesSent: 0,\n                            lastLocalStreamCreatedTimestamp: null,\n                            lastRemoteStreamCreatedTimestamp: null,\n                            lastMessageSentTimestamp: null,\n                            lastMessageReceivedTimestamp: null,\n                            localFlowControlWindow: null,\n                            remoteFlowControlWindow: null\n                        };\n                    }, this.channelzEnabled);\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.refChild(channelzRef);\n                    }\n                    this.http2ServerList.push({ server: http2Server, channelzRef: channelzRef });\n                    this.trace('Successfully bound ' + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));\n                    resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));\n                    http2Server.removeListener('error', onError);\n                });\n            });\n        };\n        const resolverListener = {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {\n                // We only want one resolution result. Discard all future results\n                resolverListener.onSuccessfulResolution = () => { };\n                if (addressList.length === 0) {\n                    deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);\n                    return;\n                }\n                let bindResultPromise;\n                if (subchannel_address_1.isTcpSubchannelAddress(addressList[0])) {\n                    if (addressList[0].port === 0) {\n                        bindResultPromise = bindWildcardPort(addressList);\n                    }\n                    else {\n                        bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n                    }\n                }\n                else {\n                    // Use an arbitrary non-zero port for non-TCP addresses\n                    bindResultPromise = bindSpecificPort(addressList, 1, 0);\n                }\n                bindResultPromise.then((bindResult) => {\n                    if (bindResult.count === 0) {\n                        const errorString = `No address added out of total ${addressList.length} resolved`;\n                        logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                        deferredCallback(new Error(errorString), 0);\n                    }\n                    else {\n                        if (bindResult.count < addressList.length) {\n                            logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n                        }\n                        deferredCallback(null, bindResult.port);\n                    }\n                }, (error) => {\n                    const errorString = `No address added out of total ${addressList.length} resolved`;\n                    logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                    deferredCallback(new Error(errorString), 0);\n                });\n            },\n            onError: (error) => {\n                deferredCallback(new Error(error.details), 0);\n            },\n        };\n        const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);\n        resolver.updateResolution();\n    }\n    forceShutdown() {\n        // Close the server if it is still running.\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList) {\n            if (http2Server.listening) {\n                http2Server.close(() => {\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        channelz_1.unregisterChannelzRef(ref);\n                    }\n                });\n            }\n        }\n        this.started = false;\n        // Always destroy any available sessions. It's possible that one or more\n        // tryShutdown() calls are in progress. Don't wait on them to finish.\n        this.sessions.forEach((channelzInfo, session) => {\n            // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n            // recognize destroy(code) as a valid signature.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            session.destroy(http2.constants.NGHTTP2_CANCEL);\n        });\n        this.sessions.clear();\n        if (this.channelzEnabled) {\n            channelz_1.unregisterChannelzRef(this.channelzRef);\n        }\n    }\n    register(name, handler, serialize, deserialize, type) {\n        if (this.handlers.has(name)) {\n            return false;\n        }\n        this.handlers.set(name, {\n            func: handler,\n            serialize,\n            deserialize,\n            type,\n            path: name,\n        });\n        return true;\n    }\n    unregister(name) {\n        return this.handlers.delete(name);\n    }\n    start() {\n        if (this.http2ServerList.length === 0 ||\n            this.http2ServerList.every(({ server: http2Server }) => http2Server.listening !== true)) {\n            throw new Error('server must be bound in order to start');\n        }\n        if (this.started === true) {\n            throw new Error('server is already started');\n        }\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Starting');\n        }\n        this.started = true;\n    }\n    tryShutdown(callback) {\n        const wrappedCallback = (error) => {\n            if (this.channelzEnabled) {\n                channelz_1.unregisterChannelzRef(this.channelzRef);\n            }\n            callback(error);\n        };\n        let pendingChecks = 0;\n        function maybeCallback() {\n            pendingChecks--;\n            if (pendingChecks === 0) {\n                wrappedCallback();\n            }\n        }\n        // Close the server if necessary.\n        this.started = false;\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList) {\n            if (http2Server.listening) {\n                pendingChecks++;\n                http2Server.close(() => {\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        channelz_1.unregisterChannelzRef(ref);\n                    }\n                    maybeCallback();\n                });\n            }\n        }\n        this.sessions.forEach((channelzInfo, session) => {\n            if (!session.closed) {\n                pendingChecks += 1;\n                session.close(maybeCallback);\n            }\n        });\n        if (pendingChecks === 0) {\n            wrappedCallback();\n        }\n    }\n    addHttp2Port() {\n        throw new Error('Not yet implemented');\n    }\n    /**\n     * Get the channelz reference object for this server. The returned value is\n     * garbage if channelz is disabled for this server.\n     * @returns\n     */\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    _verifyContentType(stream, headers) {\n        const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n        if (typeof contentType !== 'string' ||\n            !contentType.startsWith('application/grpc')) {\n            stream.respond({\n                [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,\n            }, { endStream: true });\n            return false;\n        }\n        return true;\n    }\n    _retrieveHandler(headers) {\n        const path = headers[HTTP2_HEADER_PATH];\n        this.trace('Received call to method ' +\n            path +\n            ' at address ' +\n            this.serverAddressString);\n        const handler = this.handlers.get(path);\n        if (handler === undefined) {\n            this.trace('No handler registered for method ' +\n                path +\n                '. Sending UNIMPLEMENTED status.');\n            throw getUnimplementedStatusResponse(path);\n        }\n        return handler;\n    }\n    _respondWithError(err, stream, channelzSessionInfo = null) {\n        const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n        if (err.code === undefined) {\n            err.code = constants_1.Status.INTERNAL;\n        }\n        if (this.channelzEnabled) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n        }\n        call.sendError(err);\n    }\n    _channelzHandler(stream, headers) {\n        const channelzSessionInfo = this.sessions.get(stream.session);\n        this.callTracker.addCallStarted();\n        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n        if (!this._verifyContentType(stream, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            return;\n        }\n        let handler;\n        try {\n            handler = this._retrieveHandler(headers);\n        }\n        catch (err) {\n            this._respondWithError(err, stream, channelzSessionInfo);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        call.once('callEnd', (code) => {\n            if (code === constants_1.Status.OK) {\n                this.callTracker.addCallSucceeded();\n            }\n            else {\n                this.callTracker.addCallFailed();\n            }\n        });\n        if (channelzSessionInfo) {\n            call.once('streamEnd', (success) => {\n                if (success) {\n                    channelzSessionInfo.streamTracker.addCallSucceeded();\n                }\n                else {\n                    channelzSessionInfo.streamTracker.addCallFailed();\n                }\n            });\n            call.on('sendMessage', () => {\n                channelzSessionInfo.messagesSent += 1;\n                channelzSessionInfo.lastMessageSentTimestamp = new Date();\n            });\n            call.on('receiveMessage', () => {\n                channelzSessionInfo.messagesReceived += 1;\n                channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n            });\n        }\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _streamHandler(stream, headers) {\n        if (this._verifyContentType(stream, headers) !== true) {\n            return;\n        }\n        let handler;\n        try {\n            handler = this._retrieveHandler(headers);\n        }\n        catch (err) {\n            this._respondWithError(err, stream, null);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _runHandlerForCall(call, handler, headers) {\n        var _a;\n        const metadata = call.receiveMetadata(headers);\n        const encoding = (_a = metadata.get('grpc-encoding')[0]) !== null && _a !== void 0 ? _a : 'identity';\n        metadata.remove('grpc-encoding');\n        const { type } = handler;\n        if (type === 'unary') {\n            handleUnary(call, handler, metadata, encoding);\n        }\n        else if (type === 'clientStream') {\n            handleClientStreaming(call, handler, metadata, encoding);\n        }\n        else if (type === 'serverStream') {\n            handleServerStreaming(call, handler, metadata, encoding);\n        }\n        else if (type === 'bidi') {\n            handleBidiStreaming(call, handler, metadata, encoding);\n        }\n        else {\n            return false;\n        }\n        return true;\n    }\n    _setupHandlers(http2Server) {\n        if (http2Server === null) {\n            return;\n        }\n        const serverAddress = http2Server.address();\n        let serverAddressString = 'null';\n        if (serverAddress) {\n            if (typeof serverAddress === 'string') {\n                serverAddressString = serverAddress;\n            }\n            else {\n                serverAddressString =\n                    serverAddress.address + ':' + serverAddress.port;\n            }\n        }\n        this.serverAddressString = serverAddressString;\n        const handler = this.channelzEnabled\n            ? this._channelzHandler\n            : this._streamHandler;\n        http2Server.on('stream', handler.bind(this));\n        http2Server.on('session', (session) => {\n            var _a;\n            if (!this.started) {\n                session.destroy();\n                return;\n            }\n            let channelzRef;\n            channelzRef = channelz_1.registerChannelzSocket((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : 'unknown', this.getChannelzSessionInfoGetter(session), this.channelzEnabled);\n            const channelzSessionInfo = {\n                ref: channelzRef,\n                streamTracker: new channelz_1.ChannelzCallTracker(),\n                messagesSent: 0,\n                messagesReceived: 0,\n                lastMessageSentTimestamp: null,\n                lastMessageReceivedTimestamp: null\n            };\n            this.sessions.set(session, channelzSessionInfo);\n            const clientAddress = session.socket.remoteAddress;\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);\n                this.sessionChildrenTracker.refChild(channelzRef);\n            }\n            session.on('close', () => {\n                if (this.channelzEnabled) {\n                    this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);\n                    this.sessionChildrenTracker.unrefChild(channelzRef);\n                    channelz_1.unregisterChannelzRef(channelzRef);\n                }\n                this.sessions.delete(session);\n            });\n        });\n    }\n}\nexports.Server = Server;\nfunction handleUnary(call, handler, metadata, encoding) {\n    call.receiveUnaryMessage(encoding, (err, request) => {\n        if (err) {\n            call.sendError(err);\n            return;\n        }\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n        handler.func(emitter, (err, value, trailer, flags) => {\n            call.sendUnaryMessage(err, value, trailer, flags);\n        });\n    });\n}\nfunction handleClientStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize, encoding);\n    function respond(err, value, trailer, flags) {\n        stream.destroy();\n        call.sendUnaryMessage(err, value, trailer, flags);\n    }\n    if (call.cancelled) {\n        return;\n    }\n    stream.on('error', respond);\n    handler.func(stream, respond);\n}\nfunction handleServerStreaming(call, handler, metadata, encoding) {\n    call.receiveUnaryMessage(encoding, (err, request) => {\n        if (err) {\n            call.sendError(err);\n            return;\n        }\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n        handler.func(stream);\n    });\n}\nfunction handleBidiStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize, encoding);\n    if (call.cancelled) {\n        return;\n    }\n    handler.func(stream);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}