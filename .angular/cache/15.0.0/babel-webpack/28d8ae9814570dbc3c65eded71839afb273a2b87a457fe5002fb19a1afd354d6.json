{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Metadata = void 0;\nconst logging_1 = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\nfunction isLegalKey(key) {\n  return LEGAL_KEY_REGEX.test(key);\n}\nfunction isLegalNonBinaryValue(value) {\n  return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\nfunction isBinaryKey(key) {\n  return key.endsWith('-bin');\n}\nfunction isCustomMetadata(key) {\n  return !key.startsWith('grpc-');\n}\nfunction normalizeKey(key) {\n  return key.toLowerCase();\n}\nfunction validate(key, value) {\n  if (!isLegalKey(key)) {\n    throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n  }\n  if (value !== null && value !== undefined) {\n    if (isBinaryKey(key)) {\n      if (!Buffer.isBuffer(value)) {\n        throw new Error(\"keys that end with '-bin' must have Buffer values\");\n      }\n    } else {\n      if (Buffer.isBuffer(value)) {\n        throw new Error(\"keys that don't end with '-bin' must have String values\");\n      }\n      if (!isLegalNonBinaryValue(value)) {\n        throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n      }\n    }\n  }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\nclass Metadata {\n  constructor(options = {}) {\n    this.internalRepr = new Map();\n    this.options = options;\n  }\n  /**\n   * Sets the given value for the given key by replacing any other values\n   * associated with that key. Normalizes the key.\n   * @param key The key to whose value should be set.\n   * @param value The value to set. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n  set(key, value) {\n    key = normalizeKey(key);\n    validate(key, value);\n    this.internalRepr.set(key, [value]);\n  }\n  /**\n   * Adds the given value for the given key by appending to a list of previous\n   * values associated with that key. Normalizes the key.\n   * @param key The key for which a new value should be appended.\n   * @param value The value to add. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n  add(key, value) {\n    key = normalizeKey(key);\n    validate(key, value);\n    const existingValue = this.internalRepr.get(key);\n    if (existingValue === undefined) {\n      this.internalRepr.set(key, [value]);\n    } else {\n      existingValue.push(value);\n    }\n  }\n  /**\n   * Removes the given key and any associated values. Normalizes the key.\n   * @param key The key whose values should be removed.\n   */\n  remove(key) {\n    key = normalizeKey(key);\n    // validate(key);\n    this.internalRepr.delete(key);\n  }\n  /**\n   * Gets a list of all values associated with the key. Normalizes the key.\n   * @param key The key whose value should be retrieved.\n   * @return A list of values associated with the given key.\n   */\n  get(key) {\n    key = normalizeKey(key);\n    // validate(key);\n    return this.internalRepr.get(key) || [];\n  }\n  /**\n   * Gets a plain object mapping each key to the first value associated with it.\n   * This reflects the most common way that people will want to see metadata.\n   * @return A key/value mapping of the metadata.\n   */\n  getMap() {\n    const result = {};\n    for (const [key, values] of this.internalRepr) {\n      if (values.length > 0) {\n        const v = values[0];\n        result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\n      }\n    }\n    return result;\n  }\n  /**\n   * Clones the metadata object.\n   * @return The newly cloned object.\n   */\n  clone() {\n    const newMetadata = new Metadata(this.options);\n    const newInternalRepr = newMetadata.internalRepr;\n    for (const [key, value] of this.internalRepr) {\n      const clonedValue = value.map(v => {\n        if (Buffer.isBuffer(v)) {\n          return Buffer.from(v);\n        } else {\n          return v;\n        }\n      });\n      newInternalRepr.set(key, clonedValue);\n    }\n    return newMetadata;\n  }\n  /**\n   * Merges all key-value pairs from a given Metadata object into this one.\n   * If both this object and the given object have values in the same key,\n   * values from the other Metadata object will be appended to this object's\n   * values.\n   * @param other A Metadata object.\n   */\n  merge(other) {\n    for (const [key, values] of other.internalRepr) {\n      const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n      this.internalRepr.set(key, mergedValue);\n    }\n  }\n  setOptions(options) {\n    this.options = options;\n  }\n  getOptions() {\n    return this.options;\n  }\n  /**\n   * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n   */\n  toHttp2Headers() {\n    // NOTE: Node <8.9 formats http2 headers incorrectly.\n    const result = {};\n    for (const [key, values] of this.internalRepr) {\n      // We assume that the user's interaction with this object is limited to\n      // through its public API (i.e. keys and values are already validated).\n      result[key] = values.map(bufToString);\n    }\n    return result;\n  }\n  // For compatibility with the other Metadata implementation\n  _getCoreRepresentation() {\n    return this.internalRepr;\n  }\n  /**\n   * This modifies the behavior of JSON.stringify to show an object\n   * representation of the metadata map.\n   */\n  toJSON() {\n    const result = {};\n    for (const [key, values] of this.internalRepr) {\n      result[key] = values;\n    }\n    return result;\n  }\n  /**\n   * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n   * object.\n   * @param headers An IncomingHttpHeaders object.\n   */\n  static fromHttp2Headers(headers) {\n    const result = new Metadata();\n    for (const key of Object.keys(headers)) {\n      // Reserved headers (beginning with `:`) are not valid keys.\n      if (key.charAt(0) === ':') {\n        continue;\n      }\n      const values = headers[key];\n      try {\n        if (isBinaryKey(key)) {\n          if (Array.isArray(values)) {\n            values.forEach(value => {\n              result.add(key, Buffer.from(value, 'base64'));\n            });\n          } else if (values !== undefined) {\n            if (isCustomMetadata(key)) {\n              values.split(',').forEach(v => {\n                result.add(key, Buffer.from(v.trim(), 'base64'));\n              });\n            } else {\n              result.add(key, Buffer.from(values, 'base64'));\n            }\n          }\n        } else {\n          if (Array.isArray(values)) {\n            values.forEach(value => {\n              result.add(key, value);\n            });\n          } else if (values !== undefined) {\n            result.add(key, values);\n          }\n        }\n      } catch (error) {\n        const message = `Failed to add metadata entry ${key}: ${values}. ${error.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n        logging_1.log(constants_1.LogVerbosity.ERROR, message);\n      }\n    }\n    return result;\n  }\n}\nexports.Metadata = Metadata;\nconst bufToString = val => {\n  return Buffer.isBuffer(val) ? val.toString('base64') : val;\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","Metadata","logging_1","require","constants_1","LEGAL_KEY_REGEX","LEGAL_NON_BINARY_VALUE_REGEX","isLegalKey","key","test","isLegalNonBinaryValue","isBinaryKey","endsWith","isCustomMetadata","startsWith","normalizeKey","toLowerCase","validate","Error","undefined","Buffer","isBuffer","constructor","options","internalRepr","Map","set","add","existingValue","get","push","remove","delete","getMap","result","values","length","v","from","clone","newMetadata","newInternalRepr","clonedValue","map","merge","other","mergedValue","concat","setOptions","getOptions","toHttp2Headers","bufToString","_getCoreRepresentation","toJSON","fromHttp2Headers","headers","keys","charAt","Array","isArray","forEach","split","trim","error","message","log","LogVerbosity","ERROR","val","toString"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/metadata.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Metadata = void 0;\nconst logging_1 = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\nfunction isLegalKey(key) {\n    return LEGAL_KEY_REGEX.test(key);\n}\nfunction isLegalNonBinaryValue(value) {\n    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\nfunction isBinaryKey(key) {\n    return key.endsWith('-bin');\n}\nfunction isCustomMetadata(key) {\n    return !key.startsWith('grpc-');\n}\nfunction normalizeKey(key) {\n    return key.toLowerCase();\n}\nfunction validate(key, value) {\n    if (!isLegalKey(key)) {\n        throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n    }\n    if (value !== null && value !== undefined) {\n        if (isBinaryKey(key)) {\n            if (!Buffer.isBuffer(value)) {\n                throw new Error(\"keys that end with '-bin' must have Buffer values\");\n            }\n        }\n        else {\n            if (Buffer.isBuffer(value)) {\n                throw new Error(\"keys that don't end with '-bin' must have String values\");\n            }\n            if (!isLegalNonBinaryValue(value)) {\n                throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n            }\n        }\n    }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\nclass Metadata {\n    constructor(options = {}) {\n        this.internalRepr = new Map();\n        this.options = options;\n    }\n    /**\n     * Sets the given value for the given key by replacing any other values\n     * associated with that key. Normalizes the key.\n     * @param key The key to whose value should be set.\n     * @param value The value to set. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */\n    set(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        this.internalRepr.set(key, [value]);\n    }\n    /**\n     * Adds the given value for the given key by appending to a list of previous\n     * values associated with that key. Normalizes the key.\n     * @param key The key for which a new value should be appended.\n     * @param value The value to add. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */\n    add(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        const existingValue = this.internalRepr.get(key);\n        if (existingValue === undefined) {\n            this.internalRepr.set(key, [value]);\n        }\n        else {\n            existingValue.push(value);\n        }\n    }\n    /**\n     * Removes the given key and any associated values. Normalizes the key.\n     * @param key The key whose values should be removed.\n     */\n    remove(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        this.internalRepr.delete(key);\n    }\n    /**\n     * Gets a list of all values associated with the key. Normalizes the key.\n     * @param key The key whose value should be retrieved.\n     * @return A list of values associated with the given key.\n     */\n    get(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        return this.internalRepr.get(key) || [];\n    }\n    /**\n     * Gets a plain object mapping each key to the first value associated with it.\n     * This reflects the most common way that people will want to see metadata.\n     * @return A key/value mapping of the metadata.\n     */\n    getMap() {\n        const result = {};\n        for (const [key, values] of this.internalRepr) {\n            if (values.length > 0) {\n                const v = values[0];\n                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\n            }\n        }\n        return result;\n    }\n    /**\n     * Clones the metadata object.\n     * @return The newly cloned object.\n     */\n    clone() {\n        const newMetadata = new Metadata(this.options);\n        const newInternalRepr = newMetadata.internalRepr;\n        for (const [key, value] of this.internalRepr) {\n            const clonedValue = value.map((v) => {\n                if (Buffer.isBuffer(v)) {\n                    return Buffer.from(v);\n                }\n                else {\n                    return v;\n                }\n            });\n            newInternalRepr.set(key, clonedValue);\n        }\n        return newMetadata;\n    }\n    /**\n     * Merges all key-value pairs from a given Metadata object into this one.\n     * If both this object and the given object have values in the same key,\n     * values from the other Metadata object will be appended to this object's\n     * values.\n     * @param other A Metadata object.\n     */\n    merge(other) {\n        for (const [key, values] of other.internalRepr) {\n            const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n            this.internalRepr.set(key, mergedValue);\n        }\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n    getOptions() {\n        return this.options;\n    }\n    /**\n     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n     */\n    toHttp2Headers() {\n        // NOTE: Node <8.9 formats http2 headers incorrectly.\n        const result = {};\n        for (const [key, values] of this.internalRepr) {\n            // We assume that the user's interaction with this object is limited to\n            // through its public API (i.e. keys and values are already validated).\n            result[key] = values.map(bufToString);\n        }\n        return result;\n    }\n    // For compatibility with the other Metadata implementation\n    _getCoreRepresentation() {\n        return this.internalRepr;\n    }\n    /**\n     * This modifies the behavior of JSON.stringify to show an object\n     * representation of the metadata map.\n     */\n    toJSON() {\n        const result = {};\n        for (const [key, values] of this.internalRepr) {\n            result[key] = values;\n        }\n        return result;\n    }\n    /**\n     * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n     * object.\n     * @param headers An IncomingHttpHeaders object.\n     */\n    static fromHttp2Headers(headers) {\n        const result = new Metadata();\n        for (const key of Object.keys(headers)) {\n            // Reserved headers (beginning with `:`) are not valid keys.\n            if (key.charAt(0) === ':') {\n                continue;\n            }\n            const values = headers[key];\n            try {\n                if (isBinaryKey(key)) {\n                    if (Array.isArray(values)) {\n                        values.forEach((value) => {\n                            result.add(key, Buffer.from(value, 'base64'));\n                        });\n                    }\n                    else if (values !== undefined) {\n                        if (isCustomMetadata(key)) {\n                            values.split(',').forEach((v) => {\n                                result.add(key, Buffer.from(v.trim(), 'base64'));\n                            });\n                        }\n                        else {\n                            result.add(key, Buffer.from(values, 'base64'));\n                        }\n                    }\n                }\n                else {\n                    if (Array.isArray(values)) {\n                        values.forEach((value) => {\n                            result.add(key, value);\n                        });\n                    }\n                    else if (values !== undefined) {\n                        result.add(key, values);\n                    }\n                }\n            }\n            catch (error) {\n                const message = `Failed to add metadata entry ${key}: ${values}. ${error.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n                logging_1.log(constants_1.LogVerbosity.ERROR, message);\n            }\n        }\n        return result;\n    }\n}\nexports.Metadata = Metadata;\nconst bufToString = (val) => {\n    return Buffer.isBuffer(val) ? val.toString('base64') : val;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}