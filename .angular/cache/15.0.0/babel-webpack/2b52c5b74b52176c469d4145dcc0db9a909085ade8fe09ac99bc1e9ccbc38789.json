{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _asyncToGenerator = require(\"/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nconst events_1 = require(\"events\");\nconst http2 = require(\"http2\");\nconst stream_1 = require(\"stream\");\nconst zlib = require(\"zlib\");\nconst util_1 = require(\"util\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst TRACER_NAME = 'server_call';\nconst unzip = util_1.promisify(zlib.unzip);\nconst inflate = util_1.promisify(zlib.inflate);\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001\n};\nconst defaultResponseHeaders = {\n  // TODO(cjihrig): Remove these encoding headers from the default response\n  // once compression is integrated.\n  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n  [GRPC_ENCODING_HEADER]: 'identity',\n  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto'\n};\nconst defaultResponseOptions = {\n  waitForTrailers: true\n};\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n  constructor(call, metadata, request) {\n    super();\n    this.call = call;\n    this.metadata = metadata;\n    this.request = request;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n  constructor(call, metadata, deserialize, encoding) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n  }\n  _read(size) {\n    if (!this.call.consumeUnpushedMessages(this)) {\n      return;\n    }\n    this.call.resume();\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n  constructor(call, metadata, serialize, request) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.request = request;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n  _write(chunk, encoding,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  callback) {\n    try {\n      const response = this.call.serializeMessage(chunk);\n      if (!this.call.write(response)) {\n        this.call.once('drain', callback);\n        return;\n      }\n    } catch (err) {\n      err.code = constants_1.Status.INTERNAL;\n      this.emit('error', err);\n    }\n    callback();\n  }\n  _final(callback) {\n    this.call.sendStatus({\n      code: constants_1.Status.OK,\n      details: 'OK',\n      metadata: this.trailingMetadata\n    });\n    callback(null);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n    return super.end();\n  }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n  constructor(call, metadata, serialize, deserialize, encoding) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n    return super.end();\n  }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;\n// Internal class that wraps the HTTP2 request.\nclass Http2ServerCallStream extends events_1.EventEmitter {\n  constructor(stream, handler, options) {\n    super();\n    this.stream = stream;\n    this.handler = handler;\n    this.options = options;\n    this.cancelled = false;\n    this.deadlineTimer = null;\n    this.statusSent = false;\n    this.deadline = Infinity;\n    this.wantTrailers = false;\n    this.metadataSent = false;\n    this.canPush = false;\n    this.isPushPending = false;\n    this.bufferedMessages = [];\n    this.messagesToPush = [];\n    this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    this.stream.once('error', err => {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n    this.stream.once('close', () => {\n      var _a;\n      trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' stream closed with rstCode ' + this.stream.rstCode);\n      if (!this.statusSent) {\n        this.cancelled = true;\n        this.emit('cancelled', 'cancelled');\n        this.emit('streamEnd', false);\n        this.sendStatus({\n          code: constants_1.Status.CANCELLED,\n          details: 'Cancelled by client',\n          metadata: null\n        });\n      }\n    });\n    this.stream.on('drain', () => {\n      this.emit('drain');\n    });\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length'];\n    }\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n    }\n  }\n  checkCancelled() {\n    /* In some cases the stream can become destroyed before the close event\n     * fires. That creates a race condition that this check works around */\n    if (this.stream.destroyed || this.stream.closed) {\n      this.cancelled = true;\n    }\n    return this.cancelled;\n  }\n  getDecompressedMessage(message, encoding) {\n    if (encoding === 'deflate') {\n      return inflate(message.subarray(5));\n    } else if (encoding === 'gzip') {\n      return unzip(message.subarray(5));\n    } else if (encoding === 'identity') {\n      return message.subarray(5);\n    }\n    return Promise.reject({\n      code: constants_1.Status.UNIMPLEMENTED,\n      details: `Received message compressed with unsupported encoding \"${encoding}\"`\n    });\n  }\n  sendMetadata(customMetadata) {\n    if (this.checkCancelled()) {\n      return;\n    }\n    if (this.metadataSent) {\n      return;\n    }\n    this.metadataSent = true;\n    const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n    // TODO(cjihrig): Include compression headers.\n    const headers = Object.assign(Object.assign({}, defaultResponseHeaders), custom);\n    this.stream.respond(headers, defaultResponseOptions);\n  }\n  receiveMetadata(headers) {\n    const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      trace('Request to ' + this.handler.path + ' received headers ' + JSON.stringify(metadata.toJSON()));\n    }\n    // TODO(cjihrig): Receive compression metadata.\n    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n    if (timeoutHeader.length > 0) {\n      const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n      if (match === null) {\n        const err = new Error('Invalid deadline');\n        err.code = constants_1.Status.OUT_OF_RANGE;\n        this.sendError(err);\n        return metadata;\n      }\n      const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;\n      const now = new Date();\n      this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n      this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n      metadata.remove(GRPC_TIMEOUT_HEADER);\n    }\n    // Remove several headers that should not be propagated to the application\n    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n    metadata.remove(http2.constants.HTTP2_HEADER_TE);\n    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n  receiveUnaryMessage(encoding, next) {\n    const {\n      stream\n    } = this;\n    let receivedLength = 0;\n    const call = this;\n    const body = [];\n    const limit = this.maxReceiveMessageSize;\n    stream.on('data', onData);\n    stream.on('end', onEnd);\n    stream.on('error', onEnd);\n    function onData(chunk) {\n      receivedLength += chunk.byteLength;\n      if (limit !== -1 && receivedLength > limit) {\n        stream.removeListener('data', onData);\n        stream.removeListener('end', onEnd);\n        stream.removeListener('error', onEnd);\n        next({\n          code: constants_1.Status.RESOURCE_EXHAUSTED,\n          details: `Received message larger than max (${receivedLength} vs. ${limit})`\n        });\n        return;\n      }\n      body.push(chunk);\n    }\n    function onEnd(err) {\n      stream.removeListener('data', onData);\n      stream.removeListener('end', onEnd);\n      stream.removeListener('error', onEnd);\n      if (err !== undefined) {\n        next({\n          code: constants_1.Status.INTERNAL,\n          details: err.message\n        });\n        return;\n      }\n      if (receivedLength === 0) {\n        next({\n          code: constants_1.Status.INTERNAL,\n          details: 'received empty unary message'\n        });\n        return;\n      }\n      call.emit('receiveMessage');\n      const requestBytes = Buffer.concat(body, receivedLength);\n      const compressed = requestBytes.readUInt8(0) === 1;\n      const compressedMessageEncoding = compressed ? encoding : 'identity';\n      const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);\n      if (Buffer.isBuffer(decompressedMessage)) {\n        call.safeDeserializeMessage(decompressedMessage, next);\n        return;\n      }\n      decompressedMessage.then(decompressed => call.safeDeserializeMessage(decompressed, next), err => next(err.code ? err : {\n        code: constants_1.Status.INTERNAL,\n        details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`\n      }));\n    }\n  }\n  safeDeserializeMessage(buffer, next) {\n    try {\n      next(null, this.deserializeMessage(buffer));\n    } catch (err) {\n      err.code = constants_1.Status.INTERNAL;\n      next(err);\n    }\n  }\n  serializeMessage(value) {\n    const messageBuffer = this.handler.serialize(value);\n    // TODO(cjihrig): Call compression aware serializeMessage().\n    const byteLength = messageBuffer.byteLength;\n    const output = Buffer.allocUnsafe(byteLength + 5);\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(byteLength, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n  deserializeMessage(bytes) {\n    return this.handler.deserialize(bytes);\n  }\n  sendUnaryMessage(err, value, metadata, flags) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.checkCancelled()) {\n        return;\n      }\n      if (metadata === undefined) {\n        metadata = null;\n      }\n      if (err) {\n        if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) {\n          err.metadata = metadata;\n        }\n        _this.sendError(err);\n        return;\n      }\n      try {\n        const response = _this.serializeMessage(value);\n        _this.write(response);\n        _this.sendStatus({\n          code: constants_1.Status.OK,\n          details: 'OK',\n          metadata\n        });\n      } catch (err) {\n        err.code = constants_1.Status.INTERNAL;\n        _this.sendError(err);\n      }\n    })();\n  }\n  sendStatus(statusObj) {\n    var _a;\n    this.emit('callEnd', statusObj.code);\n    this.emit('streamEnd', statusObj.code === constants_1.Status.OK);\n    if (this.checkCancelled()) {\n      return;\n    }\n    trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' ended with status code: ' + constants_1.Status[statusObj.code] + ' details: ' + statusObj.details);\n    if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n    if (!this.wantTrailers) {\n      this.wantTrailers = true;\n      this.stream.once('wantTrailers', () => {\n        var _a;\n        const trailersToSend = Object.assign({\n          [GRPC_STATUS_HEADER]: statusObj.code,\n          [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n        }, (_a = statusObj.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\n        this.stream.sendTrailers(trailersToSend);\n        this.statusSent = true;\n      });\n      this.sendMetadata();\n      this.stream.end();\n    }\n  }\n  sendError(error) {\n    const status = {\n      code: constants_1.Status.UNKNOWN,\n      details: 'message' in error ? error.message : 'Unknown Error',\n      metadata: 'metadata' in error && error.metadata !== undefined ? error.metadata : null\n    };\n    if ('code' in error && typeof error.code === 'number' && Number.isInteger(error.code)) {\n      status.code = error.code;\n      if ('details' in error && typeof error.details === 'string') {\n        status.details = error.details;\n      }\n    }\n    this.sendStatus(status);\n  }\n  write(chunk) {\n    if (this.checkCancelled()) {\n      return;\n    }\n    if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {\n      this.sendError({\n        code: constants_1.Status.RESOURCE_EXHAUSTED,\n        details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`\n      });\n      return;\n    }\n    this.sendMetadata();\n    this.emit('sendMessage');\n    return this.stream.write(chunk);\n  }\n  resume() {\n    this.stream.resume();\n  }\n  setupSurfaceCall(call) {\n    this.once('cancelled', reason => {\n      call.cancelled = true;\n      call.emit('cancelled', reason);\n    });\n    this.once('callEnd', status => call.emit('callEnd', status));\n  }\n  setupReadable(readable, encoding) {\n    var _this2 = this;\n    const decoder = new stream_decoder_1.StreamDecoder();\n    let readsDone = false;\n    let pendingMessageProcessing = false;\n    let pushedEnd = false;\n    const maybePushEnd = () => {\n      if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n        pushedEnd = true;\n        this.pushOrBufferMessage(readable, null);\n      }\n    };\n    this.stream.on('data', /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (data) {\n        const messages = decoder.write(data);\n        pendingMessageProcessing = true;\n        _this2.stream.pause();\n        for (const message of messages) {\n          if (_this2.maxReceiveMessageSize !== -1 && message.length > _this2.maxReceiveMessageSize) {\n            _this2.sendError({\n              code: constants_1.Status.RESOURCE_EXHAUSTED,\n              details: `Received message larger than max (${message.length} vs. ${_this2.maxReceiveMessageSize})`\n            });\n            return;\n          }\n          _this2.emit('receiveMessage');\n          const compressed = message.readUInt8(0) === 1;\n          const compressedMessageEncoding = compressed ? encoding : 'identity';\n          const decompressedMessage = yield _this2.getDecompressedMessage(message, compressedMessageEncoding);\n          // Encountered an error with decompression; it'll already have been propogated back\n          // Just return early\n          if (!decompressedMessage) return;\n          _this2.pushOrBufferMessage(readable, decompressedMessage);\n        }\n        pendingMessageProcessing = false;\n        _this2.stream.resume();\n        maybePushEnd();\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    this.stream.once('end', () => {\n      readsDone = true;\n      maybePushEnd();\n    });\n  }\n  consumeUnpushedMessages(readable) {\n    this.canPush = true;\n    while (this.messagesToPush.length > 0) {\n      const nextMessage = this.messagesToPush.shift();\n      const canPush = readable.push(nextMessage);\n      if (nextMessage === null || canPush === false) {\n        this.canPush = false;\n        break;\n      }\n    }\n    return this.canPush;\n  }\n  pushOrBufferMessage(readable, messageBytes) {\n    if (this.isPushPending) {\n      this.bufferedMessages.push(messageBytes);\n    } else {\n      this.pushMessage(readable, messageBytes);\n    }\n  }\n  pushMessage(readable, messageBytes) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (messageBytes === null) {\n        trace('Received end of stream');\n        if (_this3.canPush) {\n          readable.push(null);\n        } else {\n          _this3.messagesToPush.push(null);\n        }\n        return;\n      }\n      trace('Received message of length ' + messageBytes.length);\n      _this3.isPushPending = true;\n      try {\n        const deserialized = yield _this3.deserializeMessage(messageBytes);\n        if (_this3.canPush) {\n          if (!readable.push(deserialized)) {\n            _this3.canPush = false;\n            _this3.stream.pause();\n          }\n        } else {\n          _this3.messagesToPush.push(deserialized);\n        }\n      } catch (error) {\n        // Ignore any remaining messages when errors occur.\n        _this3.bufferedMessages.length = 0;\n        if (!('code' in error && typeof error.code === 'number' && Number.isInteger(error.code) && error.code >= constants_1.Status.OK && error.code <= constants_1.Status.UNAUTHENTICATED)) {\n          // The error code is not a valid gRPC code so its being overwritten.\n          error.code = constants_1.Status.INTERNAL;\n        }\n        readable.emit('error', error);\n      }\n      _this3.isPushPending = false;\n      if (_this3.bufferedMessages.length > 0) {\n        _this3.pushMessage(readable, _this3.bufferedMessages.shift());\n      }\n    })();\n  }\n  getPeer() {\n    const socket = this.stream.session.socket;\n    if (socket.remoteAddress) {\n      if (socket.remotePort) {\n        return `${socket.remoteAddress}:${socket.remotePort}`;\n      } else {\n        return socket.remoteAddress;\n      }\n    } else {\n      return 'unknown';\n    }\n  }\n  getDeadline() {\n    return this.deadline;\n  }\n  getPath() {\n    return this.handler.path;\n  }\n}\nexports.Http2ServerCallStream = Http2ServerCallStream;\nfunction handleExpiredDeadline(call) {\n  const err = new Error('Deadline exceeded');\n  err.code = constants_1.Status.DEADLINE_EXCEEDED;\n  call.sendError(err);\n  call.cancelled = true;\n  call.emit('cancelled', 'deadline');\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Http2ServerCallStream","ServerDuplexStreamImpl","ServerWritableStreamImpl","ServerReadableStreamImpl","ServerUnaryCallImpl","events_1","require","http2","stream_1","zlib","util_1","constants_1","metadata_1","stream_decoder_1","logging","TRACER_NAME","unzip","promisify","inflate","trace","text","LogVerbosity","DEBUG","GRPC_ACCEPT_ENCODING_HEADER","GRPC_ENCODING_HEADER","GRPC_MESSAGE_HEADER","GRPC_STATUS_HEADER","GRPC_TIMEOUT_HEADER","DEADLINE_REGEX","deadlineUnitsToMs","H","M","S","m","u","n","defaultResponseHeaders","constants","HTTP2_HEADER_STATUS","HTTP_STATUS_OK","HTTP2_HEADER_CONTENT_TYPE","defaultResponseOptions","waitForTrailers","EventEmitter","constructor","call","metadata","request","cancelled","setupSurfaceCall","getPeer","sendMetadata","responseMetadata","getDeadline","getPath","Readable","deserialize","encoding","objectMode","setupReadable","_read","size","consumeUnpushedMessages","resume","Writable","serialize","trailingMetadata","Metadata","on","err","sendError","end","_write","chunk","callback","response","serializeMessage","write","once","code","Status","INTERNAL","emit","_final","sendStatus","OK","details","Duplex","prototype","stream","handler","options","deadlineTimer","statusSent","deadline","Infinity","wantTrailers","metadataSent","canPush","isPushPending","bufferedMessages","messagesToPush","maxSendMessageSize","DEFAULT_MAX_SEND_MESSAGE_LENGTH","maxReceiveMessageSize","DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH","_a","path","rstCode","CANCELLED","checkCancelled","destroyed","closed","getDecompressedMessage","message","subarray","Promise","reject","UNIMPLEMENTED","customMetadata","custom","toHttp2Headers","headers","assign","respond","receiveMetadata","fromHttp2Headers","isTracerEnabled","JSON","stringify","toJSON","timeoutHeader","get","length","match","toString","Error","OUT_OF_RANGE","timeout","now","Date","setMilliseconds","getMilliseconds","setTimeout","handleExpiredDeadline","remove","HTTP2_HEADER_ACCEPT_ENCODING","HTTP2_HEADER_TE","receiveUnaryMessage","next","receivedLength","body","limit","onData","onEnd","byteLength","removeListener","RESOURCE_EXHAUSTED","push","undefined","requestBytes","Buffer","concat","compressed","readUInt8","compressedMessageEncoding","decompressedMessage","isBuffer","safeDeserializeMessage","then","decompressed","buffer","deserializeMessage","messageBuffer","output","allocUnsafe","writeUInt8","writeUInt32BE","copy","bytes","sendUnaryMessage","flags","hasOwnProperty","statusObj","clearTimeout","trailersToSend","encodeURI","sendTrailers","error","status","UNKNOWN","Number","isInteger","reason","readable","decoder","StreamDecoder","readsDone","pendingMessageProcessing","pushedEnd","maybePushEnd","pushOrBufferMessage","data","messages","pause","nextMessage","shift","messageBytes","pushMessage","deserialized","UNAUTHENTICATED","socket","session","remoteAddress","remotePort","DEADLINE_EXCEEDED"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/server-call.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nconst events_1 = require(\"events\");\nconst http2 = require(\"http2\");\nconst stream_1 = require(\"stream\");\nconst zlib = require(\"zlib\");\nconst util_1 = require(\"util\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst TRACER_NAME = 'server_call';\nconst unzip = util_1.promisify(zlib.unzip);\nconst inflate = util_1.promisify(zlib.inflate);\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n    H: 3600000,\n    M: 60000,\n    S: 1000,\n    m: 1,\n    u: 0.001,\n    n: 0.000001,\n};\nconst defaultResponseHeaders = {\n    // TODO(cjihrig): Remove these encoding headers from the default response\n    // once compression is integrated.\n    [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n    [GRPC_ENCODING_HEADER]: 'identity',\n    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\n};\nconst defaultResponseOptions = {\n    waitForTrailers: true,\n};\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n    constructor(call, metadata, request) {\n        super();\n        this.call = call;\n        this.metadata = metadata;\n        this.request = request;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n    constructor(call, metadata, deserialize, encoding) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n    }\n    _read(size) {\n        if (!this.call.consumeUnpushedMessages(this)) {\n            return;\n        }\n        this.call.resume();\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n    constructor(call, metadata, serialize, request) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.request = request;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.on('error', (err) => {\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    _write(chunk, encoding, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        try {\n            const response = this.call.serializeMessage(chunk);\n            if (!this.call.write(response)) {\n                this.call.once('drain', callback);\n                return;\n            }\n        }\n        catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            this.emit('error', err);\n        }\n        callback();\n    }\n    _final(callback) {\n        this.call.sendStatus({\n            code: constants_1.Status.OK,\n            details: 'OK',\n            metadata: this.trailingMetadata,\n        });\n        callback(null);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n    constructor(call, metadata, serialize, deserialize, encoding) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n        this.on('error', (err) => {\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read =\n    ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write =\n    ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final =\n    ServerWritableStreamImpl.prototype._final;\n// Internal class that wraps the HTTP2 request.\nclass Http2ServerCallStream extends events_1.EventEmitter {\n    constructor(stream, handler, options) {\n        super();\n        this.stream = stream;\n        this.handler = handler;\n        this.options = options;\n        this.cancelled = false;\n        this.deadlineTimer = null;\n        this.statusSent = false;\n        this.deadline = Infinity;\n        this.wantTrailers = false;\n        this.metadataSent = false;\n        this.canPush = false;\n        this.isPushPending = false;\n        this.bufferedMessages = [];\n        this.messagesToPush = [];\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.stream.once('error', (err) => {\n            /* We need an error handler to avoid uncaught error event exceptions, but\n             * there is nothing we can reasonably do here. Any error event should\n             * have a corresponding close event, which handles emitting the cancelled\n             * event. And the stream is now in a bad state, so we can't reasonably\n             * expect to be able to send an error over it. */\n        });\n        this.stream.once('close', () => {\n            var _a;\n            trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\n                ' stream closed with rstCode ' +\n                this.stream.rstCode);\n            if (!this.statusSent) {\n                this.cancelled = true;\n                this.emit('cancelled', 'cancelled');\n                this.emit('streamEnd', false);\n                this.sendStatus({\n                    code: constants_1.Status.CANCELLED,\n                    details: 'Cancelled by client',\n                    metadata: null,\n                });\n            }\n        });\n        this.stream.on('drain', () => {\n            this.emit('drain');\n        });\n        if ('grpc.max_send_message_length' in options) {\n            this.maxSendMessageSize = options['grpc.max_send_message_length'];\n        }\n        if ('grpc.max_receive_message_length' in options) {\n            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n        }\n    }\n    checkCancelled() {\n        /* In some cases the stream can become destroyed before the close event\n         * fires. That creates a race condition that this check works around */\n        if (this.stream.destroyed || this.stream.closed) {\n            this.cancelled = true;\n        }\n        return this.cancelled;\n    }\n    getDecompressedMessage(message, encoding) {\n        if (encoding === 'deflate') {\n            return inflate(message.subarray(5));\n        }\n        else if (encoding === 'gzip') {\n            return unzip(message.subarray(5));\n        }\n        else if (encoding === 'identity') {\n            return message.subarray(5);\n        }\n        return Promise.reject({\n            code: constants_1.Status.UNIMPLEMENTED,\n            details: `Received message compressed with unsupported encoding \"${encoding}\"`,\n        });\n    }\n    sendMetadata(customMetadata) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.metadataSent) {\n            return;\n        }\n        this.metadataSent = true;\n        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n        // TODO(cjihrig): Include compression headers.\n        const headers = Object.assign(Object.assign({}, defaultResponseHeaders), custom);\n        this.stream.respond(headers, defaultResponseOptions);\n    }\n    receiveMetadata(headers) {\n        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            trace('Request to ' +\n                this.handler.path +\n                ' received headers ' +\n                JSON.stringify(metadata.toJSON()));\n        }\n        // TODO(cjihrig): Receive compression metadata.\n        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n        if (timeoutHeader.length > 0) {\n            const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n            if (match === null) {\n                const err = new Error('Invalid deadline');\n                err.code = constants_1.Status.OUT_OF_RANGE;\n                this.sendError(err);\n                return metadata;\n            }\n            const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;\n            const now = new Date();\n            this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n            this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n            metadata.remove(GRPC_TIMEOUT_HEADER);\n        }\n        // Remove several headers that should not be propagated to the application\n        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n        metadata.remove(http2.constants.HTTP2_HEADER_TE);\n        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n        metadata.remove('grpc-accept-encoding');\n        return metadata;\n    }\n    receiveUnaryMessage(encoding, next) {\n        const { stream } = this;\n        let receivedLength = 0;\n        const call = this;\n        const body = [];\n        const limit = this.maxReceiveMessageSize;\n        stream.on('data', onData);\n        stream.on('end', onEnd);\n        stream.on('error', onEnd);\n        function onData(chunk) {\n            receivedLength += chunk.byteLength;\n            if (limit !== -1 && receivedLength > limit) {\n                stream.removeListener('data', onData);\n                stream.removeListener('end', onEnd);\n                stream.removeListener('error', onEnd);\n                next({\n                    code: constants_1.Status.RESOURCE_EXHAUSTED,\n                    details: `Received message larger than max (${receivedLength} vs. ${limit})`,\n                });\n                return;\n            }\n            body.push(chunk);\n        }\n        function onEnd(err) {\n            stream.removeListener('data', onData);\n            stream.removeListener('end', onEnd);\n            stream.removeListener('error', onEnd);\n            if (err !== undefined) {\n                next({ code: constants_1.Status.INTERNAL, details: err.message });\n                return;\n            }\n            if (receivedLength === 0) {\n                next({ code: constants_1.Status.INTERNAL, details: 'received empty unary message' });\n                return;\n            }\n            call.emit('receiveMessage');\n            const requestBytes = Buffer.concat(body, receivedLength);\n            const compressed = requestBytes.readUInt8(0) === 1;\n            const compressedMessageEncoding = compressed ? encoding : 'identity';\n            const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);\n            if (Buffer.isBuffer(decompressedMessage)) {\n                call.safeDeserializeMessage(decompressedMessage, next);\n                return;\n            }\n            decompressedMessage.then((decompressed) => call.safeDeserializeMessage(decompressed, next), (err) => next(err.code\n                ? err\n                : {\n                    code: constants_1.Status.INTERNAL,\n                    details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`,\n                }));\n        }\n    }\n    safeDeserializeMessage(buffer, next) {\n        try {\n            next(null, this.deserializeMessage(buffer));\n        }\n        catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            next(err);\n        }\n    }\n    serializeMessage(value) {\n        const messageBuffer = this.handler.serialize(value);\n        // TODO(cjihrig): Call compression aware serializeMessage().\n        const byteLength = messageBuffer.byteLength;\n        const output = Buffer.allocUnsafe(byteLength + 5);\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(byteLength, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    deserializeMessage(bytes) {\n        return this.handler.deserialize(bytes);\n    }\n    async sendUnaryMessage(err, value, metadata, flags) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (metadata === undefined) {\n            metadata = null;\n        }\n        if (err) {\n            if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) {\n                err.metadata = metadata;\n            }\n            this.sendError(err);\n            return;\n        }\n        try {\n            const response = this.serializeMessage(value);\n            this.write(response);\n            this.sendStatus({ code: constants_1.Status.OK, details: 'OK', metadata });\n        }\n        catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            this.sendError(err);\n        }\n    }\n    sendStatus(statusObj) {\n        var _a;\n        this.emit('callEnd', statusObj.code);\n        this.emit('streamEnd', statusObj.code === constants_1.Status.OK);\n        if (this.checkCancelled()) {\n            return;\n        }\n        trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\n            ' ended with status code: ' +\n            constants_1.Status[statusObj.code] +\n            ' details: ' +\n            statusObj.details);\n        if (this.deadlineTimer)\n            clearTimeout(this.deadlineTimer);\n        if (!this.wantTrailers) {\n            this.wantTrailers = true;\n            this.stream.once('wantTrailers', () => {\n                var _a;\n                const trailersToSend = Object.assign({ [GRPC_STATUS_HEADER]: statusObj.code, [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details) }, (_a = statusObj.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\n                this.stream.sendTrailers(trailersToSend);\n                this.statusSent = true;\n            });\n            this.sendMetadata();\n            this.stream.end();\n        }\n    }\n    sendError(error) {\n        const status = {\n            code: constants_1.Status.UNKNOWN,\n            details: 'message' in error ? error.message : 'Unknown Error',\n            metadata: 'metadata' in error && error.metadata !== undefined\n                ? error.metadata\n                : null,\n        };\n        if ('code' in error &&\n            typeof error.code === 'number' &&\n            Number.isInteger(error.code)) {\n            status.code = error.code;\n            if ('details' in error && typeof error.details === 'string') {\n                status.details = error.details;\n            }\n        }\n        this.sendStatus(status);\n    }\n    write(chunk) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.maxSendMessageSize !== -1 &&\n            chunk.length > this.maxSendMessageSize) {\n            this.sendError({\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\n                details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`,\n            });\n            return;\n        }\n        this.sendMetadata();\n        this.emit('sendMessage');\n        return this.stream.write(chunk);\n    }\n    resume() {\n        this.stream.resume();\n    }\n    setupSurfaceCall(call) {\n        this.once('cancelled', (reason) => {\n            call.cancelled = true;\n            call.emit('cancelled', reason);\n        });\n        this.once('callEnd', (status) => call.emit('callEnd', status));\n    }\n    setupReadable(readable, encoding) {\n        const decoder = new stream_decoder_1.StreamDecoder();\n        let readsDone = false;\n        let pendingMessageProcessing = false;\n        let pushedEnd = false;\n        const maybePushEnd = () => {\n            if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n                pushedEnd = true;\n                this.pushOrBufferMessage(readable, null);\n            }\n        };\n        this.stream.on('data', async (data) => {\n            const messages = decoder.write(data);\n            pendingMessageProcessing = true;\n            this.stream.pause();\n            for (const message of messages) {\n                if (this.maxReceiveMessageSize !== -1 &&\n                    message.length > this.maxReceiveMessageSize) {\n                    this.sendError({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`,\n                    });\n                    return;\n                }\n                this.emit('receiveMessage');\n                const compressed = message.readUInt8(0) === 1;\n                const compressedMessageEncoding = compressed ? encoding : 'identity';\n                const decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);\n                // Encountered an error with decompression; it'll already have been propogated back\n                // Just return early\n                if (!decompressedMessage)\n                    return;\n                this.pushOrBufferMessage(readable, decompressedMessage);\n            }\n            pendingMessageProcessing = false;\n            this.stream.resume();\n            maybePushEnd();\n        });\n        this.stream.once('end', () => {\n            readsDone = true;\n            maybePushEnd();\n        });\n    }\n    consumeUnpushedMessages(readable) {\n        this.canPush = true;\n        while (this.messagesToPush.length > 0) {\n            const nextMessage = this.messagesToPush.shift();\n            const canPush = readable.push(nextMessage);\n            if (nextMessage === null || canPush === false) {\n                this.canPush = false;\n                break;\n            }\n        }\n        return this.canPush;\n    }\n    pushOrBufferMessage(readable, messageBytes) {\n        if (this.isPushPending) {\n            this.bufferedMessages.push(messageBytes);\n        }\n        else {\n            this.pushMessage(readable, messageBytes);\n        }\n    }\n    async pushMessage(readable, messageBytes) {\n        if (messageBytes === null) {\n            trace('Received end of stream');\n            if (this.canPush) {\n                readable.push(null);\n            }\n            else {\n                this.messagesToPush.push(null);\n            }\n            return;\n        }\n        trace('Received message of length ' + messageBytes.length);\n        this.isPushPending = true;\n        try {\n            const deserialized = await this.deserializeMessage(messageBytes);\n            if (this.canPush) {\n                if (!readable.push(deserialized)) {\n                    this.canPush = false;\n                    this.stream.pause();\n                }\n            }\n            else {\n                this.messagesToPush.push(deserialized);\n            }\n        }\n        catch (error) {\n            // Ignore any remaining messages when errors occur.\n            this.bufferedMessages.length = 0;\n            if (!('code' in error &&\n                typeof error.code === 'number' &&\n                Number.isInteger(error.code) &&\n                error.code >= constants_1.Status.OK &&\n                error.code <= constants_1.Status.UNAUTHENTICATED)) {\n                // The error code is not a valid gRPC code so its being overwritten.\n                error.code = constants_1.Status.INTERNAL;\n            }\n            readable.emit('error', error);\n        }\n        this.isPushPending = false;\n        if (this.bufferedMessages.length > 0) {\n            this.pushMessage(readable, this.bufferedMessages.shift());\n        }\n    }\n    getPeer() {\n        const socket = this.stream.session.socket;\n        if (socket.remoteAddress) {\n            if (socket.remotePort) {\n                return `${socket.remoteAddress}:${socket.remotePort}`;\n            }\n            else {\n                return socket.remoteAddress;\n            }\n        }\n        else {\n            return 'unknown';\n        }\n    }\n    getDeadline() {\n        return this.deadline;\n    }\n    getPath() {\n        return this.handler.path;\n    }\n}\nexports.Http2ServerCallStream = Http2ServerCallStream;\nfunction handleExpiredDeadline(call) {\n    const err = new Error('Deadline exceeded');\n    err.code = constants_1.Status.DEADLINE_EXCEEDED;\n    call.sendError(err);\n    call.cancelled = true;\n    call.emit('cancelled', 'deadline');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}