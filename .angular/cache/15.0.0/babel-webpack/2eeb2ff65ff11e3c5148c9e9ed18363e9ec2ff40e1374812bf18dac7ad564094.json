{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getProxiedConnection = exports.mapProxyName = void 0;\nconst logging_1 = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst resolver_1 = require(\"./resolver\");\nconst http = require(\"http\");\nconst tls = require(\"tls\");\nconst logging = require(\"./logging\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst url_1 = require(\"url\");\nconst TRACER_NAME = 'proxy';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n  let proxyEnv = '';\n  let envVar = '';\n  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n   * fallback behavior can be removed if there's a demand for it.\n   */\n  if (process.env.grpc_proxy) {\n    envVar = 'grpc_proxy';\n    proxyEnv = process.env.grpc_proxy;\n  } else if (process.env.https_proxy) {\n    envVar = 'https_proxy';\n    proxyEnv = process.env.https_proxy;\n  } else if (process.env.http_proxy) {\n    envVar = 'http_proxy';\n    proxyEnv = process.env.http_proxy;\n  } else {\n    return {};\n  }\n  let proxyUrl;\n  try {\n    proxyUrl = new url_1.URL(proxyEnv);\n  } catch (e) {\n    logging_1.log(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n    return {};\n  }\n  if (proxyUrl.protocol !== 'http:') {\n    logging_1.log(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n    return {};\n  }\n  let userCred = null;\n  if (proxyUrl.username) {\n    if (proxyUrl.password) {\n      logging_1.log(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\n      userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n    } else {\n      userCred = proxyUrl.username;\n    }\n  }\n  const hostname = proxyUrl.hostname;\n  let port = proxyUrl.port;\n  /* The proxy URL uses the scheme \"http:\", which has a default port number of\n   * 80. We need to set that explicitly here if it is omitted because otherwise\n   * it will use gRPC's default port 443. */\n  if (port === '') {\n    port = '80';\n  }\n  const result = {\n    address: `${hostname}:${port}`\n  };\n  if (userCred) {\n    result.creds = userCred;\n  }\n  trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\n  return result;\n}\nfunction getNoProxyHostList() {\n  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n  let noProxyStr = process.env.no_grpc_proxy;\n  let envVar = 'no_grpc_proxy';\n  if (!noProxyStr) {\n    noProxyStr = process.env.no_proxy;\n    envVar = 'no_proxy';\n  }\n  if (noProxyStr) {\n    trace('No proxy server list set by environment variable ' + envVar);\n    return noProxyStr.split(',');\n  } else {\n    return [];\n  }\n}\nfunction mapProxyName(target, options) {\n  var _a;\n  const noProxyResult = {\n    target: target,\n    extraOptions: {}\n  };\n  if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {\n    return noProxyResult;\n  }\n  if (target.scheme === 'unix') {\n    return noProxyResult;\n  }\n  const proxyInfo = getProxyInfo();\n  if (!proxyInfo.address) {\n    return noProxyResult;\n  }\n  const hostPort = uri_parser_1.splitHostPort(target.path);\n  if (!hostPort) {\n    return noProxyResult;\n  }\n  const serverHost = hostPort.host;\n  for (const host of getNoProxyHostList()) {\n    if (host === serverHost) {\n      trace('Not using proxy for target in no_proxy list: ' + uri_parser_1.uriToString(target));\n      return noProxyResult;\n    }\n  }\n  const extraOptions = {\n    'grpc.http_connect_target': uri_parser_1.uriToString(target)\n  };\n  if (proxyInfo.creds) {\n    extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n  }\n  return {\n    target: {\n      scheme: 'dns',\n      path: proxyInfo.address\n    },\n    extraOptions: extraOptions\n  };\n}\nexports.mapProxyName = mapProxyName;\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\n  if (!('grpc.http_connect_target' in channelOptions)) {\n    return Promise.resolve({});\n  }\n  const realTarget = channelOptions['grpc.http_connect_target'];\n  const parsedTarget = uri_parser_1.parseUri(realTarget);\n  if (parsedTarget === null) {\n    return Promise.resolve({});\n  }\n  const options = {\n    method: 'CONNECT',\n    path: parsedTarget.path\n  };\n  const headers = {\n    Host: parsedTarget.path\n  };\n  // Connect to the subchannel address as a proxy\n  if (subchannel_address_1.isTcpSubchannelAddress(address)) {\n    options.host = address.host;\n    options.port = address.port;\n  } else {\n    options.socketPath = address.path;\n  }\n  if ('grpc.http_connect_creds' in channelOptions) {\n    headers['Proxy-Authorization'] = 'Basic ' + Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');\n  }\n  options.headers = headers;\n  const proxyAddressString = subchannel_address_1.subchannelAddressToString(address);\n  trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n  return new Promise((resolve, reject) => {\n    const request = http.request(options);\n    request.once('connect', (res, socket, head) => {\n      var _a;\n      request.removeAllListeners();\n      socket.removeAllListeners();\n      if (res.statusCode === 200) {\n        trace('Successfully connected to ' + options.path + ' through proxy ' + proxyAddressString);\n        if ('secureContext' in connectionOptions) {\n          /* The proxy is connecting to a TLS server, so upgrade this socket\n           * connection to a TLS connection.\n           * This is a workaround for https://github.com/nodejs/node/issues/32922\n           * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n          const targetPath = resolver_1.getDefaultAuthority(parsedTarget);\n          const hostPort = uri_parser_1.splitHostPort(targetPath);\n          const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n          const cts = tls.connect(Object.assign({\n            host: remoteHost,\n            servername: remoteHost,\n            socket: socket\n          }, connectionOptions), () => {\n            trace('Successfully established a TLS connection to ' + options.path + ' through proxy ' + proxyAddressString);\n            resolve({\n              socket: cts,\n              realTarget: parsedTarget\n            });\n          });\n          cts.on('error', error => {\n            trace('Failed to establish a TLS connection to ' + options.path + ' through proxy ' + proxyAddressString + ' with error ' + error.message);\n            reject();\n          });\n        } else {\n          trace('Successfully established a plaintext connection to ' + options.path + ' through proxy ' + proxyAddressString);\n          resolve({\n            socket,\n            realTarget: parsedTarget\n          });\n        }\n      } else {\n        logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' + options.path + ' through proxy ' + proxyAddressString + ' with status ' + res.statusCode);\n        reject();\n      }\n    });\n    request.once('error', err => {\n      request.removeAllListeners();\n      logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' + proxyAddressString + ' with error ' + err.message);\n      reject();\n    });\n    request.end();\n  });\n}\nexports.getProxiedConnection = getProxiedConnection;","map":{"version":3,"names":["Object","defineProperty","exports","value","getProxiedConnection","mapProxyName","logging_1","require","constants_1","resolver_1","http","tls","logging","subchannel_address_1","uri_parser_1","url_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","getProxyInfo","proxyEnv","envVar","process","env","grpc_proxy","https_proxy","http_proxy","proxyUrl","URL","e","log","ERROR","protocol","userCred","username","password","INFO","hostname","port","result","address","creds","getNoProxyHostList","noProxyStr","no_grpc_proxy","no_proxy","split","target","options","_a","noProxyResult","extraOptions","scheme","proxyInfo","hostPort","splitHostPort","path","serverHost","host","uriToString","channelOptions","connectionOptions","Promise","resolve","realTarget","parsedTarget","parseUri","method","headers","Host","isTcpSubchannelAddress","socketPath","Buffer","from","toString","proxyAddressString","subchannelAddressToString","reject","request","once","res","socket","head","removeAllListeners","statusCode","targetPath","getDefaultAuthority","remoteHost","cts","connect","assign","servername","on","error","message","err","end"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/http_proxy.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getProxiedConnection = exports.mapProxyName = void 0;\nconst logging_1 = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst resolver_1 = require(\"./resolver\");\nconst http = require(\"http\");\nconst tls = require(\"tls\");\nconst logging = require(\"./logging\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst url_1 = require(\"url\");\nconst TRACER_NAME = 'proxy';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n    let proxyEnv = '';\n    let envVar = '';\n    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n     * fallback behavior can be removed if there's a demand for it.\n     */\n    if (process.env.grpc_proxy) {\n        envVar = 'grpc_proxy';\n        proxyEnv = process.env.grpc_proxy;\n    }\n    else if (process.env.https_proxy) {\n        envVar = 'https_proxy';\n        proxyEnv = process.env.https_proxy;\n    }\n    else if (process.env.http_proxy) {\n        envVar = 'http_proxy';\n        proxyEnv = process.env.http_proxy;\n    }\n    else {\n        return {};\n    }\n    let proxyUrl;\n    try {\n        proxyUrl = new url_1.URL(proxyEnv);\n    }\n    catch (e) {\n        logging_1.log(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n        return {};\n    }\n    if (proxyUrl.protocol !== 'http:') {\n        logging_1.log(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n        return {};\n    }\n    let userCred = null;\n    if (proxyUrl.username) {\n        if (proxyUrl.password) {\n            logging_1.log(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\n            userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n        }\n        else {\n            userCred = proxyUrl.username;\n        }\n    }\n    const hostname = proxyUrl.hostname;\n    let port = proxyUrl.port;\n    /* The proxy URL uses the scheme \"http:\", which has a default port number of\n     * 80. We need to set that explicitly here if it is omitted because otherwise\n     * it will use gRPC's default port 443. */\n    if (port === '') {\n        port = '80';\n    }\n    const result = {\n        address: `${hostname}:${port}`,\n    };\n    if (userCred) {\n        result.creds = userCred;\n    }\n    trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\n    return result;\n}\nfunction getNoProxyHostList() {\n    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n    let noProxyStr = process.env.no_grpc_proxy;\n    let envVar = 'no_grpc_proxy';\n    if (!noProxyStr) {\n        noProxyStr = process.env.no_proxy;\n        envVar = 'no_proxy';\n    }\n    if (noProxyStr) {\n        trace('No proxy server list set by environment variable ' + envVar);\n        return noProxyStr.split(',');\n    }\n    else {\n        return [];\n    }\n}\nfunction mapProxyName(target, options) {\n    var _a;\n    const noProxyResult = {\n        target: target,\n        extraOptions: {},\n    };\n    if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {\n        return noProxyResult;\n    }\n    if (target.scheme === 'unix') {\n        return noProxyResult;\n    }\n    const proxyInfo = getProxyInfo();\n    if (!proxyInfo.address) {\n        return noProxyResult;\n    }\n    const hostPort = uri_parser_1.splitHostPort(target.path);\n    if (!hostPort) {\n        return noProxyResult;\n    }\n    const serverHost = hostPort.host;\n    for (const host of getNoProxyHostList()) {\n        if (host === serverHost) {\n            trace('Not using proxy for target in no_proxy list: ' + uri_parser_1.uriToString(target));\n            return noProxyResult;\n        }\n    }\n    const extraOptions = {\n        'grpc.http_connect_target': uri_parser_1.uriToString(target),\n    };\n    if (proxyInfo.creds) {\n        extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n    }\n    return {\n        target: {\n            scheme: 'dns',\n            path: proxyInfo.address,\n        },\n        extraOptions: extraOptions,\n    };\n}\nexports.mapProxyName = mapProxyName;\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\n    if (!('grpc.http_connect_target' in channelOptions)) {\n        return Promise.resolve({});\n    }\n    const realTarget = channelOptions['grpc.http_connect_target'];\n    const parsedTarget = uri_parser_1.parseUri(realTarget);\n    if (parsedTarget === null) {\n        return Promise.resolve({});\n    }\n    const options = {\n        method: 'CONNECT',\n        path: parsedTarget.path,\n    };\n    const headers = {\n        Host: parsedTarget.path,\n    };\n    // Connect to the subchannel address as a proxy\n    if (subchannel_address_1.isTcpSubchannelAddress(address)) {\n        options.host = address.host;\n        options.port = address.port;\n    }\n    else {\n        options.socketPath = address.path;\n    }\n    if ('grpc.http_connect_creds' in channelOptions) {\n        headers['Proxy-Authorization'] =\n            'Basic ' +\n                Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');\n    }\n    options.headers = headers;\n    const proxyAddressString = subchannel_address_1.subchannelAddressToString(address);\n    trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n    return new Promise((resolve, reject) => {\n        const request = http.request(options);\n        request.once('connect', (res, socket, head) => {\n            var _a;\n            request.removeAllListeners();\n            socket.removeAllListeners();\n            if (res.statusCode === 200) {\n                trace('Successfully connected to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString);\n                if ('secureContext' in connectionOptions) {\n                    /* The proxy is connecting to a TLS server, so upgrade this socket\n                     * connection to a TLS connection.\n                     * This is a workaround for https://github.com/nodejs/node/issues/32922\n                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n                    const targetPath = resolver_1.getDefaultAuthority(parsedTarget);\n                    const hostPort = uri_parser_1.splitHostPort(targetPath);\n                    const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n                    const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket: socket }, connectionOptions), () => {\n                        trace('Successfully established a TLS connection to ' +\n                            options.path +\n                            ' through proxy ' +\n                            proxyAddressString);\n                        resolve({ socket: cts, realTarget: parsedTarget });\n                    });\n                    cts.on('error', (error) => {\n                        trace('Failed to establish a TLS connection to ' +\n                            options.path +\n                            ' through proxy ' +\n                            proxyAddressString +\n                            ' with error ' +\n                            error.message);\n                        reject();\n                    });\n                }\n                else {\n                    trace('Successfully established a plaintext connection to ' +\n                        options.path +\n                        ' through proxy ' +\n                        proxyAddressString);\n                    resolve({\n                        socket,\n                        realTarget: parsedTarget,\n                    });\n                }\n            }\n            else {\n                logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString +\n                    ' with status ' +\n                    res.statusCode);\n                reject();\n            }\n        });\n        request.once('error', (err) => {\n            request.removeAllListeners();\n            logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' +\n                proxyAddressString +\n                ' with error ' +\n                err.message);\n            reject();\n        });\n        request.end();\n    });\n}\nexports.getProxiedConnection = getProxiedConnection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}