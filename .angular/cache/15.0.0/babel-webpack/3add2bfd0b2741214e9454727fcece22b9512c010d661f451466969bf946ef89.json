{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag, ValueType } from '@opentelemetry/api';\nimport { AttributeHashMap } from './state/HashMap';\nimport { isObservableInstrument } from './Instruments';\n/**\n * The class implements {@link ObservableResult} interface.\n */\nvar ObservableResultImpl = /** @class */function () {\n  function ObservableResultImpl(_descriptor) {\n    this._descriptor = _descriptor;\n    /**\n     * @internal\n     */\n    this._buffer = new AttributeHashMap();\n  }\n  /**\n   * Observe a measurement of the value associated with the given attributes.\n   */\n  ObservableResultImpl.prototype.observe = function (value, attributes) {\n    if (attributes === void 0) {\n      attributes = {};\n    }\n    if (this._descriptor.valueType === ValueType.INT && !Number.isInteger(value)) {\n      diag.warn(\"INT value type cannot accept a floating-point value for \" + this._descriptor.name + \", ignoring the fractional digits.\");\n      value = Math.trunc(value);\n    }\n    this._buffer.set(attributes, value);\n  };\n  return ObservableResultImpl;\n}();\nexport { ObservableResultImpl };\n/**\n * The class implements {@link BatchObservableCallback} interface.\n */\nvar BatchObservableResultImpl = /** @class */function () {\n  function BatchObservableResultImpl() {\n    /**\n     * @internal\n     */\n    this._buffer = new Map();\n  }\n  /**\n   * Observe a measurement of the value associated with the given attributes.\n   */\n  BatchObservableResultImpl.prototype.observe = function (metric, value, attributes) {\n    if (attributes === void 0) {\n      attributes = {};\n    }\n    if (!isObservableInstrument(metric)) {\n      return;\n    }\n    var map = this._buffer.get(metric);\n    if (map == null) {\n      map = new AttributeHashMap();\n      this._buffer.set(metric, map);\n    }\n    if (metric._descriptor.valueType === ValueType.INT && !Number.isInteger(value)) {\n      diag.warn(\"INT value type cannot accept a floating-point value for \" + metric._descriptor.name + \", ignoring the fractional digits.\");\n      value = Math.trunc(value);\n    }\n    map.set(attributes, value);\n  };\n  return BatchObservableResultImpl;\n}();\nexport { BatchObservableResultImpl };","map":{"version":3,"names":["diag","ValueType","AttributeHashMap","isObservableInstrument","ObservableResultImpl","_descriptor","_buffer","prototype","observe","value","attributes","valueType","INT","Number","isInteger","warn","name","Math","trunc","set","BatchObservableResultImpl","Map","metric","map","get"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@opentelemetry/sdk-metrics/build/esm/ObservableResult.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag, ValueType, } from '@opentelemetry/api';\nimport { AttributeHashMap } from './state/HashMap';\nimport { isObservableInstrument } from './Instruments';\n/**\n * The class implements {@link ObservableResult} interface.\n */\nvar ObservableResultImpl = /** @class */ (function () {\n    function ObservableResultImpl(_descriptor) {\n        this._descriptor = _descriptor;\n        /**\n         * @internal\n         */\n        this._buffer = new AttributeHashMap();\n    }\n    /**\n     * Observe a measurement of the value associated with the given attributes.\n     */\n    ObservableResultImpl.prototype.observe = function (value, attributes) {\n        if (attributes === void 0) { attributes = {}; }\n        if (this._descriptor.valueType === ValueType.INT && !Number.isInteger(value)) {\n            diag.warn(\"INT value type cannot accept a floating-point value for \" + this._descriptor.name + \", ignoring the fractional digits.\");\n            value = Math.trunc(value);\n        }\n        this._buffer.set(attributes, value);\n    };\n    return ObservableResultImpl;\n}());\nexport { ObservableResultImpl };\n/**\n * The class implements {@link BatchObservableCallback} interface.\n */\nvar BatchObservableResultImpl = /** @class */ (function () {\n    function BatchObservableResultImpl() {\n        /**\n         * @internal\n         */\n        this._buffer = new Map();\n    }\n    /**\n     * Observe a measurement of the value associated with the given attributes.\n     */\n    BatchObservableResultImpl.prototype.observe = function (metric, value, attributes) {\n        if (attributes === void 0) { attributes = {}; }\n        if (!isObservableInstrument(metric)) {\n            return;\n        }\n        var map = this._buffer.get(metric);\n        if (map == null) {\n            map = new AttributeHashMap();\n            this._buffer.set(metric, map);\n        }\n        if (metric._descriptor.valueType === ValueType.INT && !Number.isInteger(value)) {\n            diag.warn(\"INT value type cannot accept a floating-point value for \" + metric._descriptor.name + \", ignoring the fractional digits.\");\n            value = Math.trunc(value);\n        }\n        map.set(attributes, value);\n    };\n    return BatchObservableResultImpl;\n}());\nexport { BatchObservableResultImpl };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,IAAI,EAAEC,SAAS,QAAS,oBAAoB;AACrD,SAASC,gBAAgB,QAAQ,iBAAiB;AAClD,SAASC,sBAAsB,QAAQ,eAAe;AACtD;AACA;AACA;AACA,IAAIC,oBAAoB,GAAG,aAAe,YAAY;EAClD,SAASA,oBAAoB,CAACC,WAAW,EAAE;IACvC,IAAI,CAACA,WAAW,GAAGA,WAAW;IAC9B;AACR;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,IAAIJ,gBAAgB,EAAE;EACzC;EACA;AACJ;AACA;EACIE,oBAAoB,CAACG,SAAS,CAACC,OAAO,GAAG,UAAUC,KAAK,EAAEC,UAAU,EAAE;IAClE,IAAIA,UAAU,KAAK,KAAK,CAAC,EAAE;MAAEA,UAAU,GAAG,CAAC,CAAC;IAAE;IAC9C,IAAI,IAAI,CAACL,WAAW,CAACM,SAAS,KAAKV,SAAS,CAACW,GAAG,IAAI,CAACC,MAAM,CAACC,SAAS,CAACL,KAAK,CAAC,EAAE;MAC1ET,IAAI,CAACe,IAAI,CAAC,0DAA0D,GAAG,IAAI,CAACV,WAAW,CAACW,IAAI,GAAG,mCAAmC,CAAC;MACnIP,KAAK,GAAGQ,IAAI,CAACC,KAAK,CAACT,KAAK,CAAC;IAC7B;IACA,IAAI,CAACH,OAAO,CAACa,GAAG,CAACT,UAAU,EAAED,KAAK,CAAC;EACvC,CAAC;EACD,OAAOL,oBAAoB;AAC/B,CAAC,EAAG;AACJ,SAASA,oBAAoB;AAC7B;AACA;AACA;AACA,IAAIgB,yBAAyB,GAAG,aAAe,YAAY;EACvD,SAASA,yBAAyB,GAAG;IACjC;AACR;AACA;IACQ,IAAI,CAACd,OAAO,GAAG,IAAIe,GAAG,EAAE;EAC5B;EACA;AACJ;AACA;EACID,yBAAyB,CAACb,SAAS,CAACC,OAAO,GAAG,UAAUc,MAAM,EAAEb,KAAK,EAAEC,UAAU,EAAE;IAC/E,IAAIA,UAAU,KAAK,KAAK,CAAC,EAAE;MAAEA,UAAU,GAAG,CAAC,CAAC;IAAE;IAC9C,IAAI,CAACP,sBAAsB,CAACmB,MAAM,CAAC,EAAE;MACjC;IACJ;IACA,IAAIC,GAAG,GAAG,IAAI,CAACjB,OAAO,CAACkB,GAAG,CAACF,MAAM,CAAC;IAClC,IAAIC,GAAG,IAAI,IAAI,EAAE;MACbA,GAAG,GAAG,IAAIrB,gBAAgB,EAAE;MAC5B,IAAI,CAACI,OAAO,CAACa,GAAG,CAACG,MAAM,EAAEC,GAAG,CAAC;IACjC;IACA,IAAID,MAAM,CAACjB,WAAW,CAACM,SAAS,KAAKV,SAAS,CAACW,GAAG,IAAI,CAACC,MAAM,CAACC,SAAS,CAACL,KAAK,CAAC,EAAE;MAC5ET,IAAI,CAACe,IAAI,CAAC,0DAA0D,GAAGO,MAAM,CAACjB,WAAW,CAACW,IAAI,GAAG,mCAAmC,CAAC;MACrIP,KAAK,GAAGQ,IAAI,CAACC,KAAK,CAACT,KAAK,CAAC;IAC7B;IACAc,GAAG,CAACJ,GAAG,CAACT,UAAU,EAAED,KAAK,CAAC;EAC9B,CAAC;EACD,OAAOW,yBAAyB;AACpC,CAAC,EAAG;AACJ,SAASA,yBAAyB"},"metadata":{},"sourceType":"module","externalDependencies":[]}