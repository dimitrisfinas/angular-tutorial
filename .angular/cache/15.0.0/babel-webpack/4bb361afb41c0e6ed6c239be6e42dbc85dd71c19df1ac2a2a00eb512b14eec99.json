{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.RoundRobinLoadBalancer = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst picker_1 = require(\"./picker\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst TRACER_NAME = 'round_robin';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'round_robin';\nclass RoundRobinLoadBalancingConfig {\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n  constructor() {}\n  toJsonObject() {\n    return {\n      [TYPE_NAME]: {}\n    };\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj) {\n    return new RoundRobinLoadBalancingConfig();\n  }\n}\nclass RoundRobinPicker {\n  constructor(subchannelList, nextIndex = 0) {\n    this.subchannelList = subchannelList;\n    this.nextIndex = nextIndex;\n  }\n  pick(pickArgs) {\n    const pickedSubchannel = this.subchannelList[this.nextIndex];\n    this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n    return {\n      pickResultType: picker_1.PickResultType.COMPLETE,\n      subchannel: pickedSubchannel,\n      status: null,\n      extraFilterFactories: [],\n      onCallStarted: null\n    };\n  }\n  /**\n   * Check what the next subchannel returned would be. Used by the load\n   * balancer implementation to preserve this part of the picker state if\n   * possible when a subchannel connects or disconnects.\n   */\n  peekNextSubchannel() {\n    return this.subchannelList[this.nextIndex];\n  }\n}\nclass RoundRobinLoadBalancer {\n  constructor(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n    this.subchannels = [];\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    this.currentReadyPicker = null;\n    this.subchannelStateCounts = {\n      [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n      [connectivity_state_1.ConnectivityState.IDLE]: 0,\n      [connectivity_state_1.ConnectivityState.READY]: 0,\n      [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n      [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n    this.subchannelStateListener = (subchannel, previousState, newState) => {\n      this.subchannelStateCounts[previousState] -= 1;\n      this.subchannelStateCounts[newState] += 1;\n      this.calculateAndUpdateState();\n      if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE || newState === connectivity_state_1.ConnectivityState.IDLE) {\n        this.channelControlHelper.requestReresolution();\n        subchannel.startConnecting();\n      }\n    };\n  }\n  calculateAndUpdateState() {\n    if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.READY] > 0) {\n      const readySubchannels = this.subchannels.filter(subchannel => subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\n      let index = 0;\n      if (this.currentReadyPicker !== null) {\n        index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\n        if (index < 0) {\n          index = 0;\n        }\n      }\n      this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\n    } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n      this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n    } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n      this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n    } else {\n      this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    }\n  }\n  updateState(newState, picker) {\n    trace(connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    if (newState === connectivity_state_1.ConnectivityState.READY) {\n      this.currentReadyPicker = picker;\n    } else {\n      this.currentReadyPicker = null;\n    }\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n  resetSubchannelList() {\n    for (const subchannel of this.subchannels) {\n      subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n    }\n    this.subchannelStateCounts = {\n      [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n      [connectivity_state_1.ConnectivityState.IDLE]: 0,\n      [connectivity_state_1.ConnectivityState.READY]: 0,\n      [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n      [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n    this.subchannels = [];\n  }\n  updateAddressList(addressList, lbConfig) {\n    this.resetSubchannelList();\n    trace('Connect to address list ' + addressList.map(address => subchannel_address_1.subchannelAddressToString(address)));\n    this.subchannels = addressList.map(address => this.channelControlHelper.createSubchannel(address, {}));\n    for (const subchannel of this.subchannels) {\n      subchannel.ref();\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n      const subchannelState = subchannel.getConnectivityState();\n      this.subchannelStateCounts[subchannelState] += 1;\n      if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        subchannel.startConnecting();\n      }\n    }\n    this.calculateAndUpdateState();\n  }\n  exitIdle() {\n    for (const subchannel of this.subchannels) {\n      subchannel.startConnecting();\n    }\n  }\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n  destroy() {\n    this.resetSubchannelList();\n  }\n  getTypeName() {\n    return TYPE_NAME;\n  }\n}\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\nfunction setup() {\n  load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\n}\nexports.setup = setup;","map":{"version":3,"names":["Object","defineProperty","exports","value","setup","RoundRobinLoadBalancer","load_balancer_1","require","connectivity_state_1","picker_1","subchannel_address_1","logging","constants_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","TYPE_NAME","RoundRobinLoadBalancingConfig","getLoadBalancerName","constructor","toJsonObject","createFromJson","obj","RoundRobinPicker","subchannelList","nextIndex","pick","pickArgs","pickedSubchannel","length","pickResultType","PickResultType","COMPLETE","subchannel","status","extraFilterFactories","onCallStarted","peekNextSubchannel","channelControlHelper","subchannels","currentState","ConnectivityState","IDLE","currentReadyPicker","subchannelStateCounts","CONNECTING","READY","SHUTDOWN","TRANSIENT_FAILURE","subchannelStateListener","previousState","newState","calculateAndUpdateState","requestReresolution","startConnecting","readySubchannels","filter","getConnectivityState","index","indexOf","updateState","QueuePicker","UnavailablePicker","picker","resetSubchannelList","removeConnectivityStateListener","unref","removeChannelzChild","getChannelzRef","updateAddressList","addressList","lbConfig","map","address","subchannelAddressToString","createSubchannel","ref","addConnectivityStateListener","addChannelzChild","subchannelState","exitIdle","resetBackoff","destroy","getTypeName","registerLoadBalancerType"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setup = exports.RoundRobinLoadBalancer = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst picker_1 = require(\"./picker\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst TRACER_NAME = 'round_robin';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'round_robin';\nclass RoundRobinLoadBalancingConfig {\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    constructor() { }\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {},\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        return new RoundRobinLoadBalancingConfig();\n    }\n}\nclass RoundRobinPicker {\n    constructor(subchannelList, nextIndex = 0) {\n        this.subchannelList = subchannelList;\n        this.nextIndex = nextIndex;\n    }\n    pick(pickArgs) {\n        const pickedSubchannel = this.subchannelList[this.nextIndex];\n        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: pickedSubchannel,\n            status: null,\n            extraFilterFactories: [],\n            onCallStarted: null,\n        };\n    }\n    /**\n     * Check what the next subchannel returned would be. Used by the load\n     * balancer implementation to preserve this part of the picker state if\n     * possible when a subchannel connects or disconnects.\n     */\n    peekNextSubchannel() {\n        return this.subchannelList[this.nextIndex];\n    }\n}\nclass RoundRobinLoadBalancer {\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        this.subchannels = [];\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentReadyPicker = null;\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0,\n        };\n        this.subchannelStateListener = (subchannel, previousState, newState) => {\n            this.subchannelStateCounts[previousState] -= 1;\n            this.subchannelStateCounts[newState] += 1;\n            this.calculateAndUpdateState();\n            if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE ||\n                newState === connectivity_state_1.ConnectivityState.IDLE) {\n                this.channelControlHelper.requestReresolution();\n                subchannel.startConnecting();\n            }\n        };\n    }\n    calculateAndUpdateState() {\n        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.READY] > 0) {\n            const readySubchannels = this.subchannels.filter((subchannel) => subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\n            let index = 0;\n            if (this.currentReadyPicker !== null) {\n                index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\n                if (index < 0) {\n                    index = 0;\n                }\n            }\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\n        }\n        else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n        else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n        }\n        else {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        }\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\n            this.currentReadyPicker = picker;\n        }\n        else {\n            this.currentReadyPicker = null;\n        }\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList() {\n        for (const subchannel of this.subchannels) {\n            subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        }\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0,\n        };\n        this.subchannels = [];\n    }\n    updateAddressList(addressList, lbConfig) {\n        this.resetSubchannelList();\n        trace('Connect to address list ' +\n            addressList.map((address) => subchannel_address_1.subchannelAddressToString(address)));\n        this.subchannels = addressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));\n        for (const subchannel of this.subchannels) {\n            subchannel.ref();\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n            const subchannelState = subchannel.getConnectivityState();\n            this.subchannelStateCounts[subchannelState] += 1;\n            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||\n                subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                subchannel.startConnecting();\n            }\n        }\n        this.calculateAndUpdateState();\n    }\n    exitIdle() {\n        for (const subchannel of this.subchannels) {\n            subchannel.startConnecting();\n        }\n    }\n    resetBackoff() {\n        /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */\n    }\n    destroy() {\n        this.resetSubchannelList();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\nfunction setup() {\n    load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\n}\nexports.setup = setup;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}