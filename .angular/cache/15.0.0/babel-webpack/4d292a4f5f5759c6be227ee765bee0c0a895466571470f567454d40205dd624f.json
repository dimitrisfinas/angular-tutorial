{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { isWrapped, InstrumentationBase } from '@opentelemetry/instrumentation';\nimport * as api from '@opentelemetry/api';\nimport { hrTime } from '@opentelemetry/core';\nimport { getElementXPath } from '@opentelemetry/sdk-trace-web';\nimport { AttributeNames } from './enums/AttributeNames';\nimport { VERSION } from './version';\nvar ZONE_CONTEXT_KEY = 'OT_ZONE_CONTEXT';\nvar EVENT_NAVIGATION_NAME = 'Navigation:';\nvar DEFAULT_EVENT_NAMES = ['click'];\nfunction defaultShouldPreventSpanCreation() {\n  return false;\n}\n/**\n * This class represents a UserInteraction plugin for auto instrumentation.\n * If zone.js is available then it patches the zone otherwise it patches\n * addEventListener of HTMLElement\n */\nvar UserInteractionInstrumentation = /** @class */function (_super) {\n  __extends(UserInteractionInstrumentation, _super);\n  function UserInteractionInstrumentation(config) {\n    var _a;\n    var _this = _super.call(this, '@opentelemetry/instrumentation-user-interaction', VERSION, config) || this;\n    _this.component = 'user-interaction';\n    _this.version = VERSION;\n    _this.moduleName = _this.component;\n    _this._spansData = new WeakMap();\n    // for addEventListener/removeEventListener state\n    _this._wrappedListeners = new WeakMap();\n    // for event bubbling\n    _this._eventsSpanMap = new WeakMap();\n    _this._eventNames = new Set((_a = config === null || config === void 0 ? void 0 : config.eventNames) !== null && _a !== void 0 ? _a : DEFAULT_EVENT_NAMES);\n    _this._shouldPreventSpanCreation = typeof (config === null || config === void 0 ? void 0 : config.shouldPreventSpanCreation) === 'function' ? config.shouldPreventSpanCreation : defaultShouldPreventSpanCreation;\n    return _this;\n  }\n  UserInteractionInstrumentation.prototype.init = function () {};\n  /**\n   * This will check if last task was timeout and will save the time to\n   * fix the user interaction when nothing happens\n   * This timeout comes from xhr plugin which is needed to collect information\n   * about last xhr main request from observer\n   * @param task\n   * @param span\n   */\n  UserInteractionInstrumentation.prototype._checkForTimeout = function (task, span) {\n    var spanData = this._spansData.get(span);\n    if (spanData) {\n      if (task.source === 'setTimeout') {\n        spanData.hrTimeLastTimeout = hrTime();\n      } else if (task.source !== 'Promise.then' && task.source !== 'setTimeout') {\n        spanData.hrTimeLastTimeout = undefined;\n      }\n    }\n  };\n  /**\n   * Controls whether or not to create a span, based on the event type.\n   */\n  UserInteractionInstrumentation.prototype._allowEventName = function (eventName) {\n    return this._eventNames.has(eventName);\n  };\n  /**\n   * Creates a new span\n   * @param element\n   * @param eventName\n   */\n  UserInteractionInstrumentation.prototype._createSpan = function (element, eventName, parentSpan) {\n    var _a;\n    if (!(element instanceof HTMLElement)) {\n      return undefined;\n    }\n    if (!element.getAttribute) {\n      return undefined;\n    }\n    if (element.hasAttribute('disabled')) {\n      return undefined;\n    }\n    if (!this._allowEventName(eventName)) {\n      return undefined;\n    }\n    var xpath = getElementXPath(element, true);\n    try {\n      var span = this.tracer.startSpan(eventName, {\n        attributes: (_a = {}, _a[AttributeNames.COMPONENT] = this.component, _a[AttributeNames.EVENT_TYPE] = eventName, _a[AttributeNames.TARGET_ELEMENT] = element.tagName, _a[AttributeNames.TARGET_XPATH] = xpath, _a[AttributeNames.HTTP_URL] = window.location.href, _a[AttributeNames.HTTP_USER_AGENT] = navigator.userAgent, _a)\n      }, parentSpan ? api.trace.setSpan(api.context.active(), parentSpan) : undefined);\n      if (this._shouldPreventSpanCreation(eventName, element, span) === true) {\n        return undefined;\n      }\n      this._spansData.set(span, {\n        taskCount: 0\n      });\n      return span;\n    } catch (e) {\n      api.diag.error(this.component, e);\n    }\n    return undefined;\n  };\n  /**\n   * Decrement number of tasks that left in zone,\n   * This is needed to be able to end span when no more tasks left\n   * @param span\n   */\n  UserInteractionInstrumentation.prototype._decrementTask = function (span) {\n    var spanData = this._spansData.get(span);\n    if (spanData) {\n      spanData.taskCount--;\n      if (spanData.taskCount === 0) {\n        this._tryToEndSpan(span, spanData.hrTimeLastTimeout);\n      }\n    }\n  };\n  /**\n   * Return the current span\n   * @param zone\n   * @private\n   */\n  UserInteractionInstrumentation.prototype._getCurrentSpan = function (zone) {\n    var context = zone.get(ZONE_CONTEXT_KEY);\n    if (context) {\n      return api.trace.getSpan(context);\n    }\n    return context;\n  };\n  /**\n   * Increment number of tasks that are run within the same zone.\n   *     This is needed to be able to end span when no more tasks left\n   * @param span\n   */\n  UserInteractionInstrumentation.prototype._incrementTask = function (span) {\n    var spanData = this._spansData.get(span);\n    if (spanData) {\n      spanData.taskCount++;\n    }\n  };\n  /**\n   * Returns true iff we should use the patched callback; false if it's already been patched\n   */\n  UserInteractionInstrumentation.prototype.addPatchedListener = function (on, type, listener, wrappedListener) {\n    var listener2Type = this._wrappedListeners.get(listener);\n    if (!listener2Type) {\n      listener2Type = new Map();\n      this._wrappedListeners.set(listener, listener2Type);\n    }\n    var element2patched = listener2Type.get(type);\n    if (!element2patched) {\n      element2patched = new Map();\n      listener2Type.set(type, element2patched);\n    }\n    if (element2patched.has(on)) {\n      return false;\n    }\n    element2patched.set(on, wrappedListener);\n    return true;\n  };\n  /**\n   * Returns the patched version of the callback (or undefined)\n   */\n  UserInteractionInstrumentation.prototype.removePatchedListener = function (on, type, listener) {\n    var listener2Type = this._wrappedListeners.get(listener);\n    if (!listener2Type) {\n      return undefined;\n    }\n    var element2patched = listener2Type.get(type);\n    if (!element2patched) {\n      return undefined;\n    }\n    var patched = element2patched.get(on);\n    if (patched) {\n      element2patched.delete(on);\n      if (element2patched.size === 0) {\n        listener2Type.delete(type);\n        if (listener2Type.size === 0) {\n          this._wrappedListeners.delete(listener);\n        }\n      }\n    }\n    return patched;\n  };\n  // utility method to deal with the Function|EventListener nature of addEventListener\n  UserInteractionInstrumentation.prototype._invokeListener = function (listener, target, args) {\n    if (typeof listener === 'function') {\n      return listener.apply(target, args);\n    } else {\n      return listener.handleEvent(args[0]);\n    }\n  };\n  /**\n   * This patches the addEventListener of HTMLElement to be able to\n   * auto instrument the click events\n   * This is done when zone is not available\n   */\n  UserInteractionInstrumentation.prototype._patchAddEventListener = function () {\n    var plugin = this;\n    return function (original) {\n      return function addEventListenerPatched(type, listener, useCapture) {\n        // Forward calls with listener = null\n        if (!listener) {\n          return original.call(this, type, listener, useCapture);\n        }\n        // filter out null (typeof null === 'object')\n        var once = useCapture && typeof useCapture === 'object' && useCapture.once;\n        var patchedListener = function () {\n          var _this = this;\n          var args = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n          var parentSpan;\n          var event = args[0];\n          var target = event === null || event === void 0 ? void 0 : event.target;\n          if (event) {\n            parentSpan = plugin._eventsSpanMap.get(event);\n          }\n          if (once) {\n            plugin.removePatchedListener(this, type, listener);\n          }\n          var span = plugin._createSpan(target, type, parentSpan);\n          if (span) {\n            if (event) {\n              plugin._eventsSpanMap.set(event, span);\n            }\n            return api.context.with(api.trace.setSpan(api.context.active(), span), function () {\n              var result = plugin._invokeListener(listener, _this, args);\n              // no zone so end span immediately\n              span.end();\n              return result;\n            });\n          } else {\n            return plugin._invokeListener(listener, this, args);\n          }\n        };\n        if (plugin.addPatchedListener(this, type, listener, patchedListener)) {\n          return original.call(this, type, patchedListener, useCapture);\n        }\n      };\n    };\n  };\n  /**\n   * This patches the removeEventListener of HTMLElement to handle the fact that\n   * we patched the original callbacks\n   * This is done when zone is not available\n   */\n  UserInteractionInstrumentation.prototype._patchRemoveEventListener = function () {\n    var plugin = this;\n    return function (original) {\n      return function removeEventListenerPatched(type, listener, useCapture) {\n        var wrappedListener = plugin.removePatchedListener(this, type, listener);\n        if (wrappedListener) {\n          return original.call(this, type, wrappedListener, useCapture);\n        } else {\n          return original.call(this, type, listener, useCapture);\n        }\n      };\n    };\n  };\n  /**\n   * Most browser provide event listener api via EventTarget in prototype chain.\n   * Exception to this is IE 11 which has it on the prototypes closest to EventTarget:\n   *\n   * * - has addEventListener in IE\n   * ** - has addEventListener in all other browsers\n   * ! - missing in IE\n   *\n   * HTMLElement -> Element -> Node * -> EventTarget **! -> Object\n   * Document -> Node * -> EventTarget **! -> Object\n   * Window * -> WindowProperties ! -> EventTarget **! -> Object\n   */\n  UserInteractionInstrumentation.prototype._getPatchableEventTargets = function () {\n    return window.EventTarget ? [EventTarget.prototype] : [Node.prototype, Window.prototype];\n  };\n  /**\n   * Patches the history api\n   */\n  UserInteractionInstrumentation.prototype._patchHistoryApi = function () {\n    this._unpatchHistoryApi();\n    this._wrap(history, 'replaceState', this._patchHistoryMethod());\n    this._wrap(history, 'pushState', this._patchHistoryMethod());\n    this._wrap(history, 'back', this._patchHistoryMethod());\n    this._wrap(history, 'forward', this._patchHistoryMethod());\n    this._wrap(history, 'go', this._patchHistoryMethod());\n  };\n  /**\n   * Patches the certain history api method\n   */\n  UserInteractionInstrumentation.prototype._patchHistoryMethod = function () {\n    var plugin = this;\n    return function (original) {\n      return function patchHistoryMethod() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var url = \"\" + location.pathname + location.hash + location.search;\n        var result = original.apply(this, args);\n        var urlAfter = \"\" + location.pathname + location.hash + location.search;\n        if (url !== urlAfter) {\n          plugin._updateInteractionName(urlAfter);\n        }\n        return result;\n      };\n    };\n  };\n  /**\n   * unpatch the history api methods\n   */\n  UserInteractionInstrumentation.prototype._unpatchHistoryApi = function () {\n    if (isWrapped(history.replaceState)) this._unwrap(history, 'replaceState');\n    if (isWrapped(history.pushState)) this._unwrap(history, 'pushState');\n    if (isWrapped(history.back)) this._unwrap(history, 'back');\n    if (isWrapped(history.forward)) this._unwrap(history, 'forward');\n    if (isWrapped(history.go)) this._unwrap(history, 'go');\n  };\n  /**\n   * Updates interaction span name\n   * @param url\n   */\n  UserInteractionInstrumentation.prototype._updateInteractionName = function (url) {\n    var span = api.trace.getSpan(api.context.active());\n    if (span && typeof span.updateName === 'function') {\n      span.updateName(EVENT_NAVIGATION_NAME + \" \" + url);\n    }\n  };\n  /**\n   * Patches zone cancel task - this is done to be able to correctly\n   * decrement the number of remaining tasks\n   */\n  UserInteractionInstrumentation.prototype._patchZoneCancelTask = function () {\n    var plugin = this;\n    return function (original) {\n      return function patchCancelTask(task) {\n        var currentZone = Zone.current;\n        var currentSpan = plugin._getCurrentSpan(currentZone);\n        if (currentSpan && plugin._shouldCountTask(task, currentZone)) {\n          plugin._decrementTask(currentSpan);\n        }\n        return original.call(this, task);\n      };\n    };\n  };\n  /**\n   * Patches zone schedule task - this is done to be able to correctly\n   * increment the number of tasks running within current zone but also to\n   * save time in case of timeout running from xhr plugin when waiting for\n   * main request from PerformanceResourceTiming\n   */\n  UserInteractionInstrumentation.prototype._patchZoneScheduleTask = function () {\n    var plugin = this;\n    return function (original) {\n      return function patchScheduleTask(task) {\n        var currentZone = Zone.current;\n        var currentSpan = plugin._getCurrentSpan(currentZone);\n        if (currentSpan && plugin._shouldCountTask(task, currentZone)) {\n          plugin._incrementTask(currentSpan);\n          plugin._checkForTimeout(task, currentSpan);\n        }\n        return original.call(this, task);\n      };\n    };\n  };\n  /**\n   * Patches zone run task - this is done to be able to create a span when\n   * user interaction starts\n   * @private\n   */\n  UserInteractionInstrumentation.prototype._patchZoneRunTask = function () {\n    var plugin = this;\n    return function (original) {\n      return function patchRunTask(task, applyThis, applyArgs) {\n        var event = Array.isArray(applyArgs) && applyArgs[0] instanceof Event ? applyArgs[0] : undefined;\n        var target = event === null || event === void 0 ? void 0 : event.target;\n        var span;\n        var activeZone = this;\n        if (target) {\n          span = plugin._createSpan(target, task.eventName);\n          if (span) {\n            plugin._incrementTask(span);\n            return activeZone.run(function () {\n              try {\n                return api.context.with(api.trace.setSpan(api.context.active(), span), function () {\n                  var currentZone = Zone.current;\n                  task._zone = currentZone;\n                  return original.call(currentZone, task, applyThis, applyArgs);\n                });\n              } finally {\n                plugin._decrementTask(span);\n              }\n            });\n          }\n        } else {\n          span = plugin._getCurrentSpan(activeZone);\n        }\n        try {\n          return original.call(activeZone, task, applyThis, applyArgs);\n        } finally {\n          if (span && plugin._shouldCountTask(task, activeZone)) {\n            plugin._decrementTask(span);\n          }\n        }\n      };\n    };\n  };\n  /**\n   * Decides if task should be counted.\n   * @param task\n   * @param currentZone\n   * @private\n   */\n  UserInteractionInstrumentation.prototype._shouldCountTask = function (task, currentZone) {\n    if (task._zone) {\n      currentZone = task._zone;\n    }\n    if (!currentZone || !task.data || task.data.isPeriodic) {\n      return false;\n    }\n    var currentSpan = this._getCurrentSpan(currentZone);\n    if (!currentSpan) {\n      return false;\n    }\n    if (!this._spansData.get(currentSpan)) {\n      return false;\n    }\n    return task.type === 'macroTask' || task.type === 'microTask';\n  };\n  /**\n   * Will try to end span when such span still exists.\n   * @param span\n   * @param endTime\n   * @private\n   */\n  UserInteractionInstrumentation.prototype._tryToEndSpan = function (span, endTime) {\n    if (span) {\n      var spanData = this._spansData.get(span);\n      if (spanData) {\n        span.end(endTime);\n        this._spansData.delete(span);\n      }\n    }\n  };\n  /**\n   * implements enable function\n   */\n  UserInteractionInstrumentation.prototype.enable = function () {\n    var _this = this;\n    var ZoneWithPrototype = this.getZoneWithPrototype();\n    api.diag.debug('applying patch to', this.moduleName, this.version, 'zone:', !!ZoneWithPrototype);\n    if (ZoneWithPrototype) {\n      if (isWrapped(ZoneWithPrototype.prototype.runTask)) {\n        this._unwrap(ZoneWithPrototype.prototype, 'runTask');\n        api.diag.debug('removing previous patch from method runTask');\n      }\n      if (isWrapped(ZoneWithPrototype.prototype.scheduleTask)) {\n        this._unwrap(ZoneWithPrototype.prototype, 'scheduleTask');\n        api.diag.debug('removing previous patch from method scheduleTask');\n      }\n      if (isWrapped(ZoneWithPrototype.prototype.cancelTask)) {\n        this._unwrap(ZoneWithPrototype.prototype, 'cancelTask');\n        api.diag.debug('removing previous patch from method cancelTask');\n      }\n      this._zonePatched = true;\n      this._wrap(ZoneWithPrototype.prototype, 'runTask', this._patchZoneRunTask());\n      this._wrap(ZoneWithPrototype.prototype, 'scheduleTask', this._patchZoneScheduleTask());\n      this._wrap(ZoneWithPrototype.prototype, 'cancelTask', this._patchZoneCancelTask());\n    } else {\n      this._zonePatched = false;\n      var targets = this._getPatchableEventTargets();\n      targets.forEach(function (target) {\n        if (isWrapped(target.addEventListener)) {\n          _this._unwrap(target, 'addEventListener');\n          api.diag.debug('removing previous patch from method addEventListener');\n        }\n        if (isWrapped(target.removeEventListener)) {\n          _this._unwrap(target, 'removeEventListener');\n          api.diag.debug('removing previous patch from method removeEventListener');\n        }\n        _this._wrap(target, 'addEventListener', _this._patchAddEventListener());\n        _this._wrap(target, 'removeEventListener', _this._patchRemoveEventListener());\n      });\n    }\n    this._patchHistoryApi();\n  };\n  /**\n   * implements unpatch function\n   */\n  UserInteractionInstrumentation.prototype.disable = function () {\n    var _this = this;\n    var ZoneWithPrototype = this.getZoneWithPrototype();\n    api.diag.debug('removing patch from', this.moduleName, this.version, 'zone:', !!ZoneWithPrototype);\n    if (ZoneWithPrototype && this._zonePatched) {\n      if (isWrapped(ZoneWithPrototype.prototype.runTask)) {\n        this._unwrap(ZoneWithPrototype.prototype, 'runTask');\n      }\n      if (isWrapped(ZoneWithPrototype.prototype.scheduleTask)) {\n        this._unwrap(ZoneWithPrototype.prototype, 'scheduleTask');\n      }\n      if (isWrapped(ZoneWithPrototype.prototype.cancelTask)) {\n        this._unwrap(ZoneWithPrototype.prototype, 'cancelTask');\n      }\n    } else {\n      var targets = this._getPatchableEventTargets();\n      targets.forEach(function (target) {\n        if (isWrapped(target.addEventListener)) {\n          _this._unwrap(target, 'addEventListener');\n        }\n        if (isWrapped(target.removeEventListener)) {\n          _this._unwrap(target, 'removeEventListener');\n        }\n      });\n    }\n    this._unpatchHistoryApi();\n  };\n  /**\n   * returns Zone\n   */\n  UserInteractionInstrumentation.prototype.getZoneWithPrototype = function () {\n    var _window = window;\n    return _window.Zone;\n  };\n  return UserInteractionInstrumentation;\n}(InstrumentationBase);\nexport { UserInteractionInstrumentation };\n//# sourceMappingURL=instrumentation.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}