{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _asyncToGenerator = require(\"/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\nconst zlib = require(\"zlib\");\nconst compression_algorithms_1 = require(\"./compression-algorithms\");\nconst constants_1 = require(\"./constants\");\nconst filter_1 = require(\"./filter\");\nconst logging = require(\"./logging\");\nconst isCompressionAlgorithmKey = key => {\n  return typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string';\n};\nclass CompressionHandler {\n  /**\n   * @param message Raw uncompressed message bytes\n   * @param compress Indicates whether the message should be compressed\n   * @return Framed message, compressed if applicable\n   */\n  writeMessage(message, compress) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      let messageBuffer = message;\n      if (compress) {\n        messageBuffer = yield _this.compressMessage(messageBuffer);\n      }\n      const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n      output.writeUInt8(compress ? 1 : 0, 0);\n      output.writeUInt32BE(messageBuffer.length, 1);\n      messageBuffer.copy(output, 5);\n      return output;\n    })();\n  }\n  /**\n   * @param data Framed message, possibly compressed\n   * @return Uncompressed message\n   */\n  readMessage(data) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const compressed = data.readUInt8(0) === 1;\n      let messageBuffer = data.slice(5);\n      if (compressed) {\n        messageBuffer = yield _this2.decompressMessage(messageBuffer);\n      }\n      return messageBuffer;\n    })();\n  }\n}\nclass IdentityHandler extends CompressionHandler {\n  compressMessage(message) {\n    return _asyncToGenerator(function* () {\n      return message;\n    })();\n  }\n  writeMessage(message, compress) {\n    return _asyncToGenerator(function* () {\n      const output = Buffer.allocUnsafe(message.length + 5);\n      /* With \"identity\" compression, messages should always be marked as\n       * uncompressed */\n      output.writeUInt8(0, 0);\n      output.writeUInt32BE(message.length, 1);\n      message.copy(output, 5);\n      return output;\n    })();\n  }\n  decompressMessage(message) {\n    return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n  }\n}\nclass DeflateHandler extends CompressionHandler {\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.deflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.inflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n}\nclass GzipHandler extends CompressionHandler {\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.gzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.unzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n}\nclass UnknownHandler extends CompressionHandler {\n  constructor(compressionName) {\n    super();\n    this.compressionName = compressionName;\n  }\n  compressMessage(message) {\n    return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n  }\n  decompressMessage(message) {\n    // This should be unreachable\n    return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n  }\n}\nfunction getCompressionHandler(compressionName) {\n  switch (compressionName) {\n    case 'identity':\n      return new IdentityHandler();\n    case 'deflate':\n      return new DeflateHandler();\n    case 'gzip':\n      return new GzipHandler();\n    default:\n      return new UnknownHandler(compressionName);\n  }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n  constructor(channelOptions, sharedFilterConfig) {\n    var _a;\n    super();\n    this.sharedFilterConfig = sharedFilterConfig;\n    this.sendCompression = new IdentityHandler();\n    this.receiveCompression = new IdentityHandler();\n    this.currentCompressionAlgorithm = 'identity';\n    const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];\n    if (compressionAlgorithmKey !== undefined) {\n      if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n        const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\n        const serverSupportedEncodings = (_a = sharedFilterConfig.serverSupportedEncodingHeader) === null || _a === void 0 ? void 0 : _a.split(',');\n        /**\n         * There are two possible situations here:\n         * 1) We don't have any info yet from the server about what compression it supports\n         *    In that case we should just use what the client tells us to use\n         * 2) We've previously received a response from the server including a grpc-accept-encoding header\n         *    In that case we only want to use the encoding chosen by the client if the server supports it\n         */\n        if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {\n          this.currentCompressionAlgorithm = clientSelectedEncoding;\n          this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm);\n        }\n      } else {\n        logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\n      }\n    }\n  }\n  sendMetadata(metadata) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const headers = yield metadata;\n      headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n      headers.set('accept-encoding', 'identity');\n      // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n      if (_this3.currentCompressionAlgorithm === 'identity') {\n        headers.remove('grpc-encoding');\n      } else {\n        headers.set('grpc-encoding', _this3.currentCompressionAlgorithm);\n      }\n      return headers;\n    })();\n  }\n  receiveMetadata(metadata) {\n    const receiveEncoding = metadata.get('grpc-encoding');\n    if (receiveEncoding.length > 0) {\n      const encoding = receiveEncoding[0];\n      if (typeof encoding === 'string') {\n        this.receiveCompression = getCompressionHandler(encoding);\n      }\n    }\n    metadata.remove('grpc-encoding');\n    /* Check to see if the compression we're using to send messages is supported by the server\n     * If not, reset the sendCompression filter and have it use the default IdentityHandler */\n    const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];\n    if (serverSupportedEncodingsHeader) {\n      this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;\n      const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');\n      if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\n        this.sendCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = 'identity';\n      }\n    }\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n  sendMessage(message) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      /* This filter is special. The input message is the bare message bytes,\n       * and the output is a framed and possibly compressed message. For this\n       * reason, this filter should be at the bottom of the filter stack */\n      const resolvedMessage = yield message;\n      let compress;\n      if (_this4.sendCompression instanceof IdentityHandler) {\n        compress = false;\n      } else {\n        compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* NoCompress */) === 0;\n      }\n      return {\n        message: yield _this4.sendCompression.writeMessage(resolvedMessage.message, compress),\n        flags: resolvedMessage.flags\n      };\n    })();\n  }\n  receiveMessage(message) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      /* This filter is also special. The input message is framed and possibly\n       * compressed, and the output message is deframed and uncompressed. So\n       * this is another reason that this filter should be at the bottom of the\n       * filter stack. */\n      return _this5.receiveCompression.readMessage(yield message);\n    })();\n  }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n  constructor(channel, options) {\n    this.channel = channel;\n    this.options = options;\n    this.sharedFilterConfig = {};\n  }\n  createFilter(callStream) {\n    return new CompressionFilter(this.options, this.sharedFilterConfig);\n  }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory;","map":{"version":3,"names":["Object","defineProperty","exports","value","CompressionFilterFactory","CompressionFilter","zlib","require","compression_algorithms_1","constants_1","filter_1","logging","isCompressionAlgorithmKey","key","CompressionAlgorithms","CompressionHandler","writeMessage","message","compress","messageBuffer","compressMessage","output","Buffer","allocUnsafe","length","writeUInt8","writeUInt32BE","copy","readMessage","data","compressed","readUInt8","slice","decompressMessage","IdentityHandler","Promise","reject","Error","DeflateHandler","resolve","deflate","err","inflate","GzipHandler","gzip","unzip","UnknownHandler","constructor","compressionName","getCompressionHandler","BaseFilter","channelOptions","sharedFilterConfig","_a","sendCompression","receiveCompression","currentCompressionAlgorithm","compressionAlgorithmKey","undefined","clientSelectedEncoding","serverSupportedEncodings","serverSupportedEncodingHeader","split","includes","log","LogVerbosity","ERROR","sendMetadata","metadata","headers","set","remove","receiveMetadata","receiveEncoding","get","encoding","serverSupportedEncodingsHeader","sendMessage","resolvedMessage","flags","receiveMessage","channel","options","createFilter","callStream"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/compression-filter.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\nconst zlib = require(\"zlib\");\nconst compression_algorithms_1 = require(\"./compression-algorithms\");\nconst constants_1 = require(\"./constants\");\nconst filter_1 = require(\"./filter\");\nconst logging = require(\"./logging\");\nconst isCompressionAlgorithmKey = (key) => {\n    return typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string';\n};\nclass CompressionHandler {\n    /**\n     * @param message Raw uncompressed message bytes\n     * @param compress Indicates whether the message should be compressed\n     * @return Framed message, compressed if applicable\n     */\n    async writeMessage(message, compress) {\n        let messageBuffer = message;\n        if (compress) {\n            messageBuffer = await this.compressMessage(messageBuffer);\n        }\n        const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n        output.writeUInt8(compress ? 1 : 0, 0);\n        output.writeUInt32BE(messageBuffer.length, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    /**\n     * @param data Framed message, possibly compressed\n     * @return Uncompressed message\n     */\n    async readMessage(data) {\n        const compressed = data.readUInt8(0) === 1;\n        let messageBuffer = data.slice(5);\n        if (compressed) {\n            messageBuffer = await this.decompressMessage(messageBuffer);\n        }\n        return messageBuffer;\n    }\n}\nclass IdentityHandler extends CompressionHandler {\n    async compressMessage(message) {\n        return message;\n    }\n    async writeMessage(message, compress) {\n        const output = Buffer.allocUnsafe(message.length + 5);\n        /* With \"identity\" compression, messages should always be marked as\n         * uncompressed */\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(message.length, 1);\n        message.copy(output, 5);\n        return output;\n    }\n    decompressMessage(message) {\n        return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n    }\n}\nclass DeflateHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.deflate(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.inflate(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass GzipHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.gzip(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.unzip(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass UnknownHandler extends CompressionHandler {\n    constructor(compressionName) {\n        super();\n        this.compressionName = compressionName;\n    }\n    compressMessage(message) {\n        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n    }\n    decompressMessage(message) {\n        // This should be unreachable\n        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n    }\n}\nfunction getCompressionHandler(compressionName) {\n    switch (compressionName) {\n        case 'identity':\n            return new IdentityHandler();\n        case 'deflate':\n            return new DeflateHandler();\n        case 'gzip':\n            return new GzipHandler();\n        default:\n            return new UnknownHandler(compressionName);\n    }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n    constructor(channelOptions, sharedFilterConfig) {\n        var _a;\n        super();\n        this.sharedFilterConfig = sharedFilterConfig;\n        this.sendCompression = new IdentityHandler();\n        this.receiveCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = 'identity';\n        const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];\n        if (compressionAlgorithmKey !== undefined) {\n            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\n                const serverSupportedEncodings = (_a = sharedFilterConfig.serverSupportedEncodingHeader) === null || _a === void 0 ? void 0 : _a.split(',');\n                /**\n                 * There are two possible situations here:\n                 * 1) We don't have any info yet from the server about what compression it supports\n                 *    In that case we should just use what the client tells us to use\n                 * 2) We've previously received a response from the server including a grpc-accept-encoding header\n                 *    In that case we only want to use the encoding chosen by the client if the server supports it\n                 */\n                if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {\n                    this.currentCompressionAlgorithm = clientSelectedEncoding;\n                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm);\n                }\n            }\n            else {\n                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\n            }\n        }\n    }\n    async sendMetadata(metadata) {\n        const headers = await metadata;\n        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n        headers.set('accept-encoding', 'identity');\n        // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n        if (this.currentCompressionAlgorithm === 'identity') {\n            headers.remove('grpc-encoding');\n        }\n        else {\n            headers.set('grpc-encoding', this.currentCompressionAlgorithm);\n        }\n        return headers;\n    }\n    receiveMetadata(metadata) {\n        const receiveEncoding = metadata.get('grpc-encoding');\n        if (receiveEncoding.length > 0) {\n            const encoding = receiveEncoding[0];\n            if (typeof encoding === 'string') {\n                this.receiveCompression = getCompressionHandler(encoding);\n            }\n        }\n        metadata.remove('grpc-encoding');\n        /* Check to see if the compression we're using to send messages is supported by the server\n         * If not, reset the sendCompression filter and have it use the default IdentityHandler */\n        const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];\n        if (serverSupportedEncodingsHeader) {\n            this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;\n            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');\n            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\n                this.sendCompression = new IdentityHandler();\n                this.currentCompressionAlgorithm = 'identity';\n            }\n        }\n        metadata.remove('grpc-accept-encoding');\n        return metadata;\n    }\n    async sendMessage(message) {\n        var _a;\n        /* This filter is special. The input message is the bare message bytes,\n         * and the output is a framed and possibly compressed message. For this\n         * reason, this filter should be at the bottom of the filter stack */\n        const resolvedMessage = await message;\n        let compress;\n        if (this.sendCompression instanceof IdentityHandler) {\n            compress = false;\n        }\n        else {\n            compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* NoCompress */) === 0;\n        }\n        return {\n            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n            flags: resolvedMessage.flags,\n        };\n    }\n    async receiveMessage(message) {\n        /* This filter is also special. The input message is framed and possibly\n         * compressed, and the output message is deframed and uncompressed. So\n         * this is another reason that this filter should be at the bottom of the\n         * filter stack. */\n        return this.receiveCompression.readMessage(await message);\n    }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n    constructor(channel, options) {\n        this.channel = channel;\n        this.options = options;\n        this.sharedFilterConfig = {};\n    }\n    createFilter(callStream) {\n        return new CompressionFilter(this.options, this.sharedFilterConfig);\n    }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}