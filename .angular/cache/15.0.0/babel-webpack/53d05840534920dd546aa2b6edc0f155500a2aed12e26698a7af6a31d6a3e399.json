{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport * as api from '@opentelemetry/api';\nimport { isWrapped, InstrumentationBase, safeExecuteInTheMiddle } from '@opentelemetry/instrumentation';\nimport * as core from '@opentelemetry/core';\nimport * as web from '@opentelemetry/sdk-trace-web';\nimport { AttributeNames } from './enums/AttributeNames';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { VERSION } from './version';\nimport { _globalThis } from '@opentelemetry/core';\n// how long to wait for observer to collect information about resources\n// this is needed as event \"load\" is called before observer\n// hard to say how long it should really wait, seems like 300ms is\n// safe enough\nvar OBSERVER_WAIT_TIME_MS = 300;\n/**\n * This class represents a fetch plugin for auto instrumentation\n */\nvar FetchInstrumentation = /** @class */function (_super) {\n  __extends(FetchInstrumentation, _super);\n  function FetchInstrumentation(config) {\n    var _this = _super.call(this, '@opentelemetry/instrumentation-fetch', VERSION, config) || this;\n    _this.component = 'fetch';\n    _this.version = VERSION;\n    _this.moduleName = _this.component;\n    _this._usedResources = new WeakSet();\n    _this._tasksCount = 0;\n    return _this;\n  }\n  FetchInstrumentation.prototype.init = function () {};\n  FetchInstrumentation.prototype._getConfig = function () {\n    return this._config;\n  };\n  /**\n   * Add cors pre flight child span\n   * @param span\n   * @param corsPreFlightRequest\n   */\n  FetchInstrumentation.prototype._addChildSpan = function (span, corsPreFlightRequest) {\n    var childSpan = this.tracer.startSpan('CORS Preflight', {\n      startTime: corsPreFlightRequest[web.PerformanceTimingNames.FETCH_START]\n    }, api.trace.setSpan(api.context.active(), span));\n    if (!this._getConfig().ignoreNetworkEvents) {\n      web.addSpanNetworkEvents(childSpan, corsPreFlightRequest);\n    }\n    childSpan.end(corsPreFlightRequest[web.PerformanceTimingNames.RESPONSE_END]);\n  };\n  /**\n   * Adds more attributes to span just before ending it\n   * @param span\n   * @param response\n   */\n  FetchInstrumentation.prototype._addFinalSpanAttributes = function (span, response) {\n    var parsedUrl = web.parseUrl(response.url);\n    span.setAttribute(SemanticAttributes.HTTP_STATUS_CODE, response.status);\n    if (response.statusText != null) {\n      span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, response.statusText);\n    }\n    span.setAttribute(SemanticAttributes.HTTP_HOST, parsedUrl.host);\n    span.setAttribute(SemanticAttributes.HTTP_SCHEME, parsedUrl.protocol.replace(':', ''));\n    span.setAttribute(SemanticAttributes.HTTP_USER_AGENT, navigator.userAgent);\n  };\n  /**\n   * Add headers\n   * @param options\n   * @param spanUrl\n   */\n  FetchInstrumentation.prototype._addHeaders = function (options, spanUrl) {\n    if (!web.shouldPropagateTraceHeaders(spanUrl, this._getConfig().propagateTraceHeaderCorsUrls)) {\n      var headers = {};\n      api.propagation.inject(api.context.active(), headers);\n      if (Object.keys(headers).length > 0) {\n        this._diag.debug('headers inject skipped due to CORS policy');\n      }\n      return;\n    }\n    if (options instanceof Request) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: function (h, k, v) {\n          return h.set(k, typeof v === 'string' ? v : String(v));\n        }\n      });\n    } else if (options.headers instanceof Headers) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: function (h, k, v) {\n          return h.set(k, typeof v === 'string' ? v : String(v));\n        }\n      });\n    } else {\n      var headers = {};\n      api.propagation.inject(api.context.active(), headers);\n      options.headers = Object.assign({}, headers, options.headers || {});\n    }\n  };\n  /**\n   * Clears the resource timings and all resources assigned with spans\n   *     when {@link FetchPluginConfig.clearTimingResources} is\n   *     set to true (default false)\n   * @private\n   */\n  FetchInstrumentation.prototype._clearResources = function () {\n    if (this._tasksCount === 0 && this._getConfig().clearTimingResources) {\n      performance.clearResourceTimings();\n      this._usedResources = new WeakSet();\n    }\n  };\n  /**\n   * Creates a new span\n   * @param url\n   * @param options\n   */\n  FetchInstrumentation.prototype._createSpan = function (url, options) {\n    var _a;\n    if (options === void 0) {\n      options = {};\n    }\n    if (core.isUrlIgnored(url, this._getConfig().ignoreUrls)) {\n      this._diag.debug('ignoring span as url matches ignored url');\n      return;\n    }\n    var method = (options.method || 'GET').toUpperCase();\n    var spanName = \"HTTP \" + method;\n    return this.tracer.startSpan(spanName, {\n      kind: api.SpanKind.CLIENT,\n      attributes: (_a = {}, _a[AttributeNames.COMPONENT] = this.moduleName, _a[SemanticAttributes.HTTP_METHOD] = method, _a[SemanticAttributes.HTTP_URL] = url, _a)\n    });\n  };\n  /**\n   * Finds appropriate resource and add network events to the span\n   * @param span\n   * @param resourcesObserver\n   * @param endTime\n   */\n  FetchInstrumentation.prototype._findResourceAndAddNetworkEvents = function (span, resourcesObserver, endTime) {\n    var resources = resourcesObserver.entries;\n    if (!resources.length) {\n      if (!performance.getEntriesByType) {\n        return;\n      }\n      // fallback - either Observer is not available or it took longer\n      // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough\n      // information\n      resources = performance.getEntriesByType('resource');\n    }\n    var resource = web.getResource(resourcesObserver.spanUrl, resourcesObserver.startTime, endTime, resources, this._usedResources, 'fetch');\n    if (resource.mainRequest) {\n      var mainRequest = resource.mainRequest;\n      this._markResourceAsUsed(mainRequest);\n      var corsPreFlightRequest = resource.corsPreFlightRequest;\n      if (corsPreFlightRequest) {\n        this._addChildSpan(span, corsPreFlightRequest);\n        this._markResourceAsUsed(corsPreFlightRequest);\n      }\n      if (!this._getConfig().ignoreNetworkEvents) {\n        web.addSpanNetworkEvents(span, mainRequest);\n      }\n    }\n  };\n  /**\n   * Marks certain [resource]{@link PerformanceResourceTiming} when information\n   * from this is used to add events to span.\n   * This is done to avoid reusing the same resource again for next span\n   * @param resource\n   */\n  FetchInstrumentation.prototype._markResourceAsUsed = function (resource) {\n    this._usedResources.add(resource);\n  };\n  /**\n   * Finish span, add attributes, network events etc.\n   * @param span\n   * @param spanData\n   * @param response\n   */\n  FetchInstrumentation.prototype._endSpan = function (span, spanData, response) {\n    var _this = this;\n    var endTime = core.hrTime();\n    this._addFinalSpanAttributes(span, response);\n    setTimeout(function () {\n      var _a;\n      (_a = spanData.observer) === null || _a === void 0 ? void 0 : _a.disconnect();\n      _this._findResourceAndAddNetworkEvents(span, spanData, endTime);\n      _this._tasksCount--;\n      _this._clearResources();\n      span.end(endTime);\n    }, OBSERVER_WAIT_TIME_MS);\n  };\n  /**\n   * Patches the constructor of fetch\n   */\n  FetchInstrumentation.prototype._patchConstructor = function () {\n    var _this = this;\n    return function (original) {\n      var plugin = _this;\n      return function patchConstructor() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var self = this;\n        var url = web.parseUrl(args[0] instanceof Request ? args[0].url : args[0]).href;\n        var options = args[0] instanceof Request ? args[0] : args[1] || {};\n        var createdSpan = plugin._createSpan(url, options);\n        if (!createdSpan) {\n          return original.apply(this, args);\n        }\n        var spanData = plugin._prepareSpanData(url);\n        function endSpanOnError(span, error) {\n          plugin._applyAttributesAfterFetch(span, options, error);\n          plugin._endSpan(span, spanData, {\n            status: error.status || 0,\n            statusText: error.message,\n            url: url\n          });\n        }\n        function endSpanOnSuccess(span, response) {\n          plugin._applyAttributesAfterFetch(span, options, response);\n          if (response.status >= 200 && response.status < 400) {\n            plugin._endSpan(span, spanData, response);\n          } else {\n            plugin._endSpan(span, spanData, {\n              status: response.status,\n              statusText: response.statusText,\n              url: url\n            });\n          }\n        }\n        function onSuccess(span, resolve, response) {\n          try {\n            var resClone = response.clone();\n            var resClone4Hook_1 = response.clone();\n            var body = resClone.body;\n            if (body) {\n              var reader_1 = body.getReader();\n              var read_1 = function () {\n                reader_1.read().then(function (_a) {\n                  var done = _a.done;\n                  if (done) {\n                    endSpanOnSuccess(span, resClone4Hook_1);\n                  } else {\n                    read_1();\n                  }\n                }, function (error) {\n                  endSpanOnError(span, error);\n                });\n              };\n              read_1();\n            } else {\n              // some older browsers don't have .body implemented\n              endSpanOnSuccess(span, response);\n            }\n          } finally {\n            resolve(response);\n          }\n        }\n        function onError(span, reject, error) {\n          try {\n            endSpanOnError(span, error);\n          } finally {\n            reject(error);\n          }\n        }\n        return new Promise(function (resolve, reject) {\n          return api.context.with(api.trace.setSpan(api.context.active(), createdSpan), function () {\n            plugin._addHeaders(options, url);\n            plugin._tasksCount++;\n            // TypeScript complains about arrow function captured a this typed as globalThis\n            // ts(7041)\n            return original.apply(self, options instanceof Request ? [options] : [url, options]).then(onSuccess.bind(self, createdSpan, resolve), onError.bind(self, createdSpan, reject));\n          });\n        });\n      };\n    };\n  };\n  FetchInstrumentation.prototype._applyAttributesAfterFetch = function (span, request, result) {\n    var _this = this;\n    var applyCustomAttributesOnSpan = this._getConfig().applyCustomAttributesOnSpan;\n    if (applyCustomAttributesOnSpan) {\n      safeExecuteInTheMiddle(function () {\n        return applyCustomAttributesOnSpan(span, request, result);\n      }, function (error) {\n        if (!error) {\n          return;\n        }\n        _this._diag.error('applyCustomAttributesOnSpan', error);\n      }, true);\n    }\n  };\n  /**\n   * Prepares a span data - needed later for matching appropriate network\n   *     resources\n   * @param spanUrl\n   */\n  FetchInstrumentation.prototype._prepareSpanData = function (spanUrl) {\n    var startTime = core.hrTime();\n    var entries = [];\n    if (typeof PerformanceObserver !== 'function') {\n      return {\n        entries: entries,\n        startTime: startTime,\n        spanUrl: spanUrl\n      };\n    }\n    var observer = new PerformanceObserver(function (list) {\n      var perfObsEntries = list.getEntries();\n      perfObsEntries.forEach(function (entry) {\n        if (entry.initiatorType === 'fetch' && entry.name === spanUrl) {\n          entries.push(entry);\n        }\n      });\n    });\n    observer.observe({\n      entryTypes: ['resource']\n    });\n    return {\n      entries: entries,\n      observer: observer,\n      startTime: startTime,\n      spanUrl: spanUrl\n    };\n  };\n  /**\n   * implements enable function\n   */\n  FetchInstrumentation.prototype.enable = function () {\n    if (isWrapped(fetch)) {\n      this._unwrap(_globalThis, 'fetch');\n      this._diag.debug('removing previous patch for constructor');\n    }\n    this._wrap(_globalThis, 'fetch', this._patchConstructor());\n  };\n  /**\n   * implements unpatch function\n   */\n  FetchInstrumentation.prototype.disable = function () {\n    this._unwrap(_globalThis, 'fetch');\n    this._usedResources = new WeakSet();\n  };\n  return FetchInstrumentation;\n}(InstrumentationBase);\nexport { FetchInstrumentation };\n//# sourceMappingURL=fetch.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}