{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Server = void 0;\nconst http2 = require(\"http2\");\nconst constants_1 = require(\"./constants\");\nconst server_call_1 = require(\"./server-call\");\nconst server_credentials_1 = require(\"./server-credentials\");\nconst resolver_1 = require(\"./resolver\");\nconst logging = require(\"./logging\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst channelz_1 = require(\"./channelz\");\nconst {\n  HTTP2_HEADER_PATH\n} = http2.constants;\nconst TRACER_NAME = 'server';\nfunction noop() {}\nfunction getUnimplementedStatusResponse(methodName) {\n  return {\n    code: constants_1.Status.UNIMPLEMENTED,\n    details: `The server does not implement the method ${methodName}`\n  };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n  const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n  switch (handlerType) {\n    case 'unary':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n    case 'clientStream':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n    case 'serverStream':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    case 'bidi':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    default:\n      throw new Error(`Invalid handlerType ${handlerType}`);\n  }\n}\nclass Server {\n  constructor(options) {\n    this.http2ServerList = [];\n    this.handlers = new Map();\n    this.sessions = new Map();\n    this.started = false;\n    this.serverAddressString = 'null';\n    // Channelz Info\n    this.channelzEnabled = true;\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n    this.options = options !== null && options !== void 0 ? options : {};\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzRef = channelz_1.registerChannelzServer(() => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Server created');\n    }\n    this.trace('Server constructed');\n  }\n  getChannelzInfo() {\n    return {\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      listenerChildren: this.listenerChildrenTracker.getChildLists(),\n      sessionChildren: this.sessionChildrenTracker.getChildLists()\n    };\n  }\n  getChannelzSessionInfoGetter(session) {\n    return () => {\n      var _a, _b, _c;\n      const sessionInfo = this.sessions.get(session);\n      const sessionSocket = session.socket;\n      const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n      const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n      let tlsInfo;\n      if (session.encrypted) {\n        const tlsSocket = sessionSocket;\n        const cipherInfo = tlsSocket.getCipher();\n        const certificate = tlsSocket.getCertificate();\n        const peerCertificate = tlsSocket.getPeerCertificate();\n        tlsInfo = {\n          cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n          cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n          localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n          remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n        };\n      } else {\n        tlsInfo = null;\n      }\n      const socketInfo = {\n        remoteAddress: remoteAddress,\n        localAddress: localAddress,\n        security: tlsInfo,\n        remoteName: null,\n        streamsStarted: sessionInfo.streamTracker.callsStarted,\n        streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n        streamsFailed: sessionInfo.streamTracker.callsFailed,\n        messagesSent: sessionInfo.messagesSent,\n        messagesReceived: sessionInfo.messagesReceived,\n        keepAlivesSent: 0,\n        lastLocalStreamCreatedTimestamp: null,\n        lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n        lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n        lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n        localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n        remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n      };\n      return socketInfo;\n    };\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);\n  }\n  addProtoService() {\n    throw new Error('Not implemented. Use addService() instead');\n  }\n  addService(service, implementation) {\n    if (service === null || typeof service !== 'object' || implementation === null || typeof implementation !== 'object') {\n      throw new Error('addService() requires two objects as arguments');\n    }\n    const serviceKeys = Object.keys(service);\n    if (serviceKeys.length === 0) {\n      throw new Error('Cannot add an empty service to a server');\n    }\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      let methodType;\n      if (attrs.requestStream) {\n        if (attrs.responseStream) {\n          methodType = 'bidi';\n        } else {\n          methodType = 'clientStream';\n        }\n      } else {\n        if (attrs.responseStream) {\n          methodType = 'serverStream';\n        } else {\n          methodType = 'unary';\n        }\n      }\n      let implFn = implementation[name];\n      let impl;\n      if (implFn === undefined && typeof attrs.originalName === 'string') {\n        implFn = implementation[attrs.originalName];\n      }\n      if (implFn !== undefined) {\n        impl = implFn.bind(implementation);\n      } else {\n        impl = getDefaultHandler(methodType, name);\n      }\n      const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n      if (success === false) {\n        throw new Error(`Method handler for ${attrs.path} already provided.`);\n      }\n    });\n  }\n  removeService(service) {\n    if (service === null || typeof service !== 'object') {\n      throw new Error('removeService() requires object as argument');\n    }\n    const serviceKeys = Object.keys(service);\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      this.unregister(attrs.path);\n    });\n  }\n  bind(port, creds) {\n    throw new Error('Not implemented. Use bindAsync() instead');\n  }\n  bindAsync(port, creds, callback) {\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n    if (typeof port !== 'string') {\n      throw new TypeError('port must be a string');\n    }\n    if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n      throw new TypeError('creds must be a ServerCredentials object');\n    }\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n    const initialPortUri = uri_parser_1.parseUri(port);\n    if (initialPortUri === null) {\n      throw new Error(`Could not parse port \"${port}\"`);\n    }\n    const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);\n    if (portUri === null) {\n      throw new Error(`Could not get a default scheme for port \"${port}\"`);\n    }\n    const serverOptions = {\n      maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n    };\n    if ('grpc-node.max_session_memory' in this.options) {\n      serverOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n    } else {\n      /* By default, set a very large max session memory limit, to effectively\n       * disable enforcement of the limit. Some testing indicates that Node's\n       * behavior degrades badly when this limit is reached, so we solve that\n       * by disabling the check entirely. */\n      serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n    }\n    if ('grpc.max_concurrent_streams' in this.options) {\n      serverOptions.settings = {\n        maxConcurrentStreams: this.options['grpc.max_concurrent_streams']\n      };\n    }\n    const deferredCallback = (error, port) => {\n      process.nextTick(() => callback(error, port));\n    };\n    const setupServer = () => {\n      let http2Server;\n      if (creds._isSecure()) {\n        const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n        http2Server = http2.createSecureServer(secureServerOptions);\n        http2Server.on('secureConnection', socket => {\n          /* These errors need to be handled by the user of Http2SecureServer,\n           * according to https://github.com/nodejs/node/issues/35824 */\n          socket.on('error', e => {\n            this.trace('An incoming TLS connection closed with error: ' + e.message);\n          });\n        });\n      } else {\n        http2Server = http2.createServer(serverOptions);\n      }\n      http2Server.setTimeout(0, noop);\n      this._setupHandlers(http2Server);\n      return http2Server;\n    };\n    const bindSpecificPort = (addressList, portNum, previousCount) => {\n      if (addressList.length === 0) {\n        return Promise.resolve({\n          port: portNum,\n          count: previousCount\n        });\n      }\n      return Promise.all(addressList.map(address => {\n        this.trace('Attempting to bind ' + subchannel_address_1.subchannelAddressToString(address));\n        let addr;\n        if (subchannel_address_1.isTcpSubchannelAddress(address)) {\n          addr = {\n            host: address.host,\n            port: portNum\n          };\n        } else {\n          addr = address;\n        }\n        const http2Server = setupServer();\n        return new Promise((resolve, reject) => {\n          const onError = err => {\n            this.trace('Failed to bind ' + subchannel_address_1.subchannelAddressToString(address) + ' with error ' + err.message);\n            resolve(err);\n          };\n          http2Server.once('error', onError);\n          http2Server.listen(addr, () => {\n            const boundAddress = http2Server.address();\n            let boundSubchannelAddress;\n            if (typeof boundAddress === 'string') {\n              boundSubchannelAddress = {\n                path: boundAddress\n              };\n            } else {\n              boundSubchannelAddress = {\n                host: boundAddress.address,\n                port: boundAddress.port\n              };\n            }\n            let channelzRef;\n            channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), () => {\n              return {\n                localAddress: boundSubchannelAddress,\n                remoteAddress: null,\n                security: null,\n                remoteName: null,\n                streamsStarted: 0,\n                streamsSucceeded: 0,\n                streamsFailed: 0,\n                messagesSent: 0,\n                messagesReceived: 0,\n                keepAlivesSent: 0,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: null,\n                lastMessageSentTimestamp: null,\n                lastMessageReceivedTimestamp: null,\n                localFlowControlWindow: null,\n                remoteFlowControlWindow: null\n              };\n            }, this.channelzEnabled);\n            if (this.channelzEnabled) {\n              this.listenerChildrenTracker.refChild(channelzRef);\n            }\n            this.http2ServerList.push({\n              server: http2Server,\n              channelzRef: channelzRef\n            });\n            this.trace('Successfully bound ' + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));\n            resolve('port' in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);\n            http2Server.removeListener('error', onError);\n          });\n        });\n      })).then(results => {\n        let count = 0;\n        for (const result of results) {\n          if (typeof result === 'number') {\n            count += 1;\n            if (result !== portNum) {\n              throw new Error('Invalid state: multiple port numbers added from single address');\n            }\n          }\n        }\n        return {\n          port: portNum,\n          count: count + previousCount\n        };\n      });\n    };\n    const bindWildcardPort = addressList => {\n      if (addressList.length === 0) {\n        return Promise.resolve({\n          port: 0,\n          count: 0\n        });\n      }\n      const address = addressList[0];\n      const http2Server = setupServer();\n      return new Promise((resolve, reject) => {\n        const onError = err => {\n          this.trace('Failed to bind ' + subchannel_address_1.subchannelAddressToString(address) + ' with error ' + err.message);\n          resolve(bindWildcardPort(addressList.slice(1)));\n        };\n        http2Server.once('error', onError);\n        http2Server.listen(address, () => {\n          const boundAddress = http2Server.address();\n          const boundSubchannelAddress = {\n            host: boundAddress.address,\n            port: boundAddress.port\n          };\n          let channelzRef;\n          channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), () => {\n            return {\n              localAddress: boundSubchannelAddress,\n              remoteAddress: null,\n              security: null,\n              remoteName: null,\n              streamsStarted: 0,\n              streamsSucceeded: 0,\n              streamsFailed: 0,\n              messagesSent: 0,\n              messagesReceived: 0,\n              keepAlivesSent: 0,\n              lastLocalStreamCreatedTimestamp: null,\n              lastRemoteStreamCreatedTimestamp: null,\n              lastMessageSentTimestamp: null,\n              lastMessageReceivedTimestamp: null,\n              localFlowControlWindow: null,\n              remoteFlowControlWindow: null\n            };\n          }, this.channelzEnabled);\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.refChild(channelzRef);\n          }\n          this.http2ServerList.push({\n            server: http2Server,\n            channelzRef: channelzRef\n          });\n          this.trace('Successfully bound ' + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));\n          resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));\n          http2Server.removeListener('error', onError);\n        });\n      });\n    };\n    const resolverListener = {\n      onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {\n        // We only want one resolution result. Discard all future results\n        resolverListener.onSuccessfulResolution = () => {};\n        if (addressList.length === 0) {\n          deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);\n          return;\n        }\n        let bindResultPromise;\n        if (subchannel_address_1.isTcpSubchannelAddress(addressList[0])) {\n          if (addressList[0].port === 0) {\n            bindResultPromise = bindWildcardPort(addressList);\n          } else {\n            bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n          }\n        } else {\n          // Use an arbitrary non-zero port for non-TCP addresses\n          bindResultPromise = bindSpecificPort(addressList, 1, 0);\n        }\n        bindResultPromise.then(bindResult => {\n          if (bindResult.count === 0) {\n            const errorString = `No address added out of total ${addressList.length} resolved`;\n            logging.log(constants_1.LogVerbosity.ERROR, errorString);\n            deferredCallback(new Error(errorString), 0);\n          } else {\n            if (bindResult.count < addressList.length) {\n              logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n            }\n            deferredCallback(null, bindResult.port);\n          }\n        }, error => {\n          const errorString = `No address added out of total ${addressList.length} resolved`;\n          logging.log(constants_1.LogVerbosity.ERROR, errorString);\n          deferredCallback(new Error(errorString), 0);\n        });\n      },\n      onError: error => {\n        deferredCallback(new Error(error.details), 0);\n      }\n    };\n    const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);\n    resolver.updateResolution();\n  }\n  forceShutdown() {\n    // Close the server if it is still running.\n    for (const {\n      server: http2Server,\n      channelzRef: ref\n    } of this.http2ServerList) {\n      if (http2Server.listening) {\n        http2Server.close(() => {\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.unrefChild(ref);\n            channelz_1.unregisterChannelzRef(ref);\n          }\n        });\n      }\n    }\n    this.started = false;\n    // Always destroy any available sessions. It's possible that one or more\n    // tryShutdown() calls are in progress. Don't wait on them to finish.\n    this.sessions.forEach((channelzInfo, session) => {\n      // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n      // recognize destroy(code) as a valid signature.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      session.destroy(http2.constants.NGHTTP2_CANCEL);\n    });\n    this.sessions.clear();\n    if (this.channelzEnabled) {\n      channelz_1.unregisterChannelzRef(this.channelzRef);\n    }\n  }\n  register(name, handler, serialize, deserialize, type) {\n    if (this.handlers.has(name)) {\n      return false;\n    }\n    this.handlers.set(name, {\n      func: handler,\n      serialize,\n      deserialize,\n      type,\n      path: name\n    });\n    return true;\n  }\n  unregister(name) {\n    return this.handlers.delete(name);\n  }\n  start() {\n    if (this.http2ServerList.length === 0 || this.http2ServerList.every(({\n      server: http2Server\n    }) => http2Server.listening !== true)) {\n      throw new Error('server must be bound in order to start');\n    }\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Starting');\n    }\n    this.started = true;\n  }\n  tryShutdown(callback) {\n    const wrappedCallback = error => {\n      if (this.channelzEnabled) {\n        channelz_1.unregisterChannelzRef(this.channelzRef);\n      }\n      callback(error);\n    };\n    let pendingChecks = 0;\n    function maybeCallback() {\n      pendingChecks--;\n      if (pendingChecks === 0) {\n        wrappedCallback();\n      }\n    }\n    // Close the server if necessary.\n    this.started = false;\n    for (const {\n      server: http2Server,\n      channelzRef: ref\n    } of this.http2ServerList) {\n      if (http2Server.listening) {\n        pendingChecks++;\n        http2Server.close(() => {\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.unrefChild(ref);\n            channelz_1.unregisterChannelzRef(ref);\n          }\n          maybeCallback();\n        });\n      }\n    }\n    this.sessions.forEach((channelzInfo, session) => {\n      if (!session.closed) {\n        pendingChecks += 1;\n        session.close(maybeCallback);\n      }\n    });\n    if (pendingChecks === 0) {\n      wrappedCallback();\n    }\n  }\n  addHttp2Port() {\n    throw new Error('Not yet implemented');\n  }\n  /**\n   * Get the channelz reference object for this server. The returned value is\n   * garbage if channelz is disabled for this server.\n   * @returns\n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  _verifyContentType(stream, headers) {\n    const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n    if (typeof contentType !== 'string' || !contentType.startsWith('application/grpc')) {\n      stream.respond({\n        [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n      }, {\n        endStream: true\n      });\n      return false;\n    }\n    return true;\n  }\n  _retrieveHandler(headers) {\n    const path = headers[HTTP2_HEADER_PATH];\n    this.trace('Received call to method ' + path + ' at address ' + this.serverAddressString);\n    const handler = this.handlers.get(path);\n    if (handler === undefined) {\n      this.trace('No handler registered for method ' + path + '. Sending UNIMPLEMENTED status.');\n      throw getUnimplementedStatusResponse(path);\n    }\n    return handler;\n  }\n  _respondWithError(err, stream, channelzSessionInfo = null) {\n    const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n    if (err.code === undefined) {\n      err.code = constants_1.Status.INTERNAL;\n    }\n    if (this.channelzEnabled) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n    }\n    call.sendError(err);\n  }\n  _channelzHandler(stream, headers) {\n    const channelzSessionInfo = this.sessions.get(stream.session);\n    this.callTracker.addCallStarted();\n    channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n    if (!this._verifyContentType(stream, headers)) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n      return;\n    }\n    let handler;\n    try {\n      handler = this._retrieveHandler(headers);\n    } catch (err) {\n      this._respondWithError(err, stream, channelzSessionInfo);\n      return;\n    }\n    const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n    call.once('callEnd', code => {\n      if (code === constants_1.Status.OK) {\n        this.callTracker.addCallSucceeded();\n      } else {\n        this.callTracker.addCallFailed();\n      }\n    });\n    if (channelzSessionInfo) {\n      call.once('streamEnd', success => {\n        if (success) {\n          channelzSessionInfo.streamTracker.addCallSucceeded();\n        } else {\n          channelzSessionInfo.streamTracker.addCallFailed();\n        }\n      });\n      call.on('sendMessage', () => {\n        channelzSessionInfo.messagesSent += 1;\n        channelzSessionInfo.lastMessageSentTimestamp = new Date();\n      });\n      call.on('receiveMessage', () => {\n        channelzSessionInfo.messagesReceived += 1;\n        channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n      });\n    }\n    if (!this._runHandlerForCall(call, handler, headers)) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n      call.sendError({\n        code: constants_1.Status.INTERNAL,\n        details: `Unknown handler type: ${handler.type}`\n      });\n    }\n  }\n  _streamHandler(stream, headers) {\n    if (this._verifyContentType(stream, headers) !== true) {\n      return;\n    }\n    let handler;\n    try {\n      handler = this._retrieveHandler(headers);\n    } catch (err) {\n      this._respondWithError(err, stream, null);\n      return;\n    }\n    const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n    if (!this._runHandlerForCall(call, handler, headers)) {\n      call.sendError({\n        code: constants_1.Status.INTERNAL,\n        details: `Unknown handler type: ${handler.type}`\n      });\n    }\n  }\n  _runHandlerForCall(call, handler, headers) {\n    var _a;\n    const metadata = call.receiveMetadata(headers);\n    const encoding = (_a = metadata.get('grpc-encoding')[0]) !== null && _a !== void 0 ? _a : 'identity';\n    metadata.remove('grpc-encoding');\n    const {\n      type\n    } = handler;\n    if (type === 'unary') {\n      handleUnary(call, handler, metadata, encoding);\n    } else if (type === 'clientStream') {\n      handleClientStreaming(call, handler, metadata, encoding);\n    } else if (type === 'serverStream') {\n      handleServerStreaming(call, handler, metadata, encoding);\n    } else if (type === 'bidi') {\n      handleBidiStreaming(call, handler, metadata, encoding);\n    } else {\n      return false;\n    }\n    return true;\n  }\n  _setupHandlers(http2Server) {\n    if (http2Server === null) {\n      return;\n    }\n    const serverAddress = http2Server.address();\n    let serverAddressString = 'null';\n    if (serverAddress) {\n      if (typeof serverAddress === 'string') {\n        serverAddressString = serverAddress;\n      } else {\n        serverAddressString = serverAddress.address + ':' + serverAddress.port;\n      }\n    }\n    this.serverAddressString = serverAddressString;\n    const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;\n    http2Server.on('stream', handler.bind(this));\n    http2Server.on('session', session => {\n      var _a;\n      if (!this.started) {\n        session.destroy();\n        return;\n      }\n      let channelzRef;\n      channelzRef = channelz_1.registerChannelzSocket((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : 'unknown', this.getChannelzSessionInfoGetter(session), this.channelzEnabled);\n      const channelzSessionInfo = {\n        ref: channelzRef,\n        streamTracker: new channelz_1.ChannelzCallTracker(),\n        messagesSent: 0,\n        messagesReceived: 0,\n        lastMessageSentTimestamp: null,\n        lastMessageReceivedTimestamp: null\n      };\n      this.sessions.set(session, channelzSessionInfo);\n      const clientAddress = session.socket.remoteAddress;\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);\n        this.sessionChildrenTracker.refChild(channelzRef);\n      }\n      session.on('close', () => {\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);\n          this.sessionChildrenTracker.unrefChild(channelzRef);\n          channelz_1.unregisterChannelzRef(channelzRef);\n        }\n        this.sessions.delete(session);\n      });\n    });\n  }\n}\nexports.Server = Server;\nfunction handleUnary(call, handler, metadata, encoding) {\n  call.receiveUnaryMessage(encoding, (err, request) => {\n    if (err) {\n      call.sendError(err);\n      return;\n    }\n    if (request === undefined || call.cancelled) {\n      return;\n    }\n    const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n    handler.func(emitter, (err, value, trailer, flags) => {\n      call.sendUnaryMessage(err, value, trailer, flags);\n    });\n  });\n}\nfunction handleClientStreaming(call, handler, metadata, encoding) {\n  const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize, encoding);\n  function respond(err, value, trailer, flags) {\n    stream.destroy();\n    call.sendUnaryMessage(err, value, trailer, flags);\n  }\n  if (call.cancelled) {\n    return;\n  }\n  stream.on('error', respond);\n  handler.func(stream, respond);\n}\nfunction handleServerStreaming(call, handler, metadata, encoding) {\n  call.receiveUnaryMessage(encoding, (err, request) => {\n    if (err) {\n      call.sendError(err);\n      return;\n    }\n    if (request === undefined || call.cancelled) {\n      return;\n    }\n    const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n    handler.func(stream);\n  });\n}\nfunction handleBidiStreaming(call, handler, metadata, encoding) {\n  const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize, encoding);\n  if (call.cancelled) {\n    return;\n  }\n  handler.func(stream);\n}\n//# sourceMappingURL=server.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}