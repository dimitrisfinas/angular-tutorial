{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTracker = exports.ChannelzChildrenTracker = exports.ChannelzTrace = void 0;\nconst net_1 = require(\"net\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst constants_1 = require(\"./constants\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst admin_1 = require(\"./admin\");\nconst make_client_1 = require(\"./make-client\");\nfunction channelRefToMessage(ref) {\n  return {\n    channel_id: ref.id,\n    name: ref.name\n  };\n}\nfunction subchannelRefToMessage(ref) {\n  return {\n    subchannel_id: ref.id,\n    name: ref.name\n  };\n}\nfunction serverRefToMessage(ref) {\n  return {\n    server_id: ref.id\n  };\n}\nfunction socketRefToMessage(ref) {\n  return {\n    socket_id: ref.id,\n    name: ref.name\n  };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\nconst TARGET_RETAINED_TRACES = 32;\nclass ChannelzTrace {\n  constructor() {\n    this.events = [];\n    this.eventsLogged = 0;\n    this.creationTimestamp = new Date();\n  }\n  addTrace(severity, description, child) {\n    const timestamp = new Date();\n    this.events.push({\n      description: description,\n      severity: severity,\n      timestamp: timestamp,\n      childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,\n      childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined\n    });\n    // Whenever the trace array gets too large, discard the first half\n    if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n      this.events = this.events.slice(TARGET_RETAINED_TRACES);\n    }\n    this.eventsLogged += 1;\n  }\n  getTraceMessage() {\n    return {\n      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n      num_events_logged: this.eventsLogged,\n      events: this.events.map(event => {\n        return {\n          description: event.description,\n          severity: event.severity,\n          timestamp: dateToProtoTimestamp(event.timestamp),\n          channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n          subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n        };\n      })\n    };\n  }\n}\nexports.ChannelzTrace = ChannelzTrace;\nclass ChannelzChildrenTracker {\n  constructor() {\n    this.channelChildren = new Map();\n    this.subchannelChildren = new Map();\n    this.socketChildren = new Map();\n  }\n  refChild(child) {\n    var _a, _b, _c;\n    switch (child.kind) {\n      case 'channel':\n        {\n          let trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : {\n            ref: child,\n            count: 0\n          };\n          trackedChild.count += 1;\n          this.channelChildren.set(child.id, trackedChild);\n          break;\n        }\n      case 'subchannel':\n        {\n          let trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : {\n            ref: child,\n            count: 0\n          };\n          trackedChild.count += 1;\n          this.subchannelChildren.set(child.id, trackedChild);\n          break;\n        }\n      case 'socket':\n        {\n          let trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : {\n            ref: child,\n            count: 0\n          };\n          trackedChild.count += 1;\n          this.socketChildren.set(child.id, trackedChild);\n          break;\n        }\n    }\n  }\n  unrefChild(child) {\n    switch (child.kind) {\n      case 'channel':\n        {\n          let trackedChild = this.channelChildren.get(child.id);\n          if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n            if (trackedChild.count === 0) {\n              this.channelChildren.delete(child.id);\n            } else {\n              this.channelChildren.set(child.id, trackedChild);\n            }\n          }\n          break;\n        }\n      case 'subchannel':\n        {\n          let trackedChild = this.subchannelChildren.get(child.id);\n          if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n            if (trackedChild.count === 0) {\n              this.subchannelChildren.delete(child.id);\n            } else {\n              this.subchannelChildren.set(child.id, trackedChild);\n            }\n          }\n          break;\n        }\n      case 'socket':\n        {\n          let trackedChild = this.socketChildren.get(child.id);\n          if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n            if (trackedChild.count === 0) {\n              this.socketChildren.delete(child.id);\n            } else {\n              this.socketChildren.set(child.id, trackedChild);\n            }\n          }\n          break;\n        }\n    }\n  }\n  getChildLists() {\n    const channels = [];\n    for (const {\n      ref\n    } of this.channelChildren.values()) {\n      channels.push(ref);\n    }\n    const subchannels = [];\n    for (const {\n      ref\n    } of this.subchannelChildren.values()) {\n      subchannels.push(ref);\n    }\n    const sockets = [];\n    for (const {\n      ref\n    } of this.socketChildren.values()) {\n      sockets.push(ref);\n    }\n    return {\n      channels,\n      subchannels,\n      sockets\n    };\n  }\n}\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\nclass ChannelzCallTracker {\n  constructor() {\n    this.callsStarted = 0;\n    this.callsSucceeded = 0;\n    this.callsFailed = 0;\n    this.lastCallStartedTimestamp = null;\n  }\n  addCallStarted() {\n    this.callsStarted += 1;\n    this.lastCallStartedTimestamp = new Date();\n  }\n  addCallSucceeded() {\n    this.callsSucceeded += 1;\n  }\n  addCallFailed() {\n    this.callsFailed += 1;\n  }\n}\nexports.ChannelzCallTracker = ChannelzCallTracker;\nlet nextId = 1;\nfunction getNextId() {\n  return nextId++;\n}\nconst channels = [];\nconst subchannels = [];\nconst servers = [];\nconst sockets = [];\nfunction registerChannelzChannel(name, getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    name,\n    kind: 'channel'\n  };\n  if (channelzEnabled) {\n    channels[id] = {\n      ref,\n      getInfo\n    };\n  }\n  return ref;\n}\nexports.registerChannelzChannel = registerChannelzChannel;\nfunction registerChannelzSubchannel(name, getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    name,\n    kind: 'subchannel'\n  };\n  if (channelzEnabled) {\n    subchannels[id] = {\n      ref,\n      getInfo\n    };\n  }\n  return ref;\n}\nexports.registerChannelzSubchannel = registerChannelzSubchannel;\nfunction registerChannelzServer(getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    kind: 'server'\n  };\n  if (channelzEnabled) {\n    servers[id] = {\n      ref,\n      getInfo\n    };\n  }\n  return ref;\n}\nexports.registerChannelzServer = registerChannelzServer;\nfunction registerChannelzSocket(name, getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    name,\n    kind: 'socket'\n  };\n  if (channelzEnabled) {\n    sockets[id] = {\n      ref,\n      getInfo\n    };\n  }\n  return ref;\n}\nexports.registerChannelzSocket = registerChannelzSocket;\nfunction unregisterChannelzRef(ref) {\n  switch (ref.kind) {\n    case 'channel':\n      delete channels[ref.id];\n      return;\n    case 'subchannel':\n      delete subchannels[ref.id];\n      return;\n    case 'server':\n      delete servers[ref.id];\n      return;\n    case 'socket':\n      delete sockets[ref.id];\n      return;\n  }\n}\nexports.unregisterChannelzRef = unregisterChannelzRef;\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\nfunction parseIPv6Section(addressSection) {\n  const numberValue = Number.parseInt(addressSection, 16);\n  return [numberValue / 256 | 0, numberValue % 256];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\nfunction parseIPv6Chunk(addressChunk) {\n  if (addressChunk === '') {\n    return [];\n  }\n  const bytePairs = addressChunk.split(':').map(section => parseIPv6Section(section));\n  const result = [];\n  return result.concat(...bytePairs);\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */\nfunction ipAddressStringToBuffer(ipAddress) {\n  if (net_1.isIPv4(ipAddress)) {\n    return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\n  } else if (net_1.isIPv6(ipAddress)) {\n    let leftSection;\n    let rightSection;\n    const doubleColonIndex = ipAddress.indexOf('::');\n    if (doubleColonIndex === -1) {\n      leftSection = ipAddress;\n      rightSection = '';\n    } else {\n      leftSection = ipAddress.substring(0, doubleColonIndex);\n      rightSection = ipAddress.substring(doubleColonIndex + 2);\n    }\n    const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n    const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n    const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n    return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n  } else {\n    return null;\n  }\n}\nfunction connectivityStateToMessage(state) {\n  switch (state) {\n    case connectivity_state_1.ConnectivityState.CONNECTING:\n      return {\n        state: 'CONNECTING'\n      };\n    case connectivity_state_1.ConnectivityState.IDLE:\n      return {\n        state: 'IDLE'\n      };\n    case connectivity_state_1.ConnectivityState.READY:\n      return {\n        state: 'READY'\n      };\n    case connectivity_state_1.ConnectivityState.SHUTDOWN:\n      return {\n        state: 'SHUTDOWN'\n      };\n    case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n      return {\n        state: 'TRANSIENT_FAILURE'\n      };\n    default:\n      return {\n        state: 'UNKNOWN'\n      };\n  }\n}\nfunction dateToProtoTimestamp(date) {\n  if (!date) {\n    return null;\n  }\n  const millisSinceEpoch = date.getTime();\n  return {\n    seconds: millisSinceEpoch / 1000 | 0,\n    nanos: millisSinceEpoch % 1000 * 1000000\n  };\n}\nfunction getChannelMessage(channelEntry) {\n  const resolvedInfo = channelEntry.getInfo();\n  return {\n    ref: channelRefToMessage(channelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    channel_ref: resolvedInfo.children.channels.map(ref => channelRefToMessage(ref)),\n    subchannel_ref: resolvedInfo.children.subchannels.map(ref => subchannelRefToMessage(ref))\n  };\n}\nfunction GetChannel(call, callback) {\n  const channelId = Number.parseInt(call.request.channel_id);\n  const channelEntry = channels[channelId];\n  if (channelEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No channel data found for id ' + channelId\n    });\n    return;\n  }\n  callback(null, {\n    channel: getChannelMessage(channelEntry)\n  });\n}\nfunction GetTopChannels(call, callback) {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList = [];\n  let i = Number.parseInt(call.request.start_channel_id);\n  for (; i < channels.length; i++) {\n    const channelEntry = channels[i];\n    if (channelEntry === undefined) {\n      continue;\n    }\n    resultList.push(getChannelMessage(channelEntry));\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n  callback(null, {\n    channel: resultList,\n    end: i >= servers.length\n  });\n}\nfunction getServerMessage(serverEntry) {\n  const resolvedInfo = serverEntry.getInfo();\n  return {\n    ref: serverRefToMessage(serverEntry.ref),\n    data: {\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    listen_socket: resolvedInfo.listenerChildren.sockets.map(ref => socketRefToMessage(ref))\n  };\n}\nfunction GetServer(call, callback) {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n  if (serverEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n  callback(null, {\n    server: getServerMessage(serverEntry)\n  });\n}\nfunction GetServers(call, callback) {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList = [];\n  let i = Number.parseInt(call.request.start_server_id);\n  for (; i < servers.length; i++) {\n    const serverEntry = servers[i];\n    if (serverEntry === undefined) {\n      continue;\n    }\n    resultList.push(getServerMessage(serverEntry));\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n  callback(null, {\n    server: resultList,\n    end: i >= servers.length\n  });\n}\nfunction GetSubchannel(call, callback) {\n  const subchannelId = Number.parseInt(call.request.subchannel_id);\n  const subchannelEntry = subchannels[subchannelId];\n  if (subchannelEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No subchannel data found for id ' + subchannelId\n    });\n    return;\n  }\n  const resolvedInfo = subchannelEntry.getInfo();\n  const subchannelMessage = {\n    ref: subchannelRefToMessage(subchannelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    socket_ref: resolvedInfo.children.sockets.map(ref => socketRefToMessage(ref))\n  };\n  callback(null, {\n    subchannel: subchannelMessage\n  });\n}\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n  var _a;\n  if (subchannel_address_1.isTcpSubchannelAddress(subchannelAddress)) {\n    return {\n      address: 'tcpip_address',\n      tcpip_address: {\n        ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n        port: subchannelAddress.port\n      }\n    };\n  } else {\n    return {\n      address: 'uds_address',\n      uds_address: {\n        filename: subchannelAddress.path\n      }\n    };\n  }\n}\nfunction GetSocket(call, callback) {\n  var _a, _b, _c, _d, _e;\n  const socketId = Number.parseInt(call.request.socket_id);\n  const socketEntry = sockets[socketId];\n  if (socketEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No socket data found for id ' + socketId\n    });\n    return;\n  }\n  const resolvedInfo = socketEntry.getInfo();\n  const securityMessage = resolvedInfo.security ? {\n    model: 'tls',\n    tls: {\n      cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? 'standard_name' : 'other_name',\n      standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n      other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n      local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n      remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined\n    }\n  } : null;\n  const socketMessage = {\n    ref: socketRefToMessage(socketEntry.ref),\n    local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n    remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n    remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n    security: securityMessage,\n    data: {\n      keep_alives_sent: resolvedInfo.keepAlivesSent,\n      streams_started: resolvedInfo.streamsStarted,\n      streams_succeeded: resolvedInfo.streamsSucceeded,\n      streams_failed: resolvedInfo.streamsFailed,\n      last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n      last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n      messages_received: resolvedInfo.messagesReceived,\n      messages_sent: resolvedInfo.messagesSent,\n      last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n      last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n      local_flow_control_window: resolvedInfo.localFlowControlWindow ? {\n        value: resolvedInfo.localFlowControlWindow\n      } : null,\n      remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? {\n        value: resolvedInfo.remoteFlowControlWindow\n      } : null\n    }\n  };\n  callback(null, {\n    socket: socketMessage\n  });\n}\nfunction GetServerSockets(call, callback) {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n  if (serverEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n  const startId = Number.parseInt(call.request.start_socket_id);\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resolvedInfo = serverEntry.getInfo();\n  // If we wanted to include listener sockets in the result, this line would\n  // instead say\n  // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n  const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);\n  const resultList = [];\n  let i = 0;\n  for (; i < allSockets.length; i++) {\n    if (allSockets[i].id >= startId) {\n      resultList.push(socketRefToMessage(allSockets[i]));\n      if (resultList.length >= maxResults) {\n        break;\n      }\n    }\n  }\n  callback(null, {\n    socket_ref: resultList,\n    end: i >= allSockets.length\n  });\n}\nfunction getChannelzHandlers() {\n  return {\n    GetChannel,\n    GetTopChannels,\n    GetServer,\n    GetServers,\n    GetSubchannel,\n    GetSocket,\n    GetServerSockets\n  };\n}\nexports.getChannelzHandlers = getChannelzHandlers;\nlet loadedChannelzDefinition = null;\nfunction getChannelzServiceDefinition() {\n  if (loadedChannelzDefinition) {\n    return loadedChannelzDefinition;\n  }\n  /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n   * runtime for users who will not use/enable channelz. */\n  const loaderLoadSync = require('@grpc/proto-loader').loadSync;\n  const loadedProto = loaderLoadSync('channelz.proto', {\n    keepCase: true,\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: true,\n    includeDirs: [`${__dirname}/../../proto`]\n  });\n  const channelzGrpcObject = make_client_1.loadPackageDefinition(loadedProto);\n  loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n  return loadedChannelzDefinition;\n}\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\nfunction setup() {\n  admin_1.registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);\n}\nexports.setup = setup;","map":{"version":3,"names":["Object","defineProperty","exports","value","setup","getChannelzServiceDefinition","getChannelzHandlers","unregisterChannelzRef","registerChannelzSocket","registerChannelzServer","registerChannelzSubchannel","registerChannelzChannel","ChannelzCallTracker","ChannelzChildrenTracker","ChannelzTrace","net_1","require","connectivity_state_1","constants_1","subchannel_address_1","admin_1","make_client_1","channelRefToMessage","ref","channel_id","id","name","subchannelRefToMessage","subchannel_id","serverRefToMessage","server_id","socketRefToMessage","socket_id","TARGET_RETAINED_TRACES","constructor","events","eventsLogged","creationTimestamp","Date","addTrace","severity","description","child","timestamp","push","childChannel","kind","undefined","childSubchannel","length","slice","getTraceMessage","creation_timestamp","dateToProtoTimestamp","num_events_logged","map","event","channel_ref","subchannel_ref","channelChildren","Map","subchannelChildren","socketChildren","refChild","_a","_b","_c","trackedChild","get","count","set","unrefChild","delete","getChildLists","channels","values","subchannels","sockets","callsStarted","callsSucceeded","callsFailed","lastCallStartedTimestamp","addCallStarted","addCallSucceeded","addCallFailed","nextId","getNextId","servers","getInfo","channelzEnabled","parseIPv6Section","addressSection","numberValue","Number","parseInt","parseIPv6Chunk","addressChunk","bytePairs","split","section","result","concat","ipAddressStringToBuffer","ipAddress","isIPv4","Buffer","from","Uint8Array","segment","isIPv6","leftSection","rightSection","doubleColonIndex","indexOf","substring","leftBuffer","rightBuffer","middleBuffer","alloc","connectivityStateToMessage","state","ConnectivityState","CONNECTING","IDLE","READY","SHUTDOWN","TRANSIENT_FAILURE","date","millisSinceEpoch","getTime","seconds","nanos","getChannelMessage","channelEntry","resolvedInfo","data","target","calls_started","callTracker","calls_succeeded","calls_failed","last_call_started_timestamp","trace","children","GetChannel","call","callback","channelId","request","Status","NOT_FOUND","channel","GetTopChannels","maxResults","max_results","resultList","i","start_channel_id","end","getServerMessage","serverEntry","listen_socket","listenerChildren","GetServer","serverId","server","GetServers","start_server_id","GetSubchannel","subchannelId","subchannelEntry","subchannelMessage","socket_ref","subchannel","subchannelAddressToAddressMessage","subchannelAddress","isTcpSubchannelAddress","address","tcpip_address","ip_address","host","port","uds_address","filename","path","GetSocket","_d","_e","socketId","socketEntry","securityMessage","security","model","tls","cipher_suite","cipherSuiteStandardName","standard_name","other_name","cipherSuiteOtherName","local_certificate","localCertificate","remote_certificate","remoteCertificate","socketMessage","local","localAddress","remote","remoteAddress","remote_name","remoteName","keep_alives_sent","keepAlivesSent","streams_started","streamsStarted","streams_succeeded","streamsSucceeded","streams_failed","streamsFailed","last_local_stream_created_timestamp","lastLocalStreamCreatedTimestamp","last_remote_stream_created_timestamp","lastRemoteStreamCreatedTimestamp","messages_received","messagesReceived","messages_sent","messagesSent","last_message_received_timestamp","lastMessageReceivedTimestamp","last_message_sent_timestamp","lastMessageSentTimestamp","local_flow_control_window","localFlowControlWindow","remote_flow_control_window","remoteFlowControlWindow","socket","GetServerSockets","startId","start_socket_id","allSockets","sessionChildren","sort","ref1","ref2","loadedChannelzDefinition","loaderLoadSync","loadSync","loadedProto","keepCase","longs","String","enums","defaults","oneofs","includeDirs","__dirname","channelzGrpcObject","loadPackageDefinition","grpc","channelz","v1","Channelz","service","registerAdminService"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/channelz.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTracker = exports.ChannelzChildrenTracker = exports.ChannelzTrace = void 0;\nconst net_1 = require(\"net\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst constants_1 = require(\"./constants\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst admin_1 = require(\"./admin\");\nconst make_client_1 = require(\"./make-client\");\nfunction channelRefToMessage(ref) {\n    return {\n        channel_id: ref.id,\n        name: ref.name\n    };\n}\nfunction subchannelRefToMessage(ref) {\n    return {\n        subchannel_id: ref.id,\n        name: ref.name\n    };\n}\nfunction serverRefToMessage(ref) {\n    return {\n        server_id: ref.id\n    };\n}\nfunction socketRefToMessage(ref) {\n    return {\n        socket_id: ref.id,\n        name: ref.name\n    };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\nconst TARGET_RETAINED_TRACES = 32;\nclass ChannelzTrace {\n    constructor() {\n        this.events = [];\n        this.eventsLogged = 0;\n        this.creationTimestamp = new Date();\n    }\n    addTrace(severity, description, child) {\n        const timestamp = new Date();\n        this.events.push({\n            description: description,\n            severity: severity,\n            timestamp: timestamp,\n            childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,\n            childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined\n        });\n        // Whenever the trace array gets too large, discard the first half\n        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n            this.events = this.events.slice(TARGET_RETAINED_TRACES);\n        }\n        this.eventsLogged += 1;\n    }\n    getTraceMessage() {\n        return {\n            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n            num_events_logged: this.eventsLogged,\n            events: this.events.map(event => {\n                return {\n                    description: event.description,\n                    severity: event.severity,\n                    timestamp: dateToProtoTimestamp(event.timestamp),\n                    channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n                    subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n                };\n            })\n        };\n    }\n}\nexports.ChannelzTrace = ChannelzTrace;\nclass ChannelzChildrenTracker {\n    constructor() {\n        this.channelChildren = new Map();\n        this.subchannelChildren = new Map();\n        this.socketChildren = new Map();\n    }\n    refChild(child) {\n        var _a, _b, _c;\n        switch (child.kind) {\n            case 'channel': {\n                let trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : { ref: child, count: 0 };\n                trackedChild.count += 1;\n                this.channelChildren.set(child.id, trackedChild);\n                break;\n            }\n            case 'subchannel': {\n                let trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : { ref: child, count: 0 };\n                trackedChild.count += 1;\n                this.subchannelChildren.set(child.id, trackedChild);\n                break;\n            }\n            case 'socket': {\n                let trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : { ref: child, count: 0 };\n                trackedChild.count += 1;\n                this.socketChildren.set(child.id, trackedChild);\n                break;\n            }\n        }\n    }\n    unrefChild(child) {\n        switch (child.kind) {\n            case 'channel': {\n                let trackedChild = this.channelChildren.get(child.id);\n                if (trackedChild !== undefined) {\n                    trackedChild.count -= 1;\n                    if (trackedChild.count === 0) {\n                        this.channelChildren.delete(child.id);\n                    }\n                    else {\n                        this.channelChildren.set(child.id, trackedChild);\n                    }\n                }\n                break;\n            }\n            case 'subchannel': {\n                let trackedChild = this.subchannelChildren.get(child.id);\n                if (trackedChild !== undefined) {\n                    trackedChild.count -= 1;\n                    if (trackedChild.count === 0) {\n                        this.subchannelChildren.delete(child.id);\n                    }\n                    else {\n                        this.subchannelChildren.set(child.id, trackedChild);\n                    }\n                }\n                break;\n            }\n            case 'socket': {\n                let trackedChild = this.socketChildren.get(child.id);\n                if (trackedChild !== undefined) {\n                    trackedChild.count -= 1;\n                    if (trackedChild.count === 0) {\n                        this.socketChildren.delete(child.id);\n                    }\n                    else {\n                        this.socketChildren.set(child.id, trackedChild);\n                    }\n                }\n                break;\n            }\n        }\n    }\n    getChildLists() {\n        const channels = [];\n        for (const { ref } of this.channelChildren.values()) {\n            channels.push(ref);\n        }\n        const subchannels = [];\n        for (const { ref } of this.subchannelChildren.values()) {\n            subchannels.push(ref);\n        }\n        const sockets = [];\n        for (const { ref } of this.socketChildren.values()) {\n            sockets.push(ref);\n        }\n        return { channels, subchannels, sockets };\n    }\n}\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\nclass ChannelzCallTracker {\n    constructor() {\n        this.callsStarted = 0;\n        this.callsSucceeded = 0;\n        this.callsFailed = 0;\n        this.lastCallStartedTimestamp = null;\n    }\n    addCallStarted() {\n        this.callsStarted += 1;\n        this.lastCallStartedTimestamp = new Date();\n    }\n    addCallSucceeded() {\n        this.callsSucceeded += 1;\n    }\n    addCallFailed() {\n        this.callsFailed += 1;\n    }\n}\nexports.ChannelzCallTracker = ChannelzCallTracker;\nlet nextId = 1;\nfunction getNextId() {\n    return nextId++;\n}\nconst channels = [];\nconst subchannels = [];\nconst servers = [];\nconst sockets = [];\nfunction registerChannelzChannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, name, kind: 'channel' };\n    if (channelzEnabled) {\n        channels[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzChannel = registerChannelzChannel;\nfunction registerChannelzSubchannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, name, kind: 'subchannel' };\n    if (channelzEnabled) {\n        subchannels[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzSubchannel = registerChannelzSubchannel;\nfunction registerChannelzServer(getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, kind: 'server' };\n    if (channelzEnabled) {\n        servers[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzServer = registerChannelzServer;\nfunction registerChannelzSocket(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, name, kind: 'socket' };\n    if (channelzEnabled) {\n        sockets[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzSocket = registerChannelzSocket;\nfunction unregisterChannelzRef(ref) {\n    switch (ref.kind) {\n        case 'channel':\n            delete channels[ref.id];\n            return;\n        case 'subchannel':\n            delete subchannels[ref.id];\n            return;\n        case 'server':\n            delete servers[ref.id];\n            return;\n        case 'socket':\n            delete sockets[ref.id];\n            return;\n    }\n}\nexports.unregisterChannelzRef = unregisterChannelzRef;\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\nfunction parseIPv6Section(addressSection) {\n    const numberValue = Number.parseInt(addressSection, 16);\n    return [numberValue / 256 | 0, numberValue % 256];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\nfunction parseIPv6Chunk(addressChunk) {\n    if (addressChunk === '') {\n        return [];\n    }\n    const bytePairs = addressChunk.split(':').map(section => parseIPv6Section(section));\n    const result = [];\n    return result.concat(...bytePairs);\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */\nfunction ipAddressStringToBuffer(ipAddress) {\n    if (net_1.isIPv4(ipAddress)) {\n        return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\n    }\n    else if (net_1.isIPv6(ipAddress)) {\n        let leftSection;\n        let rightSection;\n        const doubleColonIndex = ipAddress.indexOf('::');\n        if (doubleColonIndex === -1) {\n            leftSection = ipAddress;\n            rightSection = '';\n        }\n        else {\n            leftSection = ipAddress.substring(0, doubleColonIndex);\n            rightSection = ipAddress.substring(doubleColonIndex + 2);\n        }\n        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n        return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n    }\n    else {\n        return null;\n    }\n}\nfunction connectivityStateToMessage(state) {\n    switch (state) {\n        case connectivity_state_1.ConnectivityState.CONNECTING:\n            return {\n                state: 'CONNECTING'\n            };\n        case connectivity_state_1.ConnectivityState.IDLE:\n            return {\n                state: 'IDLE'\n            };\n        case connectivity_state_1.ConnectivityState.READY:\n            return {\n                state: 'READY'\n            };\n        case connectivity_state_1.ConnectivityState.SHUTDOWN:\n            return {\n                state: 'SHUTDOWN'\n            };\n        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n            return {\n                state: 'TRANSIENT_FAILURE'\n            };\n        default:\n            return {\n                state: 'UNKNOWN'\n            };\n    }\n}\nfunction dateToProtoTimestamp(date) {\n    if (!date) {\n        return null;\n    }\n    const millisSinceEpoch = date.getTime();\n    return {\n        seconds: (millisSinceEpoch / 1000) | 0,\n        nanos: (millisSinceEpoch % 1000) * 1000000\n    };\n}\nfunction getChannelMessage(channelEntry) {\n    const resolvedInfo = channelEntry.getInfo();\n    return {\n        ref: channelRefToMessage(channelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        channel_ref: resolvedInfo.children.channels.map(ref => channelRefToMessage(ref)),\n        subchannel_ref: resolvedInfo.children.subchannels.map(ref => subchannelRefToMessage(ref))\n    };\n}\nfunction GetChannel(call, callback) {\n    const channelId = Number.parseInt(call.request.channel_id);\n    const channelEntry = channels[channelId];\n    if (channelEntry === undefined) {\n        callback({\n            'code': constants_1.Status.NOT_FOUND,\n            'details': 'No channel data found for id ' + channelId\n        });\n        return;\n    }\n    callback(null, { channel: getChannelMessage(channelEntry) });\n}\nfunction GetTopChannels(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_channel_id);\n    for (; i < channels.length; i++) {\n        const channelEntry = channels[i];\n        if (channelEntry === undefined) {\n            continue;\n        }\n        resultList.push(getChannelMessage(channelEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        channel: resultList,\n        end: i >= servers.length\n    });\n}\nfunction getServerMessage(serverEntry) {\n    const resolvedInfo = serverEntry.getInfo();\n    return {\n        ref: serverRefToMessage(serverEntry.ref),\n        data: {\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        listen_socket: resolvedInfo.listenerChildren.sockets.map(ref => socketRefToMessage(ref))\n    };\n}\nfunction GetServer(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            'code': constants_1.Status.NOT_FOUND,\n            'details': 'No server data found for id ' + serverId\n        });\n        return;\n    }\n    callback(null, { server: getServerMessage(serverEntry) });\n}\nfunction GetServers(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_server_id);\n    for (; i < servers.length; i++) {\n        const serverEntry = servers[i];\n        if (serverEntry === undefined) {\n            continue;\n        }\n        resultList.push(getServerMessage(serverEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        server: resultList,\n        end: i >= servers.length\n    });\n}\nfunction GetSubchannel(call, callback) {\n    const subchannelId = Number.parseInt(call.request.subchannel_id);\n    const subchannelEntry = subchannels[subchannelId];\n    if (subchannelEntry === undefined) {\n        callback({\n            'code': constants_1.Status.NOT_FOUND,\n            'details': 'No subchannel data found for id ' + subchannelId\n        });\n        return;\n    }\n    const resolvedInfo = subchannelEntry.getInfo();\n    const subchannelMessage = {\n        ref: subchannelRefToMessage(subchannelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        socket_ref: resolvedInfo.children.sockets.map(ref => socketRefToMessage(ref))\n    };\n    callback(null, { subchannel: subchannelMessage });\n}\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n    var _a;\n    if (subchannel_address_1.isTcpSubchannelAddress(subchannelAddress)) {\n        return {\n            address: 'tcpip_address',\n            tcpip_address: {\n                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n                port: subchannelAddress.port\n            }\n        };\n    }\n    else {\n        return {\n            address: 'uds_address',\n            uds_address: {\n                filename: subchannelAddress.path\n            }\n        };\n    }\n}\nfunction GetSocket(call, callback) {\n    var _a, _b, _c, _d, _e;\n    const socketId = Number.parseInt(call.request.socket_id);\n    const socketEntry = sockets[socketId];\n    if (socketEntry === undefined) {\n        callback({\n            'code': constants_1.Status.NOT_FOUND,\n            'details': 'No socket data found for id ' + socketId\n        });\n        return;\n    }\n    const resolvedInfo = socketEntry.getInfo();\n    const securityMessage = resolvedInfo.security ? {\n        model: 'tls',\n        tls: {\n            cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? 'standard_name' : 'other_name',\n            standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n            other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n            local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n            remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined\n        }\n    } : null;\n    const socketMessage = {\n        ref: socketRefToMessage(socketEntry.ref),\n        local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n        remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n        security: securityMessage,\n        data: {\n            keep_alives_sent: resolvedInfo.keepAlivesSent,\n            streams_started: resolvedInfo.streamsStarted,\n            streams_succeeded: resolvedInfo.streamsSucceeded,\n            streams_failed: resolvedInfo.streamsFailed,\n            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n            messages_received: resolvedInfo.messagesReceived,\n            messages_sent: resolvedInfo.messagesSent,\n            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n            local_flow_control_window: resolvedInfo.localFlowControlWindow ? { value: resolvedInfo.localFlowControlWindow } : null,\n            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? { value: resolvedInfo.remoteFlowControlWindow } : null,\n        }\n    };\n    callback(null, { socket: socketMessage });\n}\nfunction GetServerSockets(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            'code': constants_1.Status.NOT_FOUND,\n            'details': 'No server data found for id ' + serverId\n        });\n        return;\n    }\n    const startId = Number.parseInt(call.request.start_socket_id);\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resolvedInfo = serverEntry.getInfo();\n    // If we wanted to include listener sockets in the result, this line would\n    // instead say\n    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n    const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);\n    const resultList = [];\n    let i = 0;\n    for (; i < allSockets.length; i++) {\n        if (allSockets[i].id >= startId) {\n            resultList.push(socketRefToMessage(allSockets[i]));\n            if (resultList.length >= maxResults) {\n                break;\n            }\n        }\n    }\n    callback(null, {\n        socket_ref: resultList,\n        end: i >= allSockets.length\n    });\n}\nfunction getChannelzHandlers() {\n    return {\n        GetChannel,\n        GetTopChannels,\n        GetServer,\n        GetServers,\n        GetSubchannel,\n        GetSocket,\n        GetServerSockets\n    };\n}\nexports.getChannelzHandlers = getChannelzHandlers;\nlet loadedChannelzDefinition = null;\nfunction getChannelzServiceDefinition() {\n    if (loadedChannelzDefinition) {\n        return loadedChannelzDefinition;\n    }\n    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n     * runtime for users who will not use/enable channelz. */\n    const loaderLoadSync = require('@grpc/proto-loader').loadSync;\n    const loadedProto = loaderLoadSync('channelz.proto', {\n        keepCase: true,\n        longs: String,\n        enums: String,\n        defaults: true,\n        oneofs: true,\n        includeDirs: [\n            `${__dirname}/../../proto`\n        ]\n    });\n    const channelzGrpcObject = make_client_1.loadPackageDefinition(loadedProto);\n    loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n    return loadedChannelzDefinition;\n}\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\nfunction setup() {\n    admin_1.registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);\n}\nexports.setup = setup;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}