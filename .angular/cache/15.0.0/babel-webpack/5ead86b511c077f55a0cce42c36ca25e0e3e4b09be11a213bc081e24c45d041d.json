{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n  constructor(callback, options) {\n    this.callback = callback;\n    /**\n     * The delay time at the start, and after each reset.\n     */\n    this.initialDelay = INITIAL_BACKOFF_MS;\n    /**\n     * The exponential backoff multiplier.\n     */\n    this.multiplier = BACKOFF_MULTIPLIER;\n    /**\n     * The maximum delay time\n     */\n    this.maxDelay = MAX_BACKOFF_MS;\n    /**\n     * The maximum fraction by which the delay time can randomly vary after\n     * applying the multiplier.\n     */\n    this.jitter = BACKOFF_JITTER;\n    /**\n     * Indicates whether the timer is currently running.\n     */\n    this.running = false;\n    /**\n     * Indicates whether the timer should keep the Node process running if no\n     * other async operation is doing so.\n     */\n    this.hasRef = true;\n    /**\n     * The time that the currently running timer was started. Only valid if\n     * running is true.\n     */\n    this.startTime = new Date();\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(() => {}, 0);\n    clearTimeout(this.timerId);\n  }\n  runTimer(delay) {\n    var _a, _b;\n    clearTimeout(this.timerId);\n    this.timerId = setTimeout(() => {\n      this.callback();\n      this.running = false;\n    }, delay);\n    if (!this.hasRef) {\n      (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n  /**\n   * Call the callback after the current amount of delay time\n   */\n  runOnce() {\n    this.running = true;\n    this.startTime = new Date();\n    this.runTimer(this.nextDelay);\n    const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n    const jitterMagnitude = nextBackoff * this.jitter;\n    this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n  }\n  /**\n   * Stop the timer. The callback will not be called until `runOnce` is called\n   * again.\n   */\n  stop() {\n    clearTimeout(this.timerId);\n    this.running = false;\n  }\n  /**\n   * Reset the delay time to its initial value. If the timer is still running,\n   * retroactively apply that reset to the current timer.\n   */\n  reset() {\n    this.nextDelay = this.initialDelay;\n    if (this.running) {\n      const now = new Date();\n      const newEndTime = this.startTime;\n      newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n      clearTimeout(this.timerId);\n      if (now < newEndTime) {\n        this.runTimer(newEndTime.getTime() - now.getTime());\n      } else {\n        this.running = false;\n      }\n    }\n  }\n  /**\n   * Check whether the timer is currently running.\n   */\n  isRunning() {\n    return this.running;\n  }\n  /**\n   * Set that while the timer is running, it should keep the Node process\n   * running.\n   */\n  ref() {\n    var _a, _b;\n    this.hasRef = true;\n    (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  /**\n   * Set that while the timer is running, it should not keep the Node process\n   * running.\n   */\n  unref() {\n    var _a, _b;\n    this.hasRef = false;\n    (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n}\nexports.BackoffTimeout = BackoffTimeout;","map":{"version":3,"names":["Object","defineProperty","exports","value","BackoffTimeout","INITIAL_BACKOFF_MS","BACKOFF_MULTIPLIER","MAX_BACKOFF_MS","BACKOFF_JITTER","uniformRandom","min","max","Math","random","constructor","callback","options","initialDelay","multiplier","maxDelay","jitter","running","hasRef","startTime","Date","nextDelay","timerId","setTimeout","clearTimeout","runTimer","delay","_a","_b","unref","call","runOnce","nextBackoff","jitterMagnitude","stop","reset","now","newEndTime","setMilliseconds","getMilliseconds","getTime","isRunning","ref"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/backoff-timeout.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n    constructor(callback, options) {\n        this.callback = callback;\n        /**\n         * The delay time at the start, and after each reset.\n         */\n        this.initialDelay = INITIAL_BACKOFF_MS;\n        /**\n         * The exponential backoff multiplier.\n         */\n        this.multiplier = BACKOFF_MULTIPLIER;\n        /**\n         * The maximum delay time\n         */\n        this.maxDelay = MAX_BACKOFF_MS;\n        /**\n         * The maximum fraction by which the delay time can randomly vary after\n         * applying the multiplier.\n         */\n        this.jitter = BACKOFF_JITTER;\n        /**\n         * Indicates whether the timer is currently running.\n         */\n        this.running = false;\n        /**\n         * Indicates whether the timer should keep the Node process running if no\n         * other async operation is doing so.\n         */\n        this.hasRef = true;\n        /**\n         * The time that the currently running timer was started. Only valid if\n         * running is true.\n         */\n        this.startTime = new Date();\n        if (options) {\n            if (options.initialDelay) {\n                this.initialDelay = options.initialDelay;\n            }\n            if (options.multiplier) {\n                this.multiplier = options.multiplier;\n            }\n            if (options.jitter) {\n                this.jitter = options.jitter;\n            }\n            if (options.maxDelay) {\n                this.maxDelay = options.maxDelay;\n            }\n        }\n        this.nextDelay = this.initialDelay;\n        this.timerId = setTimeout(() => { }, 0);\n        clearTimeout(this.timerId);\n    }\n    runTimer(delay) {\n        var _a, _b;\n        clearTimeout(this.timerId);\n        this.timerId = setTimeout(() => {\n            this.callback();\n            this.running = false;\n        }, delay);\n        if (!this.hasRef) {\n            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Call the callback after the current amount of delay time\n     */\n    runOnce() {\n        this.running = true;\n        this.startTime = new Date();\n        this.runTimer(this.nextDelay);\n        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n        const jitterMagnitude = nextBackoff * this.jitter;\n        this.nextDelay =\n            nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n    }\n    /**\n     * Stop the timer. The callback will not be called until `runOnce` is called\n     * again.\n     */\n    stop() {\n        clearTimeout(this.timerId);\n        this.running = false;\n    }\n    /**\n     * Reset the delay time to its initial value. If the timer is still running,\n     * retroactively apply that reset to the current timer.\n     */\n    reset() {\n        this.nextDelay = this.initialDelay;\n        if (this.running) {\n            const now = new Date();\n            const newEndTime = this.startTime;\n            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n            clearTimeout(this.timerId);\n            if (now < newEndTime) {\n                this.runTimer(newEndTime.getTime() - now.getTime());\n            }\n            else {\n                this.running = false;\n            }\n        }\n    }\n    /**\n     * Check whether the timer is currently running.\n     */\n    isRunning() {\n        return this.running;\n    }\n    /**\n     * Set that while the timer is running, it should keep the Node process\n     * running.\n     */\n    ref() {\n        var _a, _b;\n        this.hasRef = true;\n        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Set that while the timer is running, it should not keep the Node process\n     * running.\n     */\n    unref() {\n        var _a, _b;\n        this.hasRef = false;\n        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n}\nexports.BackoffTimeout = BackoffTimeout;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}