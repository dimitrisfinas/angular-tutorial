{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResolvingLoadBalancer = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst service_config_1 = require(\"./service-config\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst resolver_1 = require(\"./resolver\");\nconst picker_1 = require(\"./picker\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst load_balancer_child_handler_1 = require(\"./load-balancer-child-handler\");\nconst TRACER_NAME = 'resolving_load_balancer';\nfunction trace(text) {\n  logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst DEFAULT_LOAD_BALANCER_NAME = 'pick_first';\nfunction getDefaultConfigSelector(serviceConfig) {\n  return function defaultConfigSelector(methodName, metadata) {\n    var _a, _b;\n    const splitName = methodName.split('/').filter(x => x.length > 0);\n    const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';\n    const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';\n    if (serviceConfig && serviceConfig.methodConfig) {\n      for (const methodConfig of serviceConfig.methodConfig) {\n        for (const name of methodConfig.name) {\n          if (name.service === service && (name.method === undefined || name.method === method)) {\n            return {\n              methodConfig: methodConfig,\n              pickInformation: {},\n              status: constants_1.Status.OK,\n              dynamicFilterFactories: []\n            };\n          }\n        }\n      }\n    }\n    return {\n      methodConfig: {\n        name: []\n      },\n      pickInformation: {},\n      status: constants_1.Status.OK,\n      dynamicFilterFactories: []\n    };\n  };\n}\nclass ResolvingLoadBalancer {\n  /**\n   * Wrapper class that behaves like a `LoadBalancer` and also handles name\n   * resolution internally.\n   * @param target The address of the backend to connect to.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   * @param defaultServiceConfig The default service configuration to be used\n   *     if none is provided by the name resolver. A `null` value indicates\n   *     that the default behavior should be the default unconfigured behavior.\n   *     In practice, that means using the \"pick first\" load balancer\n   *     implmentation\n   */\n  constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {\n    this.target = target;\n    this.channelControlHelper = channelControlHelper;\n    this.channelOptions = channelOptions;\n    this.onSuccessfulResolution = onSuccessfulResolution;\n    this.onFailedResolution = onFailedResolution;\n    this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n    this.latestChildPicker = new picker_1.QueuePicker(this);\n    /**\n     * This resolving load balancer's current connectivity state.\n     */\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The service config object from the last successful resolution, if\n     * available. A value of null indicates that we have not yet received a valid\n     * service config from the resolver.\n     */\n    this.previousServiceConfig = null;\n    /**\n     * Indicates whether we should attempt to resolve again after the backoff\n     * timer runs out.\n     */\n    this.continueResolving = false;\n    if (channelOptions['grpc.service_config']) {\n      this.defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(channelOptions['grpc.service_config']));\n    } else {\n      this.defaultServiceConfig = {\n        loadBalancingConfig: [],\n        methodConfig: []\n      };\n    }\n    this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n      createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n      requestReresolution: () => {\n        /* If the backoffTimeout is running, we're still backing off from\n         * making resolve requests, so we shouldn't make another one here.\n         * In that case, the backoff timer callback will call\n         * updateResolution */\n        if (this.backoffTimeout.isRunning()) {\n          this.continueResolving = true;\n        } else {\n          this.updateResolution();\n        }\n      },\n      updateState: (newState, picker) => {\n        this.latestChildState = newState;\n        this.latestChildPicker = picker;\n        this.updateState(newState, picker);\n      },\n      addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\n      removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)\n    });\n    this.innerResolver = resolver_1.createResolver(target, {\n      onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {\n        var _a;\n        let workingServiceConfig = null;\n        /* This first group of conditionals implements the algorithm described\n         * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n         * in the section called \"Behavior on receiving a new gRPC Config\".\n         */\n        if (serviceConfig === null) {\n          // Step 4 and 5\n          if (serviceConfigError === null) {\n            // Step 5\n            this.previousServiceConfig = null;\n            workingServiceConfig = this.defaultServiceConfig;\n          } else {\n            // Step 4\n            if (this.previousServiceConfig === null) {\n              // Step 4.ii\n              this.handleResolutionFailure(serviceConfigError);\n            } else {\n              // Step 4.i\n              workingServiceConfig = this.previousServiceConfig;\n            }\n          }\n        } else {\n          // Step 3\n          workingServiceConfig = serviceConfig;\n          this.previousServiceConfig = serviceConfig;\n        }\n        const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n        const loadBalancingConfig = load_balancer_1.getFirstUsableConfig(workingConfigList, true);\n        if (loadBalancingConfig === null) {\n          // There were load balancing configs but none are supported. This counts as a resolution failure\n          this.handleResolutionFailure({\n            code: constants_1.Status.UNAVAILABLE,\n            details: 'All load balancer options in service config are not compatible',\n            metadata: new metadata_1.Metadata()\n          });\n          return;\n        }\n        this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);\n        const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\n        this.onSuccessfulResolution(configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\n      },\n      onError: error => {\n        this.handleResolutionFailure(error);\n      }\n    }, channelOptions);\n    const backoffOptions = {\n      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      if (this.continueResolving) {\n        this.updateResolution();\n        this.continueResolving = false;\n      } else {\n        this.updateState(this.latestChildState, this.latestChildPicker);\n      }\n    }, backoffOptions);\n    this.backoffTimeout.unref();\n  }\n  updateResolution() {\n    this.innerResolver.updateResolution();\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n      this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n    }\n    this.backoffTimeout.runOnce();\n  }\n  updateState(connectivityState, picker) {\n    trace(uri_parser_1.uriToString(this.target) + ' ' + connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[connectivityState]);\n    // Ensure that this.exitIdle() is called by the picker\n    if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\n      picker = new picker_1.QueuePicker(this);\n    }\n    this.currentState = connectivityState;\n    this.channelControlHelper.updateState(connectivityState, picker);\n  }\n  handleResolutionFailure(error) {\n    if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\n      this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n      this.onFailedResolution(error);\n    }\n  }\n  exitIdle() {\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n      if (this.backoffTimeout.isRunning()) {\n        this.continueResolving = true;\n      } else {\n        this.updateResolution();\n      }\n    }\n    this.childLoadBalancer.exitIdle();\n  }\n  updateAddressList(addressList, lbConfig) {\n    throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n  }\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.childLoadBalancer.resetBackoff();\n  }\n  destroy() {\n    this.childLoadBalancer.destroy();\n    this.innerResolver.destroy();\n    this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());\n  }\n  getTypeName() {\n    return 'resolving_load_balancer';\n  }\n}\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;","map":{"version":3,"names":["Object","defineProperty","exports","value","ResolvingLoadBalancer","load_balancer_1","require","service_config_1","connectivity_state_1","resolver_1","picker_1","backoff_timeout_1","constants_1","metadata_1","logging","constants_2","uri_parser_1","load_balancer_child_handler_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","DEFAULT_LOAD_BALANCER_NAME","getDefaultConfigSelector","serviceConfig","defaultConfigSelector","methodName","metadata","_a","_b","splitName","split","filter","x","length","service","method","methodConfig","name","undefined","pickInformation","status","Status","OK","dynamicFilterFactories","constructor","target","channelControlHelper","channelOptions","onSuccessfulResolution","onFailedResolution","latestChildState","ConnectivityState","IDLE","latestChildPicker","QueuePicker","currentState","previousServiceConfig","continueResolving","defaultServiceConfig","validateServiceConfig","JSON","parse","loadBalancingConfig","updateState","childLoadBalancer","ChildLoadBalancerHandler","createSubchannel","bind","requestReresolution","backoffTimeout","isRunning","updateResolution","newState","picker","addChannelzChild","removeChannelzChild","innerResolver","createResolver","addressList","serviceConfigError","configSelector","attributes","workingServiceConfig","handleResolutionFailure","workingConfigList","getFirstUsableConfig","code","UNAVAILABLE","details","Metadata","updateAddressList","finalServiceConfig","onError","error","backoffOptions","initialDelay","maxDelay","BackoffTimeout","unref","CONNECTING","runOnce","connectivityState","uriToString","TRANSIENT_FAILURE","UnavailablePicker","exitIdle","lbConfig","Error","resetBackoff","reset","destroy","SHUTDOWN","getTypeName"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ResolvingLoadBalancer = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst service_config_1 = require(\"./service-config\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst resolver_1 = require(\"./resolver\");\nconst picker_1 = require(\"./picker\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst load_balancer_child_handler_1 = require(\"./load-balancer-child-handler\");\nconst TRACER_NAME = 'resolving_load_balancer';\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst DEFAULT_LOAD_BALANCER_NAME = 'pick_first';\nfunction getDefaultConfigSelector(serviceConfig) {\n    return function defaultConfigSelector(methodName, metadata) {\n        var _a, _b;\n        const splitName = methodName.split('/').filter((x) => x.length > 0);\n        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';\n        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';\n        if (serviceConfig && serviceConfig.methodConfig) {\n            for (const methodConfig of serviceConfig.methodConfig) {\n                for (const name of methodConfig.name) {\n                    if (name.service === service &&\n                        (name.method === undefined || name.method === method)) {\n                        return {\n                            methodConfig: methodConfig,\n                            pickInformation: {},\n                            status: constants_1.Status.OK,\n                            dynamicFilterFactories: []\n                        };\n                    }\n                }\n            }\n        }\n        return {\n            methodConfig: { name: [] },\n            pickInformation: {},\n            status: constants_1.Status.OK,\n            dynamicFilterFactories: []\n        };\n    };\n}\nclass ResolvingLoadBalancer {\n    /**\n     * Wrapper class that behaves like a `LoadBalancer` and also handles name\n     * resolution internally.\n     * @param target The address of the backend to connect to.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     * @param defaultServiceConfig The default service configuration to be used\n     *     if none is provided by the name resolver. A `null` value indicates\n     *     that the default behavior should be the default unconfigured behavior.\n     *     In practice, that means using the \"pick first\" load balancer\n     *     implmentation\n     */\n    constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {\n        this.target = target;\n        this.channelControlHelper = channelControlHelper;\n        this.channelOptions = channelOptions;\n        this.onSuccessfulResolution = onSuccessfulResolution;\n        this.onFailedResolution = onFailedResolution;\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        /**\n         * This resolving load balancer's current connectivity state.\n         */\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The service config object from the last successful resolution, if\n         * available. A value of null indicates that we have not yet received a valid\n         * service config from the resolver.\n         */\n        this.previousServiceConfig = null;\n        /**\n         * Indicates whether we should attempt to resolve again after the backoff\n         * timer runs out.\n         */\n        this.continueResolving = false;\n        if (channelOptions['grpc.service_config']) {\n            this.defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(channelOptions['grpc.service_config']));\n        }\n        else {\n            this.defaultServiceConfig = {\n                loadBalancingConfig: [],\n                methodConfig: [],\n            };\n        }\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n            requestReresolution: () => {\n                /* If the backoffTimeout is running, we're still backing off from\n                 * making resolve requests, so we shouldn't make another one here.\n                 * In that case, the backoff timer callback will call\n                 * updateResolution */\n                if (this.backoffTimeout.isRunning()) {\n                    this.continueResolving = true;\n                }\n                else {\n                    this.updateResolution();\n                }\n            },\n            updateState: (newState, picker) => {\n                this.latestChildState = newState;\n                this.latestChildPicker = picker;\n                this.updateState(newState, picker);\n            },\n            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\n            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)\n        });\n        this.innerResolver = resolver_1.createResolver(target, {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {\n                var _a;\n                let workingServiceConfig = null;\n                /* This first group of conditionals implements the algorithm described\n                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n                 * in the section called \"Behavior on receiving a new gRPC Config\".\n                 */\n                if (serviceConfig === null) {\n                    // Step 4 and 5\n                    if (serviceConfigError === null) {\n                        // Step 5\n                        this.previousServiceConfig = null;\n                        workingServiceConfig = this.defaultServiceConfig;\n                    }\n                    else {\n                        // Step 4\n                        if (this.previousServiceConfig === null) {\n                            // Step 4.ii\n                            this.handleResolutionFailure(serviceConfigError);\n                        }\n                        else {\n                            // Step 4.i\n                            workingServiceConfig = this.previousServiceConfig;\n                        }\n                    }\n                }\n                else {\n                    // Step 3\n                    workingServiceConfig = serviceConfig;\n                    this.previousServiceConfig = serviceConfig;\n                }\n                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n                const loadBalancingConfig = load_balancer_1.getFirstUsableConfig(workingConfigList, true);\n                if (loadBalancingConfig === null) {\n                    // There were load balancing configs but none are supported. This counts as a resolution failure\n                    this.handleResolutionFailure({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: 'All load balancer options in service config are not compatible',\n                        metadata: new metadata_1.Metadata(),\n                    });\n                    return;\n                }\n                this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);\n                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\n                this.onSuccessfulResolution(configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\n            },\n            onError: (error) => {\n                this.handleResolutionFailure(error);\n            },\n        }, channelOptions);\n        const backoffOptions = {\n            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n            if (this.continueResolving) {\n                this.updateResolution();\n                this.continueResolving = false;\n            }\n            else {\n                this.updateState(this.latestChildState, this.latestChildPicker);\n            }\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n    }\n    updateResolution() {\n        this.innerResolver.updateResolution();\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n        this.backoffTimeout.runOnce();\n    }\n    updateState(connectivityState, picker) {\n        trace(uri_parser_1.uriToString(this.target) +\n            ' ' +\n            connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[connectivityState]);\n        // Ensure that this.exitIdle() is called by the picker\n        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\n            picker = new picker_1.QueuePicker(this);\n        }\n        this.currentState = connectivityState;\n        this.channelControlHelper.updateState(connectivityState, picker);\n    }\n    handleResolutionFailure(error) {\n        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n            this.onFailedResolution(error);\n        }\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            if (this.backoffTimeout.isRunning()) {\n                this.continueResolving = true;\n            }\n            else {\n                this.updateResolution();\n            }\n        }\n        this.childLoadBalancer.exitIdle();\n    }\n    updateAddressList(addressList, lbConfig) {\n        throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n    }\n    resetBackoff() {\n        this.backoffTimeout.reset();\n        this.childLoadBalancer.resetBackoff();\n    }\n    destroy() {\n        this.childLoadBalancer.destroy();\n        this.innerResolver.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());\n    }\n    getTypeName() {\n        return 'resolving_load_balancer';\n    }\n}\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,qBAAqB,GAAG,KAAK,CAAC;AACtC,MAAMC,eAAe,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAClD,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AACpD,MAAME,oBAAoB,GAAGF,OAAO,CAAC,sBAAsB,CAAC;AAC5D,MAAMG,UAAU,GAAGH,OAAO,CAAC,YAAY,CAAC;AACxC,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,UAAU,CAAC;AACpC,MAAMK,iBAAiB,GAAGL,OAAO,CAAC,mBAAmB,CAAC;AACtD,MAAMM,WAAW,GAAGN,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAMO,UAAU,GAAGP,OAAO,CAAC,YAAY,CAAC;AACxC,MAAMQ,OAAO,GAAGR,OAAO,CAAC,WAAW,CAAC;AACpC,MAAMS,WAAW,GAAGT,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAMU,YAAY,GAAGV,OAAO,CAAC,cAAc,CAAC;AAC5C,MAAMW,6BAA6B,GAAGX,OAAO,CAAC,+BAA+B,CAAC;AAC9E,MAAMY,WAAW,GAAG,yBAAyB;AAC7C,SAASC,KAAK,CAACC,IAAI,EAAE;EACjBN,OAAO,CAACK,KAAK,CAACJ,WAAW,CAACM,YAAY,CAACC,KAAK,EAAEJ,WAAW,EAAEE,IAAI,CAAC;AACpE;AACA,MAAMG,0BAA0B,GAAG,YAAY;AAC/C,SAASC,wBAAwB,CAACC,aAAa,EAAE;EAC7C,OAAO,SAASC,qBAAqB,CAACC,UAAU,EAAEC,QAAQ,EAAE;IACxD,IAAIC,EAAE,EAAEC,EAAE;IACV,MAAMC,SAAS,GAAGJ,UAAU,CAACK,KAAK,CAAC,GAAG,CAAC,CAACC,MAAM,CAAEC,CAAC,IAAKA,CAAC,CAACC,MAAM,GAAG,CAAC,CAAC;IACnE,MAAMC,OAAO,GAAG,CAACP,EAAE,GAAGE,SAAS,CAAC,CAAC,CAAC,MAAM,IAAI,IAAIF,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,EAAE;IACvE,MAAMQ,MAAM,GAAG,CAACP,EAAE,GAAGC,SAAS,CAAC,CAAC,CAAC,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,EAAE;IACtE,IAAIL,aAAa,IAAIA,aAAa,CAACa,YAAY,EAAE;MAC7C,KAAK,MAAMA,YAAY,IAAIb,aAAa,CAACa,YAAY,EAAE;QACnD,KAAK,MAAMC,IAAI,IAAID,YAAY,CAACC,IAAI,EAAE;UAClC,IAAIA,IAAI,CAACH,OAAO,KAAKA,OAAO,KACvBG,IAAI,CAACF,MAAM,KAAKG,SAAS,IAAID,IAAI,CAACF,MAAM,KAAKA,MAAM,CAAC,EAAE;YACvD,OAAO;cACHC,YAAY,EAAEA,YAAY;cAC1BG,eAAe,EAAE,CAAC,CAAC;cACnBC,MAAM,EAAE9B,WAAW,CAAC+B,MAAM,CAACC,EAAE;cAC7BC,sBAAsB,EAAE;YAC5B,CAAC;UACL;QACJ;MACJ;IACJ;IACA,OAAO;MACHP,YAAY,EAAE;QAAEC,IAAI,EAAE;MAAG,CAAC;MAC1BE,eAAe,EAAE,CAAC,CAAC;MACnBC,MAAM,EAAE9B,WAAW,CAAC+B,MAAM,CAACC,EAAE;MAC7BC,sBAAsB,EAAE;IAC5B,CAAC;EACL,CAAC;AACL;AACA,MAAMzC,qBAAqB,CAAC;EACxB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI0C,WAAW,CAACC,MAAM,EAAEC,oBAAoB,EAAEC,cAAc,EAAEC,sBAAsB,EAAEC,kBAAkB,EAAE;IAClG,IAAI,CAACJ,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,oBAAoB,GAAGA,oBAAoB;IAChD,IAAI,CAACC,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,sBAAsB,GAAGA,sBAAsB;IACpD,IAAI,CAACC,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACC,gBAAgB,GAAG5C,oBAAoB,CAAC6C,iBAAiB,CAACC,IAAI;IACnE,IAAI,CAACC,iBAAiB,GAAG,IAAI7C,QAAQ,CAAC8C,WAAW,CAAC,IAAI,CAAC;IACvD;AACR;AACA;IACQ,IAAI,CAACC,YAAY,GAAGjD,oBAAoB,CAAC6C,iBAAiB,CAACC,IAAI;IAC/D;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACI,qBAAqB,GAAG,IAAI;IACjC;AACR;AACA;AACA;IACQ,IAAI,CAACC,iBAAiB,GAAG,KAAK;IAC9B,IAAIV,cAAc,CAAC,qBAAqB,CAAC,EAAE;MACvC,IAAI,CAACW,oBAAoB,GAAGrD,gBAAgB,CAACsD,qBAAqB,CAACC,IAAI,CAACC,KAAK,CAACd,cAAc,CAAC,qBAAqB,CAAC,CAAC,CAAC;IACzH,CAAC,MACI;MACD,IAAI,CAACW,oBAAoB,GAAG;QACxBI,mBAAmB,EAAE,EAAE;QACvB1B,YAAY,EAAE;MAClB,CAAC;IACL;IACA,IAAI,CAAC2B,WAAW,CAACzD,oBAAoB,CAAC6C,iBAAiB,CAACC,IAAI,EAAE,IAAI5C,QAAQ,CAAC8C,WAAW,CAAC,IAAI,CAAC,CAAC;IAC7F,IAAI,CAACU,iBAAiB,GAAG,IAAIjD,6BAA6B,CAACkD,wBAAwB,CAAC;MAChFC,gBAAgB,EAAEpB,oBAAoB,CAACoB,gBAAgB,CAACC,IAAI,CAACrB,oBAAoB,CAAC;MAClFsB,mBAAmB,EAAE,MAAM;QACvB;AAChB;AACA;AACA;QACgB,IAAI,IAAI,CAACC,cAAc,CAACC,SAAS,EAAE,EAAE;UACjC,IAAI,CAACb,iBAAiB,GAAG,IAAI;QACjC,CAAC,MACI;UACD,IAAI,CAACc,gBAAgB,EAAE;QAC3B;MACJ,CAAC;MACDR,WAAW,EAAE,CAACS,QAAQ,EAAEC,MAAM,KAAK;QAC/B,IAAI,CAACvB,gBAAgB,GAAGsB,QAAQ;QAChC,IAAI,CAACnB,iBAAiB,GAAGoB,MAAM;QAC/B,IAAI,CAACV,WAAW,CAACS,QAAQ,EAAEC,MAAM,CAAC;MACtC,CAAC;MACDC,gBAAgB,EAAE5B,oBAAoB,CAAC4B,gBAAgB,CAACP,IAAI,CAACrB,oBAAoB,CAAC;MAClF6B,mBAAmB,EAAE7B,oBAAoB,CAAC6B,mBAAmB,CAACR,IAAI,CAACrB,oBAAoB;IAC3F,CAAC,CAAC;IACF,IAAI,CAAC8B,aAAa,GAAGrE,UAAU,CAACsE,cAAc,CAAChC,MAAM,EAAE;MACnDG,sBAAsB,EAAE,CAAC8B,WAAW,EAAEvD,aAAa,EAAEwD,kBAAkB,EAAEC,cAAc,EAAEC,UAAU,KAAK;QACpG,IAAItD,EAAE;QACN,IAAIuD,oBAAoB,GAAG,IAAI;QAC/B;AAChB;AACA;AACA;QACgB,IAAI3D,aAAa,KAAK,IAAI,EAAE;UACxB;UACA,IAAIwD,kBAAkB,KAAK,IAAI,EAAE;YAC7B;YACA,IAAI,CAACvB,qBAAqB,GAAG,IAAI;YACjC0B,oBAAoB,GAAG,IAAI,CAACxB,oBAAoB;UACpD,CAAC,MACI;YACD;YACA,IAAI,IAAI,CAACF,qBAAqB,KAAK,IAAI,EAAE;cACrC;cACA,IAAI,CAAC2B,uBAAuB,CAACJ,kBAAkB,CAAC;YACpD,CAAC,MACI;cACD;cACAG,oBAAoB,GAAG,IAAI,CAAC1B,qBAAqB;YACrD;UACJ;QACJ,CAAC,MACI;UACD;UACA0B,oBAAoB,GAAG3D,aAAa;UACpC,IAAI,CAACiC,qBAAqB,GAAGjC,aAAa;QAC9C;QACA,MAAM6D,iBAAiB,GAAG,CAACzD,EAAE,GAAGuD,oBAAoB,KAAK,IAAI,IAAIA,oBAAoB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,oBAAoB,CAACpB,mBAAmB,MAAM,IAAI,IAAInC,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,EAAE;QACzL,MAAMmC,mBAAmB,GAAG3D,eAAe,CAACkF,oBAAoB,CAACD,iBAAiB,EAAE,IAAI,CAAC;QACzF,IAAItB,mBAAmB,KAAK,IAAI,EAAE;UAC9B;UACA,IAAI,CAACqB,uBAAuB,CAAC;YACzBG,IAAI,EAAE5E,WAAW,CAAC+B,MAAM,CAAC8C,WAAW;YACpCC,OAAO,EAAE,gEAAgE;YACzE9D,QAAQ,EAAE,IAAIf,UAAU,CAAC8E,QAAQ;UACrC,CAAC,CAAC;UACF;QACJ;QACA,IAAI,CAACzB,iBAAiB,CAAC0B,iBAAiB,CAACZ,WAAW,EAAEhB,mBAAmB,EAAEmB,UAAU,CAAC;QACtF,MAAMU,kBAAkB,GAAGT,oBAAoB,KAAK,IAAI,IAAIA,oBAAoB,KAAK,KAAK,CAAC,GAAGA,oBAAoB,GAAG,IAAI,CAACxB,oBAAoB;QAC9I,IAAI,CAACV,sBAAsB,CAACgC,cAAc,KAAK,IAAI,IAAIA,cAAc,KAAK,KAAK,CAAC,GAAGA,cAAc,GAAG1D,wBAAwB,CAACqE,kBAAkB,CAAC,CAAC;MACrJ,CAAC;MACDC,OAAO,EAAGC,KAAK,IAAK;QAChB,IAAI,CAACV,uBAAuB,CAACU,KAAK,CAAC;MACvC;IACJ,CAAC,EAAE9C,cAAc,CAAC;IAClB,MAAM+C,cAAc,GAAG;MACnBC,YAAY,EAAEhD,cAAc,CAAC,mCAAmC,CAAC;MACjEiD,QAAQ,EAAEjD,cAAc,CAAC,+BAA+B;IAC5D,CAAC;IACD,IAAI,CAACsB,cAAc,GAAG,IAAI5D,iBAAiB,CAACwF,cAAc,CAAC,MAAM;MAC7D,IAAI,IAAI,CAACxC,iBAAiB,EAAE;QACxB,IAAI,CAACc,gBAAgB,EAAE;QACvB,IAAI,CAACd,iBAAiB,GAAG,KAAK;MAClC,CAAC,MACI;QACD,IAAI,CAACM,WAAW,CAAC,IAAI,CAACb,gBAAgB,EAAE,IAAI,CAACG,iBAAiB,CAAC;MACnE;IACJ,CAAC,EAAEyC,cAAc,CAAC;IAClB,IAAI,CAACzB,cAAc,CAAC6B,KAAK,EAAE;EAC/B;EACA3B,gBAAgB,GAAG;IACf,IAAI,CAACK,aAAa,CAACL,gBAAgB,EAAE;IACrC,IAAI,IAAI,CAAChB,YAAY,KAAKjD,oBAAoB,CAAC6C,iBAAiB,CAACC,IAAI,EAAE;MACnE,IAAI,CAACW,WAAW,CAACzD,oBAAoB,CAAC6C,iBAAiB,CAACgD,UAAU,EAAE,IAAI3F,QAAQ,CAAC8C,WAAW,CAAC,IAAI,CAAC,CAAC;IACvG;IACA,IAAI,CAACe,cAAc,CAAC+B,OAAO,EAAE;EACjC;EACArC,WAAW,CAACsC,iBAAiB,EAAE5B,MAAM,EAAE;IACnCxD,KAAK,CAACH,YAAY,CAACwF,WAAW,CAAC,IAAI,CAACzD,MAAM,CAAC,GACvC,GAAG,GACHvC,oBAAoB,CAAC6C,iBAAiB,CAAC,IAAI,CAACI,YAAY,CAAC,GACzD,MAAM,GACNjD,oBAAoB,CAAC6C,iBAAiB,CAACkD,iBAAiB,CAAC,CAAC;IAC9D;IACA,IAAIA,iBAAiB,KAAK/F,oBAAoB,CAAC6C,iBAAiB,CAACC,IAAI,EAAE;MACnEqB,MAAM,GAAG,IAAIjE,QAAQ,CAAC8C,WAAW,CAAC,IAAI,CAAC;IAC3C;IACA,IAAI,CAACC,YAAY,GAAG8C,iBAAiB;IACrC,IAAI,CAACvD,oBAAoB,CAACiB,WAAW,CAACsC,iBAAiB,EAAE5B,MAAM,CAAC;EACpE;EACAU,uBAAuB,CAACU,KAAK,EAAE;IAC3B,IAAI,IAAI,CAAC3C,gBAAgB,KAAK5C,oBAAoB,CAAC6C,iBAAiB,CAACC,IAAI,EAAE;MACvE,IAAI,CAACW,WAAW,CAACzD,oBAAoB,CAAC6C,iBAAiB,CAACoD,iBAAiB,EAAE,IAAI/F,QAAQ,CAACgG,iBAAiB,CAACX,KAAK,CAAC,CAAC;MACjH,IAAI,CAAC5C,kBAAkB,CAAC4C,KAAK,CAAC;IAClC;EACJ;EACAY,QAAQ,GAAG;IACP,IAAI,IAAI,CAAClD,YAAY,KAAKjD,oBAAoB,CAAC6C,iBAAiB,CAACC,IAAI,IAAI,IAAI,CAACG,YAAY,KAAKjD,oBAAoB,CAAC6C,iBAAiB,CAACoD,iBAAiB,EAAE;MACrJ,IAAI,IAAI,CAAClC,cAAc,CAACC,SAAS,EAAE,EAAE;QACjC,IAAI,CAACb,iBAAiB,GAAG,IAAI;MACjC,CAAC,MACI;QACD,IAAI,CAACc,gBAAgB,EAAE;MAC3B;IACJ;IACA,IAAI,CAACP,iBAAiB,CAACyC,QAAQ,EAAE;EACrC;EACAf,iBAAiB,CAACZ,WAAW,EAAE4B,QAAQ,EAAE;IACrC,MAAM,IAAIC,KAAK,CAAC,0DAA0D,CAAC;EAC/E;EACAC,YAAY,GAAG;IACX,IAAI,CAACvC,cAAc,CAACwC,KAAK,EAAE;IAC3B,IAAI,CAAC7C,iBAAiB,CAAC4C,YAAY,EAAE;EACzC;EACAE,OAAO,GAAG;IACN,IAAI,CAAC9C,iBAAiB,CAAC8C,OAAO,EAAE;IAChC,IAAI,CAAClC,aAAa,CAACkC,OAAO,EAAE;IAC5B,IAAI,CAAC/C,WAAW,CAACzD,oBAAoB,CAAC6C,iBAAiB,CAAC4D,QAAQ,EAAE,IAAIvG,QAAQ,CAACgG,iBAAiB,EAAE,CAAC;EACvG;EACAQ,WAAW,GAAG;IACV,OAAO,yBAAyB;EACpC;AACJ;AACAhH,OAAO,CAACE,qBAAqB,GAAGA,qBAAqB"},"metadata":{},"sourceType":"script","externalDependencies":[]}