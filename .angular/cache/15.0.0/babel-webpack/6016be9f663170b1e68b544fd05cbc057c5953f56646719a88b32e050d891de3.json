{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.configureCompression = exports.GrpcCompressionAlgorithm = exports.useSecureConnection = exports.configureSecurity = exports.validateAndNormalizeUrl = exports.send = exports.onInit = exports.DEFAULT_COLLECTOR_URL = void 0;\nconst grpc = require(\"@grpc/grpc-js\");\nconst protoLoader = require(\"@grpc/proto-loader\");\nconst api_1 = require(\"@opentelemetry/api\");\nconst core_1 = require(\"@opentelemetry/core\");\nconst path = require(\"path\");\nconst url_1 = require(\"url\");\nconst fs = require(\"fs\");\nconst types_1 = require(\"./types\");\nconst otlp_exporter_base_1 = require(\"@opentelemetry/otlp-exporter-base\");\nexports.DEFAULT_COLLECTOR_URL = 'http://localhost:4317';\nfunction onInit(collector, config) {\n  collector.grpcQueue = [];\n  const credentials = configureSecurity(config.credentials, collector.getUrlFromConfig(config));\n  const includeDirs = [path.resolve(__dirname, '..', 'protos')];\n  protoLoader.load(collector.getServiceProtoPath(), {\n    keepCase: false,\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: true,\n    includeDirs\n  }).then(packageDefinition => {\n    const packageObject = grpc.loadPackageDefinition(packageDefinition);\n    const options = {\n      'grpc.default_compression_algorithm': collector.compression\n    };\n    if (collector.getServiceClientType() === types_1.ServiceClientType.SPANS) {\n      collector.serviceClient = new packageObject.opentelemetry.proto.collector.trace.v1.TraceService(collector.url, credentials, options);\n    } else {\n      collector.serviceClient = new packageObject.opentelemetry.proto.collector.metrics.v1.MetricsService(collector.url, credentials, options);\n    }\n    if (collector.grpcQueue.length > 0) {\n      const queue = collector.grpcQueue.splice(0);\n      queue.forEach(item => {\n        collector.send(item.objects, item.onSuccess, item.onError);\n      });\n    }\n  }).catch(err => {\n    (0, core_1.globalErrorHandler)(err);\n  });\n}\nexports.onInit = onInit;\nfunction send(collector, objects, onSuccess, onError) {\n  if (collector.serviceClient) {\n    const serviceRequest = collector.convert(objects);\n    const deadline = Date.now() + collector.timeoutMillis;\n    collector.serviceClient.export(serviceRequest, collector.metadata || new grpc.Metadata(), {\n      deadline: deadline\n    }, err => {\n      if (err) {\n        api_1.diag.error('Service request', serviceRequest);\n        onError(err);\n      } else {\n        api_1.diag.debug('Objects sent');\n        onSuccess();\n      }\n    });\n  } else {\n    collector.grpcQueue.push({\n      objects,\n      onSuccess,\n      onError\n    });\n  }\n}\nexports.send = send;\nfunction validateAndNormalizeUrl(url) {\n  var _a;\n  const hasProtocol = url.match(/^([\\w]{1,8}):\\/\\//);\n  if (!hasProtocol) {\n    url = `https://${url}`;\n  }\n  const target = new url_1.URL(url);\n  if (target.pathname && target.pathname !== '/') {\n    api_1.diag.warn('URL path should not be set when using grpc, the path part of the URL will be ignored.');\n  }\n  if (target.protocol !== '' && !((_a = target.protocol) === null || _a === void 0 ? void 0 : _a.match(/^(http)s?:$/))) {\n    api_1.diag.warn('URL protocol should be http(s)://. Using http://.');\n  }\n  return target.host;\n}\nexports.validateAndNormalizeUrl = validateAndNormalizeUrl;\nfunction configureSecurity(credentials, endpoint) {\n  let insecure;\n  if (credentials) {\n    return credentials;\n  } else if (endpoint.startsWith('https://')) {\n    insecure = false;\n  } else if (endpoint.startsWith('http://') || endpoint === exports.DEFAULT_COLLECTOR_URL) {\n    insecure = true;\n  } else {\n    insecure = getSecurityFromEnv();\n  }\n  if (insecure) {\n    return grpc.credentials.createInsecure();\n  } else {\n    return useSecureConnection();\n  }\n}\nexports.configureSecurity = configureSecurity;\nfunction getSecurityFromEnv() {\n  const definedInsecure = (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_INSECURE || (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_INSECURE;\n  if (definedInsecure) {\n    return definedInsecure.toLowerCase() === 'true';\n  } else {\n    return false;\n  }\n}\nfunction useSecureConnection() {\n  const rootCertPath = retrieveRootCert();\n  const privateKeyPath = retrievePrivateKey();\n  const certChainPath = retrieveCertChain();\n  return grpc.credentials.createSsl(rootCertPath, privateKeyPath, certChainPath);\n}\nexports.useSecureConnection = useSecureConnection;\nfunction retrieveRootCert() {\n  const rootCertificate = (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE || (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_CERTIFICATE;\n  if (rootCertificate) {\n    try {\n      return fs.readFileSync(path.resolve(process.cwd(), rootCertificate));\n    } catch (_a) {\n      api_1.diag.warn('Failed to read root certificate file');\n      return undefined;\n    }\n  } else {\n    return undefined;\n  }\n}\nfunction retrievePrivateKey() {\n  const clientKey = (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY || (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_CLIENT_KEY;\n  if (clientKey) {\n    try {\n      return fs.readFileSync(path.resolve(process.cwd(), clientKey));\n    } catch (_a) {\n      api_1.diag.warn('Failed to read client certificate private key file');\n      return undefined;\n    }\n  } else {\n    return undefined;\n  }\n}\nfunction retrieveCertChain() {\n  const clientChain = (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE || (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE;\n  if (clientChain) {\n    try {\n      return fs.readFileSync(path.resolve(process.cwd(), clientChain));\n    } catch (_a) {\n      api_1.diag.warn('Failed to read client certificate chain file');\n      return undefined;\n    }\n  } else {\n    return undefined;\n  }\n}\nfunction toGrpcCompression(compression) {\n  if (compression === otlp_exporter_base_1.CompressionAlgorithm.NONE) return GrpcCompressionAlgorithm.NONE;else if (compression === otlp_exporter_base_1.CompressionAlgorithm.GZIP) return GrpcCompressionAlgorithm.GZIP;\n  return GrpcCompressionAlgorithm.NONE;\n}\n/**\n * These values are defined by grpc client\n */\nvar GrpcCompressionAlgorithm;\n(function (GrpcCompressionAlgorithm) {\n  GrpcCompressionAlgorithm[GrpcCompressionAlgorithm[\"NONE\"] = 0] = \"NONE\";\n  GrpcCompressionAlgorithm[GrpcCompressionAlgorithm[\"GZIP\"] = 2] = \"GZIP\";\n})(GrpcCompressionAlgorithm = exports.GrpcCompressionAlgorithm || (exports.GrpcCompressionAlgorithm = {}));\nfunction configureCompression(compression) {\n  if (compression) {\n    return toGrpcCompression(compression);\n  } else {\n    const definedCompression = (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_COMPRESSION || (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_COMPRESSION;\n    return definedCompression === 'gzip' ? GrpcCompressionAlgorithm.GZIP : GrpcCompressionAlgorithm.NONE;\n  }\n}\nexports.configureCompression = configureCompression;\n//# sourceMappingURL=util.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}