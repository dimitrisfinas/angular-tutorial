{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = void 0;\nconst resolver_1 = require(\"./resolver\");\nconst dns = require(\"dns\");\nconst util = require(\"util\");\nconst service_config_1 = require(\"./service-config\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst net_1 = require(\"net\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst TRACER_NAME = 'dns_resolver';\nfunction trace(text) {\n  logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nconst DEFAULT_PORT = 443;\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;\nconst resolveTxtPromise = util.promisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */\nfunction mergeArrays(...arrays) {\n  const result = [];\n  for (let i = 0; i < Math.max.apply(null, arrays.map(array => array.length)); i++) {\n    for (const array of arrays) {\n      if (i < array.length) {\n        result.push(array[i]);\n      }\n    }\n  }\n  return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\nclass DnsResolver {\n  constructor(target, listener, channelOptions) {\n    var _a, _b, _c;\n    this.target = target;\n    this.listener = listener;\n    this.pendingLookupPromise = null;\n    this.pendingTxtPromise = null;\n    this.latestLookupResult = null;\n    this.latestServiceConfig = null;\n    this.latestServiceConfigError = null;\n    this.continueResolving = false;\n    this.isNextResolutionTimerRunning = false;\n    trace('Resolver constructed for target ' + uri_parser_1.uriToString(target));\n    const hostPort = uri_parser_1.splitHostPort(target.path);\n    if (hostPort === null) {\n      this.ipResult = null;\n      this.dnsHostname = null;\n      this.port = null;\n    } else {\n      if (net_1.isIPv4(hostPort.host) || net_1.isIPv6(hostPort.host)) {\n        this.ipResult = [{\n          host: hostPort.host,\n          port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT\n        }];\n        this.dnsHostname = null;\n        this.port = null;\n      } else {\n        this.ipResult = null;\n        this.dnsHostname = hostPort.host;\n        this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : DEFAULT_PORT;\n      }\n    }\n    this.percentage = Math.random() * 100;\n    this.defaultResolutionError = {\n      code: constants_1.Status.UNAVAILABLE,\n      details: `Name resolution failed for target ${uri_parser_1.uriToString(this.target)}`,\n      metadata: new metadata_1.Metadata()\n    };\n    const backoffOptions = {\n      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoff = new backoff_timeout_1.BackoffTimeout(() => {\n      if (this.continueResolving) {\n        this.startResolutionWithBackoff();\n      }\n    }, backoffOptions);\n    this.backoff.unref();\n    this.minTimeBetweenResolutionsMs = (_c = channelOptions['grpc.dns_min_time_between_resolutions_ms']) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\n    this.nextResolutionTimer = setTimeout(() => {}, 0);\n    clearTimeout(this.nextResolutionTimer);\n  }\n  /**\n   * If the target is an IP address, just provide that address as a result.\n   * Otherwise, initiate A, AAAA, and TXT lookups\n   */\n  startResolution() {\n    if (this.ipResult !== null) {\n      trace('Returning IP address for target ' + uri_parser_1.uriToString(this.target));\n      setImmediate(() => {\n        this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\n      });\n      this.backoff.stop();\n      this.backoff.reset();\n      return;\n    }\n    if (this.dnsHostname === null) {\n      trace('Failed to parse DNS address ' + uri_parser_1.uriToString(this.target));\n      setImmediate(() => {\n        this.listener.onError({\n          code: constants_1.Status.UNAVAILABLE,\n          details: `Failed to parse DNS address ${uri_parser_1.uriToString(this.target)}`,\n          metadata: new metadata_1.Metadata()\n        });\n      });\n      this.stopNextResolutionTimer();\n    } else {\n      if (this.pendingLookupPromise !== null) {\n        return;\n      }\n      trace('Looking up DNS hostname ' + this.dnsHostname);\n      /* We clear out latestLookupResult here to ensure that it contains the\n       * latest result since the last time we started resolving. That way, the\n       * TXT resolution handler can use it, but only if it finishes second. We\n       * don't clear out any previous service config results because it's\n       * better to use a service config that's slightly out of date than to\n       * revert to an effectively blank one. */\n      this.latestLookupResult = null;\n      const hostname = this.dnsHostname;\n      /* We lookup both address families here and then split them up later\n       * because when looking up a single family, dns.lookup outputs an error\n       * if the name exists but there are no records for that family, and that\n       * error is indistinguishable from other kinds of errors */\n      this.pendingLookupPromise = dnsLookupPromise(hostname, {\n        all: true\n      });\n      this.pendingLookupPromise.then(addressList => {\n        this.pendingLookupPromise = null;\n        this.backoff.reset();\n        this.backoff.stop();\n        const ip4Addresses = addressList.filter(addr => addr.family === 4);\n        const ip6Addresses = addressList.filter(addr => addr.family === 6);\n        this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map(addr => ({\n          host: addr.address,\n          port: +this.port\n        }));\n        const allAddressesString = '[' + this.latestLookupResult.map(addr => addr.host + ':' + addr.port).join(',') + ']';\n        trace('Resolved addresses for target ' + uri_parser_1.uriToString(this.target) + ': ' + allAddressesString);\n        if (this.latestLookupResult.length === 0) {\n          this.listener.onError(this.defaultResolutionError);\n          return;\n        }\n        /* If the TXT lookup has not yet finished, both of the last two\n         * arguments will be null, which is the equivalent of getting an\n         * empty TXT response. When the TXT lookup does finish, its handler\n         * can update the service config by using the same address list */\n        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n      }, err => {\n        trace('Resolution error for target ' + uri_parser_1.uriToString(this.target) + ': ' + err.message);\n        this.pendingLookupPromise = null;\n        this.stopNextResolutionTimer();\n        this.listener.onError(this.defaultResolutionError);\n      });\n      /* If there already is a still-pending TXT resolution, we can just use\n       * that result when it comes in */\n      if (this.pendingTxtPromise === null) {\n        /* We handle the TXT query promise differently than the others because\n         * the name resolution attempt as a whole is a success even if the TXT\n         * lookup fails */\n        this.pendingTxtPromise = resolveTxtPromise(hostname);\n        this.pendingTxtPromise.then(txtRecord => {\n          this.pendingTxtPromise = null;\n          try {\n            this.latestServiceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, this.percentage);\n          } catch (err) {\n            this.latestServiceConfigError = {\n              code: constants_1.Status.UNAVAILABLE,\n              details: 'Parsing service config failed',\n              metadata: new metadata_1.Metadata()\n            };\n          }\n          if (this.latestLookupResult !== null) {\n            /* We rely here on the assumption that calling this function with\n             * identical parameters will be essentialy idempotent, and calling\n             * it with the same address list and a different service config\n             * should result in a fast and seamless switchover. */\n            this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n          }\n        }, err => {\n          /* If TXT lookup fails we should do nothing, which means that we\n           * continue to use the result of the most recent successful lookup,\n           * or the default null config object if there has never been a\n           * successful lookup. We do not set the latestServiceConfigError\n           * here because that is specifically used for response validation\n           * errors. We still need to handle this error so that it does not\n           * bubble up as an unhandled promise rejection. */\n        });\n      }\n    }\n  }\n  startNextResolutionTimer() {\n    var _a, _b;\n    clearTimeout(this.nextResolutionTimer);\n    this.nextResolutionTimer = (_b = (_a = setTimeout(() => {\n      this.stopNextResolutionTimer();\n      if (this.continueResolving) {\n        this.startResolutionWithBackoff();\n      }\n    }, this.minTimeBetweenResolutionsMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    this.isNextResolutionTimerRunning = true;\n  }\n  stopNextResolutionTimer() {\n    clearTimeout(this.nextResolutionTimer);\n    this.isNextResolutionTimerRunning = false;\n  }\n  startResolutionWithBackoff() {\n    if (this.pendingLookupPromise === null) {\n      this.continueResolving = false;\n      this.startResolution();\n      this.backoff.runOnce();\n      this.startNextResolutionTimer();\n    }\n  }\n  updateResolution() {\n    /* If there is a pending lookup, just let it finish. Otherwise, if the\n     * nextResolutionTimer or backoff timer is running, set the\n     * continueResolving flag to resolve when whichever of those timers\n     * fires. Otherwise, start resolving immediately. */\n    if (this.pendingLookupPromise === null) {\n      if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\n        this.continueResolving = true;\n      } else {\n        this.startResolutionWithBackoff();\n      }\n    }\n  }\n  destroy() {\n    this.continueResolving = false;\n    this.backoff.stop();\n    this.stopNextResolutionTimer();\n  }\n  /**\n   * Get the default authority for the given target. For IP targets, that is\n   * the IP address. For DNS targets, it is the hostname.\n   * @param target\n   */\n  static getDefaultAuthority(target) {\n    return target.path;\n  }\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\nfunction setup() {\n  resolver_1.registerResolver('dns', DnsResolver);\n  resolver_1.registerDefaultScheme('dns');\n}\nexports.setup = setup;","map":{"version":3,"names":["Object","defineProperty","exports","value","setup","resolver_1","require","dns","util","service_config_1","constants_1","metadata_1","logging","constants_2","uri_parser_1","net_1","backoff_timeout_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","DEFAULT_PORT","DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS","resolveTxtPromise","promisify","resolveTxt","dnsLookupPromise","lookup","mergeArrays","arrays","result","i","Math","max","apply","map","array","length","push","DnsResolver","constructor","target","listener","channelOptions","_a","_b","_c","pendingLookupPromise","pendingTxtPromise","latestLookupResult","latestServiceConfig","latestServiceConfigError","continueResolving","isNextResolutionTimerRunning","uriToString","hostPort","splitHostPort","path","ipResult","dnsHostname","port","isIPv4","host","isIPv6","percentage","random","defaultResolutionError","code","Status","UNAVAILABLE","details","metadata","Metadata","backoffOptions","initialDelay","maxDelay","backoff","BackoffTimeout","startResolutionWithBackoff","unref","minTimeBetweenResolutionsMs","nextResolutionTimer","setTimeout","clearTimeout","startResolution","setImmediate","onSuccessfulResolution","stop","reset","onError","stopNextResolutionTimer","hostname","all","then","addressList","ip4Addresses","filter","addr","family","ip6Addresses","address","allAddressesString","join","err","message","txtRecord","extractAndSelectServiceConfig","startNextResolutionTimer","call","runOnce","updateResolution","isRunning","destroy","getDefaultAuthority","registerResolver","registerDefaultScheme"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/resolver-dns.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setup = void 0;\nconst resolver_1 = require(\"./resolver\");\nconst dns = require(\"dns\");\nconst util = require(\"util\");\nconst service_config_1 = require(\"./service-config\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst net_1 = require(\"net\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst TRACER_NAME = 'dns_resolver';\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nconst DEFAULT_PORT = 443;\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;\nconst resolveTxtPromise = util.promisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */\nfunction mergeArrays(...arrays) {\n    const result = [];\n    for (let i = 0; i <\n        Math.max.apply(null, arrays.map((array) => array.length)); i++) {\n        for (const array of arrays) {\n            if (i < array.length) {\n                result.push(array[i]);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\nclass DnsResolver {\n    constructor(target, listener, channelOptions) {\n        var _a, _b, _c;\n        this.target = target;\n        this.listener = listener;\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfig = null;\n        this.latestServiceConfigError = null;\n        this.continueResolving = false;\n        this.isNextResolutionTimerRunning = false;\n        trace('Resolver constructed for target ' + uri_parser_1.uriToString(target));\n        const hostPort = uri_parser_1.splitHostPort(target.path);\n        if (hostPort === null) {\n            this.ipResult = null;\n            this.dnsHostname = null;\n            this.port = null;\n        }\n        else {\n            if (net_1.isIPv4(hostPort.host) || net_1.isIPv6(hostPort.host)) {\n                this.ipResult = [\n                    {\n                        host: hostPort.host,\n                        port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT,\n                    },\n                ];\n                this.dnsHostname = null;\n                this.port = null;\n            }\n            else {\n                this.ipResult = null;\n                this.dnsHostname = hostPort.host;\n                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : DEFAULT_PORT;\n            }\n        }\n        this.percentage = Math.random() * 100;\n        this.defaultResolutionError = {\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Name resolution failed for target ${uri_parser_1.uriToString(this.target)}`,\n            metadata: new metadata_1.Metadata(),\n        };\n        const backoffOptions = {\n            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoff = new backoff_timeout_1.BackoffTimeout(() => {\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, backoffOptions);\n        this.backoff.unref();\n        this.minTimeBetweenResolutionsMs = (_c = channelOptions['grpc.dns_min_time_between_resolutions_ms']) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\n        this.nextResolutionTimer = setTimeout(() => { }, 0);\n        clearTimeout(this.nextResolutionTimer);\n    }\n    /**\n     * If the target is an IP address, just provide that address as a result.\n     * Otherwise, initiate A, AAAA, and TXT lookups\n     */\n    startResolution() {\n        if (this.ipResult !== null) {\n            trace('Returning IP address for target ' + uri_parser_1.uriToString(this.target));\n            setImmediate(() => {\n                this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\n            });\n            this.backoff.stop();\n            this.backoff.reset();\n            return;\n        }\n        if (this.dnsHostname === null) {\n            trace('Failed to parse DNS address ' + uri_parser_1.uriToString(this.target));\n            setImmediate(() => {\n                this.listener.onError({\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse DNS address ${uri_parser_1.uriToString(this.target)}`,\n                    metadata: new metadata_1.Metadata(),\n                });\n            });\n            this.stopNextResolutionTimer();\n        }\n        else {\n            if (this.pendingLookupPromise !== null) {\n                return;\n            }\n            trace('Looking up DNS hostname ' + this.dnsHostname);\n            /* We clear out latestLookupResult here to ensure that it contains the\n             * latest result since the last time we started resolving. That way, the\n             * TXT resolution handler can use it, but only if it finishes second. We\n             * don't clear out any previous service config results because it's\n             * better to use a service config that's slightly out of date than to\n             * revert to an effectively blank one. */\n            this.latestLookupResult = null;\n            const hostname = this.dnsHostname;\n            /* We lookup both address families here and then split them up later\n             * because when looking up a single family, dns.lookup outputs an error\n             * if the name exists but there are no records for that family, and that\n             * error is indistinguishable from other kinds of errors */\n            this.pendingLookupPromise = dnsLookupPromise(hostname, { all: true });\n            this.pendingLookupPromise.then((addressList) => {\n                this.pendingLookupPromise = null;\n                this.backoff.reset();\n                this.backoff.stop();\n                const ip4Addresses = addressList.filter((addr) => addr.family === 4);\n                const ip6Addresses = addressList.filter((addr) => addr.family === 6);\n                this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map((addr) => ({ host: addr.address, port: +this.port }));\n                const allAddressesString = '[' +\n                    this.latestLookupResult\n                        .map((addr) => addr.host + ':' + addr.port)\n                        .join(',') +\n                    ']';\n                trace('Resolved addresses for target ' +\n                    uri_parser_1.uriToString(this.target) +\n                    ': ' +\n                    allAddressesString);\n                if (this.latestLookupResult.length === 0) {\n                    this.listener.onError(this.defaultResolutionError);\n                    return;\n                }\n                /* If the TXT lookup has not yet finished, both of the last two\n                 * arguments will be null, which is the equivalent of getting an\n                 * empty TXT response. When the TXT lookup does finish, its handler\n                 * can update the service config by using the same address list */\n                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n            }, (err) => {\n                trace('Resolution error for target ' +\n                    uri_parser_1.uriToString(this.target) +\n                    ': ' +\n                    err.message);\n                this.pendingLookupPromise = null;\n                this.stopNextResolutionTimer();\n                this.listener.onError(this.defaultResolutionError);\n            });\n            /* If there already is a still-pending TXT resolution, we can just use\n             * that result when it comes in */\n            if (this.pendingTxtPromise === null) {\n                /* We handle the TXT query promise differently than the others because\n                 * the name resolution attempt as a whole is a success even if the TXT\n                 * lookup fails */\n                this.pendingTxtPromise = resolveTxtPromise(hostname);\n                this.pendingTxtPromise.then((txtRecord) => {\n                    this.pendingTxtPromise = null;\n                    try {\n                        this.latestServiceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, this.percentage);\n                    }\n                    catch (err) {\n                        this.latestServiceConfigError = {\n                            code: constants_1.Status.UNAVAILABLE,\n                            details: 'Parsing service config failed',\n                            metadata: new metadata_1.Metadata(),\n                        };\n                    }\n                    if (this.latestLookupResult !== null) {\n                        /* We rely here on the assumption that calling this function with\n                         * identical parameters will be essentialy idempotent, and calling\n                         * it with the same address list and a different service config\n                         * should result in a fast and seamless switchover. */\n                        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n                    }\n                }, (err) => {\n                    /* If TXT lookup fails we should do nothing, which means that we\n                     * continue to use the result of the most recent successful lookup,\n                     * or the default null config object if there has never been a\n                     * successful lookup. We do not set the latestServiceConfigError\n                     * here because that is specifically used for response validation\n                     * errors. We still need to handle this error so that it does not\n                     * bubble up as an unhandled promise rejection. */\n                });\n            }\n        }\n    }\n    startNextResolutionTimer() {\n        var _a, _b;\n        clearTimeout(this.nextResolutionTimer);\n        this.nextResolutionTimer = (_b = (_a = setTimeout(() => {\n            this.stopNextResolutionTimer();\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, this.minTimeBetweenResolutionsMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.isNextResolutionTimerRunning = true;\n    }\n    stopNextResolutionTimer() {\n        clearTimeout(this.nextResolutionTimer);\n        this.isNextResolutionTimerRunning = false;\n    }\n    startResolutionWithBackoff() {\n        if (this.pendingLookupPromise === null) {\n            this.continueResolving = false;\n            this.startResolution();\n            this.backoff.runOnce();\n            this.startNextResolutionTimer();\n        }\n    }\n    updateResolution() {\n        /* If there is a pending lookup, just let it finish. Otherwise, if the\n         * nextResolutionTimer or backoff timer is running, set the\n         * continueResolving flag to resolve when whichever of those timers\n         * fires. Otherwise, start resolving immediately. */\n        if (this.pendingLookupPromise === null) {\n            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\n                this.continueResolving = true;\n            }\n            else {\n                this.startResolutionWithBackoff();\n            }\n        }\n    }\n    destroy() {\n        this.continueResolving = false;\n        this.backoff.stop();\n        this.stopNextResolutionTimer();\n    }\n    /**\n     * Get the default authority for the given target. For IP targets, that is\n     * the IP address. For DNS targets, it is the hostname.\n     * @param target\n     */\n    static getDefaultAuthority(target) {\n        return target.path;\n    }\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\nfunction setup() {\n    resolver_1.registerResolver('dns', DnsResolver);\n    resolver_1.registerDefaultScheme('dns');\n}\nexports.setup = setup;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}