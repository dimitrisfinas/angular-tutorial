{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _asyncToGenerator = require(\"/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DeadlineFilterFactory = exports.DeadlineFilter = void 0;\nconst constants_1 = require(\"./constants\");\nconst filter_1 = require(\"./filter\");\nconst units = [['m', 1], ['S', 1000], ['M', 60 * 1000], ['H', 60 * 60 * 1000]];\nfunction getDeadline(deadline) {\n  const now = new Date().getTime();\n  const timeoutMs = Math.max(deadline - now, 0);\n  for (const [unit, factor] of units) {\n    const amount = timeoutMs / factor;\n    if (amount < 1e8) {\n      return String(Math.ceil(amount)) + unit;\n    }\n  }\n  throw new Error('Deadline is too far in the future');\n}\nclass DeadlineFilter extends filter_1.BaseFilter {\n  constructor(channel, callStream) {\n    super();\n    this.channel = channel;\n    this.callStream = callStream;\n    this.timer = null;\n    this.deadline = Infinity;\n    this.retreiveDeadline();\n    this.runTimer();\n  }\n  retreiveDeadline() {\n    const callDeadline = this.callStream.getDeadline();\n    if (callDeadline instanceof Date) {\n      this.deadline = callDeadline.getTime();\n    } else {\n      this.deadline = callDeadline;\n    }\n  }\n  runTimer() {\n    var _a, _b;\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n    const now = new Date().getTime();\n    const timeout = this.deadline - now;\n    if (timeout <= 0) {\n      process.nextTick(() => {\n        this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n      });\n    } else if (this.deadline !== Infinity) {\n      this.timer = setTimeout(() => {\n        this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n      }, timeout);\n      (_b = (_a = this.timer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n  refresh() {\n    this.retreiveDeadline();\n    this.runTimer();\n  }\n  sendMetadata(metadata) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.deadline === Infinity) {\n        return metadata;\n      }\n      /* The input metadata promise depends on the original channel.connect()\n       * promise, so when it is complete that implies that the channel is\n       * connected */\n      const finalMetadata = yield metadata;\n      const timeoutString = getDeadline(_this.deadline);\n      finalMetadata.set('grpc-timeout', timeoutString);\n      return finalMetadata;\n    })();\n  }\n  receiveTrailers(status) {\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n    return status;\n  }\n}\nexports.DeadlineFilter = DeadlineFilter;\nclass DeadlineFilterFactory {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  createFilter(callStream) {\n    return new DeadlineFilter(this.channel, callStream);\n  }\n}\nexports.DeadlineFilterFactory = DeadlineFilterFactory;","map":{"version":3,"names":["Object","defineProperty","exports","value","DeadlineFilterFactory","DeadlineFilter","constants_1","require","filter_1","units","getDeadline","deadline","now","Date","getTime","timeoutMs","Math","max","unit","factor","amount","String","ceil","Error","BaseFilter","constructor","channel","callStream","timer","Infinity","retreiveDeadline","runTimer","callDeadline","_a","_b","clearTimeout","timeout","process","nextTick","cancelWithStatus","Status","DEADLINE_EXCEEDED","setTimeout","unref","call","refresh","sendMetadata","metadata","finalMetadata","timeoutString","set","receiveTrailers","status","createFilter"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/deadline-filter.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DeadlineFilterFactory = exports.DeadlineFilter = void 0;\nconst constants_1 = require(\"./constants\");\nconst filter_1 = require(\"./filter\");\nconst units = [\n    ['m', 1],\n    ['S', 1000],\n    ['M', 60 * 1000],\n    ['H', 60 * 60 * 1000],\n];\nfunction getDeadline(deadline) {\n    const now = new Date().getTime();\n    const timeoutMs = Math.max(deadline - now, 0);\n    for (const [unit, factor] of units) {\n        const amount = timeoutMs / factor;\n        if (amount < 1e8) {\n            return String(Math.ceil(amount)) + unit;\n        }\n    }\n    throw new Error('Deadline is too far in the future');\n}\nclass DeadlineFilter extends filter_1.BaseFilter {\n    constructor(channel, callStream) {\n        super();\n        this.channel = channel;\n        this.callStream = callStream;\n        this.timer = null;\n        this.deadline = Infinity;\n        this.retreiveDeadline();\n        this.runTimer();\n    }\n    retreiveDeadline() {\n        const callDeadline = this.callStream.getDeadline();\n        if (callDeadline instanceof Date) {\n            this.deadline = callDeadline.getTime();\n        }\n        else {\n            this.deadline = callDeadline;\n        }\n    }\n    runTimer() {\n        var _a, _b;\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        const now = new Date().getTime();\n        const timeout = this.deadline - now;\n        if (timeout <= 0) {\n            process.nextTick(() => {\n                this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n            });\n        }\n        else if (this.deadline !== Infinity) {\n            this.timer = setTimeout(() => {\n                this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n            }, timeout);\n            (_b = (_a = this.timer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    refresh() {\n        this.retreiveDeadline();\n        this.runTimer();\n    }\n    async sendMetadata(metadata) {\n        if (this.deadline === Infinity) {\n            return metadata;\n        }\n        /* The input metadata promise depends on the original channel.connect()\n         * promise, so when it is complete that implies that the channel is\n         * connected */\n        const finalMetadata = await metadata;\n        const timeoutString = getDeadline(this.deadline);\n        finalMetadata.set('grpc-timeout', timeoutString);\n        return finalMetadata;\n    }\n    receiveTrailers(status) {\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        return status;\n    }\n}\nexports.DeadlineFilter = DeadlineFilter;\nclass DeadlineFilterFactory {\n    constructor(channel) {\n        this.channel = channel;\n    }\n    createFilter(callStream) {\n        return new DeadlineFilter(this.channel, callStream);\n    }\n}\nexports.DeadlineFilterFactory = DeadlineFilterFactory;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}