{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { diag } from '@opentelemetry/api';\nexport function sanitizeAttributes(attributes) {\n  var e_1, _a;\n  var out = {};\n  if (typeof attributes !== 'object' || attributes == null) {\n    return out;\n  }\n  try {\n    for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var _d = __read(_c.value, 2),\n        key = _d[0],\n        val = _d[1];\n      if (!isAttributeKey(key)) {\n        diag.warn(\"Invalid attribute key: \" + key);\n        continue;\n      }\n      if (!isAttributeValue(val)) {\n        diag.warn(\"Invalid attribute value set for key: \" + key);\n        continue;\n      }\n      if (Array.isArray(val)) {\n        out[key] = val.slice();\n      } else {\n        out[key] = val;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return out;\n}\nexport function isAttributeKey(key) {\n  return typeof key === 'string' && key.length > 0;\n}\nexport function isAttributeValue(val) {\n  if (val == null) {\n    return true;\n  }\n  if (Array.isArray(val)) {\n    return isHomogeneousAttributeValueArray(val);\n  }\n  return isValidPrimitiveAttributeValue(val);\n}\nfunction isHomogeneousAttributeValueArray(arr) {\n  var e_2, _a;\n  var type;\n  try {\n    for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {\n      var element = arr_1_1.value;\n      // null/undefined elements are allowed\n      if (element == null) continue;\n      if (!type) {\n        if (isValidPrimitiveAttributeValue(element)) {\n          type = typeof element;\n          continue;\n        }\n        // encountered an invalid primitive\n        return false;\n      }\n      if (typeof element === type) {\n        continue;\n      }\n      return false;\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n  return true;\n}\nfunction isValidPrimitiveAttributeValue(val) {\n  switch (typeof val) {\n    case 'number':\n    case 'boolean':\n    case 'string':\n      return true;\n  }\n  return false;\n}","map":{"version":3,"names":["__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","__read","n","r","ar","e","push","error","diag","sanitizeAttributes","attributes","e_1","_a","out","_b","Object","entries","_c","_d","key","val","isAttributeKey","warn","isAttributeValue","Array","isArray","slice","e_1_1","return","isHomogeneousAttributeValueArray","isValidPrimitiveAttributeValue","arr","e_2","type","arr_1","arr_1_1","element","e_2_1"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@opentelemetry/core/build/esm/common/attributes.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { diag } from '@opentelemetry/api';\nexport function sanitizeAttributes(attributes) {\n    var e_1, _a;\n    var out = {};\n    if (typeof attributes !== 'object' || attributes == null) {\n        return out;\n    }\n    try {\n        for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var _d = __read(_c.value, 2), key = _d[0], val = _d[1];\n            if (!isAttributeKey(key)) {\n                diag.warn(\"Invalid attribute key: \" + key);\n                continue;\n            }\n            if (!isAttributeValue(val)) {\n                diag.warn(\"Invalid attribute value set for key: \" + key);\n                continue;\n            }\n            if (Array.isArray(val)) {\n                out[key] = val.slice();\n            }\n            else {\n                out[key] = val;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return out;\n}\nexport function isAttributeKey(key) {\n    return typeof key === 'string' && key.length > 0;\n}\nexport function isAttributeValue(val) {\n    if (val == null) {\n        return true;\n    }\n    if (Array.isArray(val)) {\n        return isHomogeneousAttributeValueArray(val);\n    }\n    return isValidPrimitiveAttributeValue(val);\n}\nfunction isHomogeneousAttributeValueArray(arr) {\n    var e_2, _a;\n    var type;\n    try {\n        for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {\n            var element = arr_1_1.value;\n            // null/undefined elements are allowed\n            if (element == null)\n                continue;\n            if (!type) {\n                if (isValidPrimitiveAttributeValue(element)) {\n                    type = typeof element;\n                    continue;\n                }\n                // encountered an invalid primitive\n                return false;\n            }\n            if (typeof element === type) {\n                continue;\n            }\n            return false;\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return true;\n}\nfunction isValidPrimitiveAttributeValue(val) {\n    switch (typeof val) {\n        case 'number':\n        case 'boolean':\n        case 'string':\n            return true;\n    }\n    return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}