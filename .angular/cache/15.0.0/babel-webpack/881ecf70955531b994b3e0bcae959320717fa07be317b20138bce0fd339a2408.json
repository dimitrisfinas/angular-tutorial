{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _asyncToGenerator = require(\"/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallCredentialsFilterFactory = exports.CallCredentialsFilter = void 0;\nconst filter_1 = require(\"./filter\");\nconst constants_1 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nclass CallCredentialsFilter extends filter_1.BaseFilter {\n  constructor(channel, stream) {\n    var _a, _b;\n    super();\n    this.channel = channel;\n    this.stream = stream;\n    this.channel = channel;\n    this.stream = stream;\n    const splitPath = stream.getMethod().split('/');\n    let serviceName = '';\n    /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n     * by '/', the first item should be empty and the second should be the\n     * service name */\n    if (splitPath.length >= 2) {\n      serviceName = splitPath[1];\n    }\n    const hostname = (_b = (_a = uri_parser_1.splitHostPort(stream.getHost())) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\n    /* Currently, call credentials are only allowed on HTTPS connections, so we\n     * can assume that the scheme is \"https\" */\n    this.serviceUrl = `https://${hostname}/${serviceName}`;\n  }\n  sendMetadata(metadata) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const credentials = _this.stream.getCredentials();\n      const credsMetadata = credentials.generateMetadata({\n        service_url: _this.serviceUrl\n      });\n      const resultMetadata = yield metadata;\n      try {\n        resultMetadata.merge(yield credsMetadata);\n      } catch (error) {\n        _this.stream.cancelWithStatus(constants_1.Status.UNAUTHENTICATED, `Failed to retrieve auth metadata with error: ${error.message}`);\n        return Promise.reject('Failed to retrieve auth metadata');\n      }\n      if (resultMetadata.get('authorization').length > 1) {\n        _this.stream.cancelWithStatus(constants_1.Status.INTERNAL, '\"authorization\" metadata cannot have multiple values');\n        return Promise.reject('\"authorization\" metadata cannot have multiple values');\n      }\n      return resultMetadata;\n    })();\n  }\n}\nexports.CallCredentialsFilter = CallCredentialsFilter;\nclass CallCredentialsFilterFactory {\n  constructor(channel) {\n    this.channel = channel;\n    this.channel = channel;\n  }\n  createFilter(callStream) {\n    return new CallCredentialsFilter(this.channel, callStream);\n  }\n}\nexports.CallCredentialsFilterFactory = CallCredentialsFilterFactory;","map":{"version":3,"names":["Object","defineProperty","exports","value","CallCredentialsFilterFactory","CallCredentialsFilter","filter_1","require","constants_1","uri_parser_1","BaseFilter","constructor","channel","stream","_a","_b","splitPath","getMethod","split","serviceName","length","hostname","splitHostPort","getHost","host","serviceUrl","sendMetadata","metadata","credentials","getCredentials","credsMetadata","generateMetadata","service_url","resultMetadata","merge","error","cancelWithStatus","Status","UNAUTHENTICATED","message","Promise","reject","get","INTERNAL","createFilter","callStream"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CallCredentialsFilterFactory = exports.CallCredentialsFilter = void 0;\nconst filter_1 = require(\"./filter\");\nconst constants_1 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nclass CallCredentialsFilter extends filter_1.BaseFilter {\n    constructor(channel, stream) {\n        var _a, _b;\n        super();\n        this.channel = channel;\n        this.stream = stream;\n        this.channel = channel;\n        this.stream = stream;\n        const splitPath = stream.getMethod().split('/');\n        let serviceName = '';\n        /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n         * by '/', the first item should be empty and the second should be the\n         * service name */\n        if (splitPath.length >= 2) {\n            serviceName = splitPath[1];\n        }\n        const hostname = (_b = (_a = uri_parser_1.splitHostPort(stream.getHost())) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\n        /* Currently, call credentials are only allowed on HTTPS connections, so we\n         * can assume that the scheme is \"https\" */\n        this.serviceUrl = `https://${hostname}/${serviceName}`;\n    }\n    async sendMetadata(metadata) {\n        const credentials = this.stream.getCredentials();\n        const credsMetadata = credentials.generateMetadata({\n            service_url: this.serviceUrl,\n        });\n        const resultMetadata = await metadata;\n        try {\n            resultMetadata.merge(await credsMetadata);\n        }\n        catch (error) {\n            this.stream.cancelWithStatus(constants_1.Status.UNAUTHENTICATED, `Failed to retrieve auth metadata with error: ${error.message}`);\n            return Promise.reject('Failed to retrieve auth metadata');\n        }\n        if (resultMetadata.get('authorization').length > 1) {\n            this.stream.cancelWithStatus(constants_1.Status.INTERNAL, '\"authorization\" metadata cannot have multiple values');\n            return Promise.reject('\"authorization\" metadata cannot have multiple values');\n        }\n        return resultMetadata;\n    }\n}\nexports.CallCredentialsFilter = CallCredentialsFilter;\nclass CallCredentialsFilterFactory {\n    constructor(channel) {\n        this.channel = channel;\n        this.channel = channel;\n    }\n    createFilter(callStream) {\n        return new CallCredentialsFilter(this.channel, callStream);\n    }\n}\nexports.CallCredentialsFilterFactory = CallCredentialsFilterFactory;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}