{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport { isAttributeValue, hrTime, hrTimeDuration, isTimeInput, timeInputToHrTime } from '@opentelemetry/core';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { ExceptionEventName } from './enums';\n/**\n * This class represents a span.\n */\nvar Span = /** @class */function () {\n  /** Constructs a new Span instance. */\n  function Span(parentTracer, context, spanName, spanContext, kind, parentSpanId, links, startTime) {\n    if (links === void 0) {\n      links = [];\n    }\n    if (startTime === void 0) {\n      startTime = hrTime();\n    }\n    this.attributes = {};\n    this.links = [];\n    this.events = [];\n    this.status = {\n      code: api.SpanStatusCode.UNSET\n    };\n    this.endTime = [0, 0];\n    this._ended = false;\n    this._duration = [-1, -1];\n    this.name = spanName;\n    this._spanContext = spanContext;\n    this.parentSpanId = parentSpanId;\n    this.kind = kind;\n    this.links = links;\n    this.startTime = timeInputToHrTime(startTime);\n    this.resource = parentTracer.resource;\n    this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n    this._spanLimits = parentTracer.getSpanLimits();\n    this._spanProcessor = parentTracer.getActiveSpanProcessor();\n    this._spanProcessor.onStart(this, context);\n    this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;\n  }\n  Span.prototype.spanContext = function () {\n    return this._spanContext;\n  };\n  Span.prototype.setAttribute = function (key, value) {\n    if (value == null || this._isSpanEnded()) return this;\n    if (key.length === 0) {\n      api.diag.warn(\"Invalid attribute key: \" + key);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      api.diag.warn(\"Invalid attribute value set for key: \" + key);\n      return this;\n    }\n    if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  };\n  Span.prototype.setAttributes = function (attributes) {\n    for (var _i = 0, _a = Object.entries(attributes); _i < _a.length; _i++) {\n      var _b = _a[_i],\n        k = _b[0],\n        v = _b[1];\n      this.setAttribute(k, v);\n    }\n    return this;\n  };\n  /**\n   *\n   * @param name Span Name\n   * @param [attributesOrStartTime] Span attributes or start time\n   *     if type is {@type TimeInput} and 3rd param is undefined\n   * @param [startTime] Specified start time for the event\n   */\n  Span.prototype.addEvent = function (name, attributesOrStartTime, startTime) {\n    if (this._isSpanEnded()) return this;\n    if (this.events.length >= this._spanLimits.eventCountLimit) {\n      api.diag.warn('Dropping extra events.');\n      this.events.shift();\n    }\n    if (isTimeInput(attributesOrStartTime)) {\n      if (typeof startTime === 'undefined') {\n        startTime = attributesOrStartTime;\n      }\n      attributesOrStartTime = undefined;\n    }\n    if (typeof startTime === 'undefined') {\n      startTime = hrTime();\n    }\n    this.events.push({\n      name: name,\n      attributes: attributesOrStartTime,\n      time: timeInputToHrTime(startTime)\n    });\n    return this;\n  };\n  Span.prototype.setStatus = function (status) {\n    if (this._isSpanEnded()) return this;\n    this.status = status;\n    return this;\n  };\n  Span.prototype.updateName = function (name) {\n    if (this._isSpanEnded()) return this;\n    this.name = name;\n    return this;\n  };\n  Span.prototype.end = function (endTime) {\n    if (endTime === void 0) {\n      endTime = hrTime();\n    }\n    if (this._isSpanEnded()) {\n      api.diag.error('You can only call end() on a span once.');\n      return;\n    }\n    this._ended = true;\n    this.endTime = timeInputToHrTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n    if (this._duration[0] < 0) {\n      api.diag.warn('Inconsistent start and end time, startTime > endTime', this.startTime, this.endTime);\n    }\n    this._spanProcessor.onEnd(this);\n  };\n  Span.prototype.isRecording = function () {\n    return this._ended === false;\n  };\n  Span.prototype.recordException = function (exception, time) {\n    if (time === void 0) {\n      time = hrTime();\n    }\n    var attributes = {};\n    if (typeof exception === 'string') {\n      attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n    // these are minimum requirements from spec\n    if (attributes[SemanticAttributes.EXCEPTION_TYPE] || attributes[SemanticAttributes.EXCEPTION_MESSAGE]) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      api.diag.warn(\"Failed to record an exception \" + exception);\n    }\n  };\n  Object.defineProperty(Span.prototype, \"duration\", {\n    get: function () {\n      return this._duration;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span.prototype, \"ended\", {\n    get: function () {\n      return this._ended;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Span.prototype._isSpanEnded = function () {\n    if (this._ended) {\n      api.diag.warn(\"Can not execute the operation on ended Span {traceId: \" + this._spanContext.traceId + \", spanId: \" + this._spanContext.spanId + \"}\");\n    }\n    return this._ended;\n  };\n  // Utility function to truncate given value within size\n  // for value type of string, will truncate to given limit\n  // for type of non-string, will return same value\n  Span.prototype._truncateToLimitUtil = function (value, limit) {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substr(0, limit);\n  };\n  /**\n   * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n   * return string with trucated to {@code attributeValueLengthLimit} characters\n   *\n   * If the given attribute value is array of strings then\n   * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n   *\n   * Otherwise return same Attribute {@code value}\n   *\n   * @param value Attribute value\n   * @returns truncated attribute value if required, otherwise same value\n   */\n  Span.prototype._truncateToSize = function (value) {\n    var _this = this;\n    var limit = this._attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      api.diag.warn(\"Attribute value limit must be positive, got \" + limit);\n      return value;\n    }\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n    // Array of strings\n    if (Array.isArray(value)) {\n      return value.map(function (val) {\n        return typeof val === 'string' ? _this._truncateToLimitUtil(val, limit) : val;\n      });\n    }\n    // Other types, no need to apply value length limit\n    return value;\n  };\n  return Span;\n}();\nexport { Span };","map":{"version":3,"names":["api","isAttributeValue","hrTime","hrTimeDuration","isTimeInput","timeInputToHrTime","SemanticAttributes","ExceptionEventName","Span","parentTracer","context","spanName","spanContext","kind","parentSpanId","links","startTime","attributes","events","status","code","SpanStatusCode","UNSET","endTime","_ended","_duration","name","_spanContext","resource","instrumentationLibrary","_spanLimits","getSpanLimits","_spanProcessor","getActiveSpanProcessor","onStart","_attributeValueLengthLimit","attributeValueLengthLimit","prototype","setAttribute","key","value","_isSpanEnded","length","diag","warn","Object","keys","attributeCountLimit","hasOwnProperty","call","_truncateToSize","setAttributes","_i","_a","entries","_b","k","v","addEvent","attributesOrStartTime","eventCountLimit","shift","undefined","push","time","setStatus","updateName","end","error","onEnd","isRecording","recordException","exception","EXCEPTION_MESSAGE","EXCEPTION_TYPE","toString","message","stack","EXCEPTION_STACKTRACE","defineProperty","get","enumerable","configurable","traceId","spanId","_truncateToLimitUtil","limit","substr","_this","Array","isArray","map","val"],"sources":["/Users/dimitris.finas/node_modules/@opentelemetry/sdk-trace-base/build/esm/Span.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport { isAttributeValue, hrTime, hrTimeDuration, isTimeInput, timeInputToHrTime, } from '@opentelemetry/core';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { ExceptionEventName } from './enums';\n/**\n * This class represents a span.\n */\nvar Span = /** @class */ (function () {\n    /** Constructs a new Span instance. */\n    function Span(parentTracer, context, spanName, spanContext, kind, parentSpanId, links, startTime) {\n        if (links === void 0) { links = []; }\n        if (startTime === void 0) { startTime = hrTime(); }\n        this.attributes = {};\n        this.links = [];\n        this.events = [];\n        this.status = {\n            code: api.SpanStatusCode.UNSET,\n        };\n        this.endTime = [0, 0];\n        this._ended = false;\n        this._duration = [-1, -1];\n        this.name = spanName;\n        this._spanContext = spanContext;\n        this.parentSpanId = parentSpanId;\n        this.kind = kind;\n        this.links = links;\n        this.startTime = timeInputToHrTime(startTime);\n        this.resource = parentTracer.resource;\n        this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n        this._spanLimits = parentTracer.getSpanLimits();\n        this._spanProcessor = parentTracer.getActiveSpanProcessor();\n        this._spanProcessor.onStart(this, context);\n        this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;\n    }\n    Span.prototype.spanContext = function () {\n        return this._spanContext;\n    };\n    Span.prototype.setAttribute = function (key, value) {\n        if (value == null || this._isSpanEnded())\n            return this;\n        if (key.length === 0) {\n            api.diag.warn(\"Invalid attribute key: \" + key);\n            return this;\n        }\n        if (!isAttributeValue(value)) {\n            api.diag.warn(\"Invalid attribute value set for key: \" + key);\n            return this;\n        }\n        if (Object.keys(this.attributes).length >=\n            this._spanLimits.attributeCountLimit &&\n            !Object.prototype.hasOwnProperty.call(this.attributes, key)) {\n            return this;\n        }\n        this.attributes[key] = this._truncateToSize(value);\n        return this;\n    };\n    Span.prototype.setAttributes = function (attributes) {\n        for (var _i = 0, _a = Object.entries(attributes); _i < _a.length; _i++) {\n            var _b = _a[_i], k = _b[0], v = _b[1];\n            this.setAttribute(k, v);\n        }\n        return this;\n    };\n    /**\n     *\n     * @param name Span Name\n     * @param [attributesOrStartTime] Span attributes or start time\n     *     if type is {@type TimeInput} and 3rd param is undefined\n     * @param [startTime] Specified start time for the event\n     */\n    Span.prototype.addEvent = function (name, attributesOrStartTime, startTime) {\n        if (this._isSpanEnded())\n            return this;\n        if (this.events.length >= this._spanLimits.eventCountLimit) {\n            api.diag.warn('Dropping extra events.');\n            this.events.shift();\n        }\n        if (isTimeInput(attributesOrStartTime)) {\n            if (typeof startTime === 'undefined') {\n                startTime = attributesOrStartTime;\n            }\n            attributesOrStartTime = undefined;\n        }\n        if (typeof startTime === 'undefined') {\n            startTime = hrTime();\n        }\n        this.events.push({\n            name: name,\n            attributes: attributesOrStartTime,\n            time: timeInputToHrTime(startTime),\n        });\n        return this;\n    };\n    Span.prototype.setStatus = function (status) {\n        if (this._isSpanEnded())\n            return this;\n        this.status = status;\n        return this;\n    };\n    Span.prototype.updateName = function (name) {\n        if (this._isSpanEnded())\n            return this;\n        this.name = name;\n        return this;\n    };\n    Span.prototype.end = function (endTime) {\n        if (endTime === void 0) { endTime = hrTime(); }\n        if (this._isSpanEnded()) {\n            api.diag.error('You can only call end() on a span once.');\n            return;\n        }\n        this._ended = true;\n        this.endTime = timeInputToHrTime(endTime);\n        this._duration = hrTimeDuration(this.startTime, this.endTime);\n        if (this._duration[0] < 0) {\n            api.diag.warn('Inconsistent start and end time, startTime > endTime', this.startTime, this.endTime);\n        }\n        this._spanProcessor.onEnd(this);\n    };\n    Span.prototype.isRecording = function () {\n        return this._ended === false;\n    };\n    Span.prototype.recordException = function (exception, time) {\n        if (time === void 0) { time = hrTime(); }\n        var attributes = {};\n        if (typeof exception === 'string') {\n            attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;\n        }\n        else if (exception) {\n            if (exception.code) {\n                attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString();\n            }\n            else if (exception.name) {\n                attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;\n            }\n            if (exception.message) {\n                attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;\n            }\n            if (exception.stack) {\n                attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;\n            }\n        }\n        // these are minimum requirements from spec\n        if (attributes[SemanticAttributes.EXCEPTION_TYPE] ||\n            attributes[SemanticAttributes.EXCEPTION_MESSAGE]) {\n            this.addEvent(ExceptionEventName, attributes, time);\n        }\n        else {\n            api.diag.warn(\"Failed to record an exception \" + exception);\n        }\n    };\n    Object.defineProperty(Span.prototype, \"duration\", {\n        get: function () {\n            return this._duration;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Span.prototype, \"ended\", {\n        get: function () {\n            return this._ended;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Span.prototype._isSpanEnded = function () {\n        if (this._ended) {\n            api.diag.warn(\"Can not execute the operation on ended Span {traceId: \" + this._spanContext.traceId + \", spanId: \" + this._spanContext.spanId + \"}\");\n        }\n        return this._ended;\n    };\n    // Utility function to truncate given value within size\n    // for value type of string, will truncate to given limit\n    // for type of non-string, will return same value\n    Span.prototype._truncateToLimitUtil = function (value, limit) {\n        if (value.length <= limit) {\n            return value;\n        }\n        return value.substr(0, limit);\n    };\n    /**\n     * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n     * return string with trucated to {@code attributeValueLengthLimit} characters\n     *\n     * If the given attribute value is array of strings then\n     * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n     *\n     * Otherwise return same Attribute {@code value}\n     *\n     * @param value Attribute value\n     * @returns truncated attribute value if required, otherwise same value\n     */\n    Span.prototype._truncateToSize = function (value) {\n        var _this = this;\n        var limit = this._attributeValueLengthLimit;\n        // Check limit\n        if (limit <= 0) {\n            // Negative values are invalid, so do not truncate\n            api.diag.warn(\"Attribute value limit must be positive, got \" + limit);\n            return value;\n        }\n        // String\n        if (typeof value === 'string') {\n            return this._truncateToLimitUtil(value, limit);\n        }\n        // Array of strings\n        if (Array.isArray(value)) {\n            return value.map(function (val) { return typeof val === 'string' ? _this._truncateToLimitUtil(val, limit) : val; });\n        }\n        // Other types, no need to apply value length limit\n        return value;\n    };\n    return Span;\n}());\nexport { Span };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}