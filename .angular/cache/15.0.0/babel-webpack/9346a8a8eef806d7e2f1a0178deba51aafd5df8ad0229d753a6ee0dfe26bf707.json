{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst constants_1 = require(\"./constants\");\nconst duration_1 = require(\"./duration\");\nconst experimental_1 = require(\"./experimental\");\nconst filter_1 = require(\"./filter\");\nconst load_balancer_1 = require(\"./load-balancer\");\nconst load_balancer_child_handler_1 = require(\"./load-balancer-child-handler\");\nconst picker_1 = require(\"./picker\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst subchannel_interface_1 = require(\"./subchannel-interface\");\nconst logging = require(\"./logging\");\nconst TRACER_NAME = 'outlier_detection';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'outlier_detection';\nconst OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : 'true') === 'true';\nconst defaultSuccessRateEjectionConfig = {\n  stdev_factor: 1900,\n  enforcement_percentage: 100,\n  minimum_hosts: 5,\n  request_volume: 100\n};\nconst defaultFailurePercentageEjectionConfig = {\n  threshold: 85,\n  enforcement_percentage: 100,\n  minimum_hosts: 5,\n  request_volume: 50\n};\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\n  if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n  }\n}\nfunction validatePositiveDuration(obj, fieldName, objectName) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n  if (fieldName in obj) {\n    if (!duration_1.isDuration(obj[fieldName])) {\n      throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n    }\n    if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576000000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {\n      throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n    }\n  }\n}\nfunction validatePercentage(obj, fieldName, objectName) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n  validateFieldType(obj, fieldName, 'number', objectName);\n  if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n    throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n  }\n}\nclass OutlierDetectionLoadBalancingConfig {\n  constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {\n    this.childPolicy = childPolicy;\n    this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\n    this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\n    this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\n    this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\n    this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\n    this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\n  }\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n  toJsonObject() {\n    return {\n      interval: duration_1.msToDuration(this.intervalMs),\n      base_ejection_time: duration_1.msToDuration(this.baseEjectionTimeMs),\n      max_ejection_time: duration_1.msToDuration(this.maxEjectionTimeMs),\n      max_ejection_percent: this.maxEjectionPercent,\n      success_rate_ejection: this.successRateEjection,\n      failure_percentage_ejection: this.failurePercentageEjection,\n      child_policy: this.childPolicy.map(policy => policy.toJsonObject())\n    };\n  }\n  getIntervalMs() {\n    return this.intervalMs;\n  }\n  getBaseEjectionTimeMs() {\n    return this.baseEjectionTimeMs;\n  }\n  getMaxEjectionTimeMs() {\n    return this.maxEjectionTimeMs;\n  }\n  getMaxEjectionPercent() {\n    return this.maxEjectionPercent;\n  }\n  getSuccessRateEjectionConfig() {\n    return this.successRateEjection;\n  }\n  getFailurePercentageEjectionConfig() {\n    return this.failurePercentageEjection;\n  }\n  getChildPolicy() {\n    return this.childPolicy;\n  }\n  copyWithChildPolicy(childPolicy) {\n    return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\n  }\n  static createFromJson(obj) {\n    var _a;\n    validatePositiveDuration(obj, 'interval');\n    validatePositiveDuration(obj, 'base_ejection_time');\n    validatePositiveDuration(obj, 'max_ejection_time');\n    validatePercentage(obj, 'max_ejection_percent');\n    if ('success_rate_ejection' in obj) {\n      if (typeof obj.success_rate_ejection !== 'object') {\n        throw new Error('outlier detection config success_rate_ejection must be an object');\n      }\n      validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');\n      validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');\n      validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');\n      validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');\n    }\n    if ('failure_percentage_ejection' in obj) {\n      if (typeof obj.failure_percentage_ejection !== 'object') {\n        throw new Error('outlier detection config failure_percentage_ejection must be an object');\n      }\n      validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');\n      validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');\n      validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');\n      validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');\n    }\n    return new OutlierDetectionLoadBalancingConfig(obj.interval ? duration_1.durationToMs(obj.interval) : null, obj.base_ejection_time ? duration_1.durationToMs(obj.base_ejection_time) : null, obj.max_ejection_time ? duration_1.durationToMs(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));\n  }\n}\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n  constructor(childSubchannel, mapEntry) {\n    super(childSubchannel);\n    this.mapEntry = mapEntry;\n    this.stateListeners = [];\n    this.ejected = false;\n    this.refCount = 0;\n    this.childSubchannelState = childSubchannel.getConnectivityState();\n    childSubchannel.addConnectivityStateListener((subchannel, previousState, newState) => {\n      this.childSubchannelState = newState;\n      if (!this.ejected) {\n        for (const listener of this.stateListeners) {\n          listener(this, previousState, newState);\n        }\n      }\n    });\n  }\n  getConnectivityState() {\n    if (this.ejected) {\n      return connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n    } else {\n      return this.childSubchannelState;\n    }\n  }\n  /**\n   * Add a listener function to be called whenever the wrapper's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener) {\n    this.stateListeners.push(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n  ref() {\n    this.child.ref();\n    this.refCount += 1;\n  }\n  unref() {\n    this.child.unref();\n    this.refCount -= 1;\n    if (this.refCount <= 0) {\n      if (this.mapEntry) {\n        const index = this.mapEntry.subchannelWrappers.indexOf(this);\n        if (index >= 0) {\n          this.mapEntry.subchannelWrappers.splice(index, 1);\n        }\n      }\n    }\n  }\n  eject() {\n    this.ejected = true;\n    for (const listener of this.stateListeners) {\n      listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    }\n  }\n  uneject() {\n    this.ejected = false;\n    for (const listener of this.stateListeners) {\n      listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState);\n    }\n  }\n  getMapEntry() {\n    return this.mapEntry;\n  }\n  getWrappedSubchannel() {\n    return this.child;\n  }\n}\nfunction createEmptyBucket() {\n  return {\n    success: 0,\n    failure: 0\n  };\n}\nclass CallCounter {\n  constructor() {\n    this.activeBucket = createEmptyBucket();\n    this.inactiveBucket = createEmptyBucket();\n  }\n  addSuccess() {\n    this.activeBucket.success += 1;\n  }\n  addFailure() {\n    this.activeBucket.failure += 1;\n  }\n  switchBuckets() {\n    this.inactiveBucket = this.activeBucket;\n    this.activeBucket = createEmptyBucket();\n  }\n  getLastSuccesses() {\n    return this.inactiveBucket.success;\n  }\n  getLastFailures() {\n    return this.inactiveBucket.failure;\n  }\n}\nclass OutlierDetectionCounterFilter extends filter_1.BaseFilter {\n  constructor(callCounter) {\n    super();\n    this.callCounter = callCounter;\n  }\n  receiveTrailers(status) {\n    if (status.code === constants_1.Status.OK) {\n      this.callCounter.addSuccess();\n    } else {\n      this.callCounter.addFailure();\n    }\n    return status;\n  }\n}\nclass OutlierDetectionCounterFilterFactory {\n  constructor(callCounter) {\n    this.callCounter = callCounter;\n  }\n  createFilter(callStream) {\n    return new OutlierDetectionCounterFilter(this.callCounter);\n  }\n}\nclass OutlierDetectionPicker {\n  constructor(wrappedPicker, countCalls) {\n    this.wrappedPicker = wrappedPicker;\n    this.countCalls = countCalls;\n  }\n  pick(pickArgs) {\n    const wrappedPick = this.wrappedPicker.pick(pickArgs);\n    if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\n      const subchannelWrapper = wrappedPick.subchannel;\n      const mapEntry = subchannelWrapper.getMapEntry();\n      if (mapEntry) {\n        const extraFilterFactories = [...wrappedPick.extraFilterFactories];\n        if (this.countCalls) {\n          extraFilterFactories.push(new OutlierDetectionCounterFilterFactory(mapEntry.counter));\n        }\n        return Object.assign(Object.assign({}, wrappedPick), {\n          subchannel: subchannelWrapper.getWrappedSubchannel(),\n          extraFilterFactories: extraFilterFactories\n        });\n      } else {\n        return Object.assign(Object.assign({}, wrappedPick), {\n          subchannel: subchannelWrapper.getWrappedSubchannel()\n        });\n      }\n    } else {\n      return wrappedPick;\n    }\n  }\n}\nclass OutlierDetectionLoadBalancer {\n  constructor(channelControlHelper) {\n    this.addressMap = new Map();\n    this.latestConfig = null;\n    this.timerStartTime = null;\n    this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler(experimental_1.createChildChannelControlHelper(channelControlHelper, {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n        const mapEntry = this.addressMap.get(subchannel_address_1.subchannelAddressToString(subchannelAddress));\n        const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n        if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {\n          // If the address is ejected, propagate that to the new subchannel wrapper\n          subchannelWrapper.eject();\n        }\n        mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\n        return subchannelWrapper;\n      },\n      updateState: (connectivityState, picker) => {\n        if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\n          channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));\n        } else {\n          channelControlHelper.updateState(connectivityState, picker);\n        }\n      }\n    }));\n    this.ejectionTimer = setInterval(() => {}, 0);\n    clearInterval(this.ejectionTimer);\n  }\n  isCountingEnabled() {\n    return this.latestConfig !== null && (this.latestConfig.getSuccessRateEjectionConfig() !== null || this.latestConfig.getFailurePercentageEjectionConfig() !== null);\n  }\n  getCurrentEjectionPercent() {\n    let ejectionCount = 0;\n    for (const mapEntry of this.addressMap.values()) {\n      if (mapEntry.currentEjectionTimestamp !== null) {\n        ejectionCount += 1;\n      }\n    }\n    return ejectionCount * 100 / this.addressMap.size;\n  }\n  runSuccessRateCheck(ejectionTimestamp) {\n    if (!this.latestConfig) {\n      return;\n    }\n    const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n    if (!successRateConfig) {\n      return;\n    }\n    trace('Running success rate check');\n    // Step 1\n    const targetRequestVolume = successRateConfig.request_volume;\n    let addresesWithTargetVolume = 0;\n    const successRates = [];\n    for (const mapEntry of this.addressMap.values()) {\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      if (successes + failures >= targetRequestVolume) {\n        addresesWithTargetVolume += 1;\n        successRates.push(successes / (successes + failures));\n      }\n    }\n    trace('Found ' + addresesWithTargetVolume + ' success rate candidates; currentEjectionPercent=' + this.getCurrentEjectionPercent() + ' successRates=[' + successRates + ']');\n    if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n      return;\n    }\n    // Step 2\n    const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;\n    let successRateDeviationSum = 0;\n    for (const rate of successRates) {\n      const deviation = rate - successRateMean;\n      successRateDeviationSum += deviation * deviation;\n    }\n    const successRateVariance = successRateDeviationSum / successRates.length;\n    const successRateStdev = Math.sqrt(successRateVariance);\n    const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000);\n    trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);\n    // Step 3\n    for (const [address, mapEntry] of this.addressMap.entries()) {\n      // Step 3.i\n      if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n        break;\n      }\n      // Step 3.ii\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      if (successes + failures < targetRequestVolume) {\n        continue;\n      }\n      // Step 3.iii\n      const successRate = successes / (successes + failures);\n      trace('Checking candidate ' + address + ' successRate=' + successRate);\n      if (successRate < ejectionThreshold) {\n        const randomNumber = Math.random() * 100;\n        trace('Candidate ' + address + ' randomNumber=' + randomNumber + ' enforcement_percentage=' + successRateConfig.enforcement_percentage);\n        if (randomNumber < successRateConfig.enforcement_percentage) {\n          trace('Ejecting candidate ' + address);\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n  runFailurePercentageCheck(ejectionTimestamp) {\n    if (!this.latestConfig) {\n      return;\n    }\n    const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\n    if (!failurePercentageConfig) {\n      return;\n    }\n    trace('Running failure percentage check. threshold=' + failurePercentageConfig.threshold + ' request volume threshold=' + failurePercentageConfig.request_volume);\n    // Step 1\n    let addressesWithTargetVolume = 0;\n    for (const mapEntry of this.addressMap.values()) {\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      if (successes + failures >= failurePercentageConfig.request_volume) {\n        addressesWithTargetVolume += 1;\n      }\n    }\n    if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\n      return;\n    }\n    // Step 2\n    for (const [address, mapEntry] of this.addressMap.entries()) {\n      // Step 2.i\n      if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n        break;\n      }\n      // Step 2.ii\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      trace('Candidate successes=' + successes + ' failures=' + failures);\n      if (successes + failures < failurePercentageConfig.request_volume) {\n        continue;\n      }\n      // Step 2.iii\n      const failurePercentage = failures * 100 / (failures + successes);\n      if (failurePercentage > failurePercentageConfig.threshold) {\n        const randomNumber = Math.random() * 100;\n        trace('Candidate ' + address + ' randomNumber=' + randomNumber + ' enforcement_percentage=' + failurePercentageConfig.enforcement_percentage);\n        if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n          trace('Ejecting candidate ' + address);\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n  eject(mapEntry, ejectionTimestamp) {\n    mapEntry.currentEjectionTimestamp = new Date();\n    mapEntry.ejectionTimeMultiplier += 1;\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.eject();\n    }\n  }\n  uneject(mapEntry) {\n    mapEntry.currentEjectionTimestamp = null;\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.uneject();\n    }\n  }\n  switchAllBuckets() {\n    for (const mapEntry of this.addressMap.values()) {\n      mapEntry.counter.switchBuckets();\n    }\n  }\n  startTimer(delayMs) {\n    this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);\n  }\n  runChecks() {\n    const ejectionTimestamp = new Date();\n    trace('Ejection timer running');\n    this.switchAllBuckets();\n    if (!this.latestConfig) {\n      return;\n    }\n    this.timerStartTime = ejectionTimestamp;\n    this.startTimer(this.latestConfig.getIntervalMs());\n    this.runSuccessRateCheck(ejectionTimestamp);\n    this.runFailurePercentageCheck(ejectionTimestamp);\n    for (const [address, mapEntry] of this.addressMap.entries()) {\n      if (mapEntry.currentEjectionTimestamp === null) {\n        if (mapEntry.ejectionTimeMultiplier > 0) {\n          mapEntry.ejectionTimeMultiplier -= 1;\n        }\n      } else {\n        const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n        const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n        const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n        returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n        if (returnTime < new Date()) {\n          trace('Unejecting ' + address);\n          this.uneject(mapEntry);\n        }\n      }\n    }\n  }\n  updateAddressList(addressList, lbConfig, attributes) {\n    if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n      return;\n    }\n    const subchannelAddresses = new Set();\n    for (const address of addressList) {\n      subchannelAddresses.add(subchannel_address_1.subchannelAddressToString(address));\n    }\n    for (const address of subchannelAddresses) {\n      if (!this.addressMap.has(address)) {\n        trace('Adding map entry for ' + address);\n        this.addressMap.set(address, {\n          counter: new CallCounter(),\n          currentEjectionTimestamp: null,\n          ejectionTimeMultiplier: 0,\n          subchannelWrappers: []\n        });\n      }\n    }\n    for (const key of this.addressMap.keys()) {\n      if (!subchannelAddresses.has(key)) {\n        trace('Removing map entry for ' + key);\n        this.addressMap.delete(key);\n      }\n    }\n    const childPolicy = load_balancer_1.getFirstUsableConfig(lbConfig.getChildPolicy(), true);\n    this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n    if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) {\n      if (this.timerStartTime) {\n        trace('Previous timer existed. Replacing timer');\n        clearTimeout(this.ejectionTimer);\n        const remainingDelay = lbConfig.getIntervalMs() - (new Date().getTime() - this.timerStartTime.getTime());\n        this.startTimer(remainingDelay);\n      } else {\n        trace('Starting new timer');\n        this.timerStartTime = new Date();\n        this.startTimer(lbConfig.getIntervalMs());\n        this.switchAllBuckets();\n      }\n    } else {\n      trace('Counting disabled. Cancelling timer.');\n      this.timerStartTime = null;\n      clearTimeout(this.ejectionTimer);\n      for (const mapEntry of this.addressMap.values()) {\n        this.uneject(mapEntry);\n        mapEntry.ejectionTimeMultiplier = 0;\n      }\n    }\n    this.latestConfig = lbConfig;\n  }\n  exitIdle() {\n    this.childBalancer.exitIdle();\n  }\n  resetBackoff() {\n    this.childBalancer.resetBackoff();\n  }\n  destroy() {\n    clearTimeout(this.ejectionTimer);\n    this.childBalancer.destroy();\n  }\n  getTypeName() {\n    return TYPE_NAME;\n  }\n}\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\nfunction setup() {\n  if (OUTLIER_DETECTION_ENABLED) {\n    experimental_1.registerLoadBalancerType(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n  }\n}\nexports.setup = setup;","map":{"version":3,"names":["_a","Object","defineProperty","exports","value","setup","OutlierDetectionLoadBalancer","OutlierDetectionLoadBalancingConfig","connectivity_state_1","require","constants_1","duration_1","experimental_1","filter_1","load_balancer_1","load_balancer_child_handler_1","picker_1","subchannel_address_1","subchannel_interface_1","logging","TRACER_NAME","trace","text","LogVerbosity","DEBUG","TYPE_NAME","OUTLIER_DETECTION_ENABLED","process","env","GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION","defaultSuccessRateEjectionConfig","stdev_factor","enforcement_percentage","minimum_hosts","request_volume","defaultFailurePercentageEjectionConfig","threshold","validateFieldType","obj","fieldName","expectedType","objectName","fullFieldName","Error","validatePositiveDuration","isDuration","seconds","nanos","validatePercentage","constructor","intervalMs","baseEjectionTimeMs","maxEjectionTimeMs","maxEjectionPercent","successRateEjection","failurePercentageEjection","childPolicy","assign","getLoadBalancerName","toJsonObject","interval","msToDuration","base_ejection_time","max_ejection_time","max_ejection_percent","success_rate_ejection","failure_percentage_ejection","child_policy","map","policy","getIntervalMs","getBaseEjectionTimeMs","getMaxEjectionTimeMs","getMaxEjectionPercent","getSuccessRateEjectionConfig","getFailurePercentageEjectionConfig","getChildPolicy","copyWithChildPolicy","createFromJson","durationToMs","validateLoadBalancingConfig","OutlierDetectionSubchannelWrapper","BaseSubchannelWrapper","childSubchannel","mapEntry","stateListeners","ejected","refCount","childSubchannelState","getConnectivityState","addConnectivityStateListener","subchannel","previousState","newState","listener","ConnectivityState","TRANSIENT_FAILURE","push","removeConnectivityStateListener","listenerIndex","indexOf","splice","ref","child","unref","index","subchannelWrappers","eject","uneject","getMapEntry","getWrappedSubchannel","createEmptyBucket","success","failure","CallCounter","activeBucket","inactiveBucket","addSuccess","addFailure","switchBuckets","getLastSuccesses","getLastFailures","OutlierDetectionCounterFilter","BaseFilter","callCounter","receiveTrailers","status","code","Status","OK","OutlierDetectionCounterFilterFactory","createFilter","callStream","OutlierDetectionPicker","wrappedPicker","countCalls","pick","pickArgs","wrappedPick","pickResultType","PickResultType","COMPLETE","subchannelWrapper","extraFilterFactories","counter","channelControlHelper","addressMap","Map","latestConfig","timerStartTime","childBalancer","ChildLoadBalancerHandler","createChildChannelControlHelper","createSubchannel","subchannelAddress","subchannelArgs","originalSubchannel","get","subchannelAddressToString","currentEjectionTimestamp","updateState","connectivityState","picker","READY","isCountingEnabled","ejectionTimer","setInterval","clearInterval","getCurrentEjectionPercent","ejectionCount","values","size","runSuccessRateCheck","ejectionTimestamp","successRateConfig","targetRequestVolume","addresesWithTargetVolume","successRates","successes","failures","successRateMean","reduce","a","b","length","successRateDeviationSum","rate","deviation","successRateVariance","successRateStdev","Math","sqrt","ejectionThreshold","address","entries","successRate","randomNumber","random","runFailurePercentageCheck","failurePercentageConfig","addressesWithTargetVolume","failurePercentage","Date","ejectionTimeMultiplier","switchAllBuckets","startTimer","delayMs","setTimeout","runChecks","returnTime","getTime","setMilliseconds","getMilliseconds","min","max","updateAddressList","addressList","lbConfig","attributes","subchannelAddresses","Set","add","has","set","key","keys","delete","getFirstUsableConfig","clearTimeout","remainingDelay","exitIdle","resetBackoff","destroy","getTypeName","registerLoadBalancerType"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setup = exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst constants_1 = require(\"./constants\");\nconst duration_1 = require(\"./duration\");\nconst experimental_1 = require(\"./experimental\");\nconst filter_1 = require(\"./filter\");\nconst load_balancer_1 = require(\"./load-balancer\");\nconst load_balancer_child_handler_1 = require(\"./load-balancer-child-handler\");\nconst picker_1 = require(\"./picker\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst subchannel_interface_1 = require(\"./subchannel-interface\");\nconst logging = require(\"./logging\");\nconst TRACER_NAME = 'outlier_detection';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'outlier_detection';\nconst OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : 'true') === 'true';\nconst defaultSuccessRateEjectionConfig = {\n    stdev_factor: 1900,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 100\n};\nconst defaultFailurePercentageEjectionConfig = {\n    threshold: 85,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 50\n};\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\n    if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n    }\n}\nfunction validatePositiveDuration(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    if (fieldName in obj) {\n        if (!duration_1.isDuration(obj[fieldName])) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n        }\n        if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576000000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n        }\n    }\n}\nfunction validatePercentage(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    validateFieldType(obj, fieldName, 'number', objectName);\n    if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n    }\n}\nclass OutlierDetectionLoadBalancingConfig {\n    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {\n        this.childPolicy = childPolicy;\n        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\n        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\n        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\n        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\n        this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\n        this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        return {\n            interval: duration_1.msToDuration(this.intervalMs),\n            base_ejection_time: duration_1.msToDuration(this.baseEjectionTimeMs),\n            max_ejection_time: duration_1.msToDuration(this.maxEjectionTimeMs),\n            max_ejection_percent: this.maxEjectionPercent,\n            success_rate_ejection: this.successRateEjection,\n            failure_percentage_ejection: this.failurePercentageEjection,\n            child_policy: this.childPolicy.map(policy => policy.toJsonObject())\n        };\n    }\n    getIntervalMs() {\n        return this.intervalMs;\n    }\n    getBaseEjectionTimeMs() {\n        return this.baseEjectionTimeMs;\n    }\n    getMaxEjectionTimeMs() {\n        return this.maxEjectionTimeMs;\n    }\n    getMaxEjectionPercent() {\n        return this.maxEjectionPercent;\n    }\n    getSuccessRateEjectionConfig() {\n        return this.successRateEjection;\n    }\n    getFailurePercentageEjectionConfig() {\n        return this.failurePercentageEjection;\n    }\n    getChildPolicy() {\n        return this.childPolicy;\n    }\n    copyWithChildPolicy(childPolicy) {\n        return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\n    }\n    static createFromJson(obj) {\n        var _a;\n        validatePositiveDuration(obj, 'interval');\n        validatePositiveDuration(obj, 'base_ejection_time');\n        validatePositiveDuration(obj, 'max_ejection_time');\n        validatePercentage(obj, 'max_ejection_percent');\n        if ('success_rate_ejection' in obj) {\n            if (typeof obj.success_rate_ejection !== 'object') {\n                throw new Error('outlier detection config success_rate_ejection must be an object');\n            }\n            validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');\n            validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');\n            validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');\n            validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');\n        }\n        if ('failure_percentage_ejection' in obj) {\n            if (typeof obj.failure_percentage_ejection !== 'object') {\n                throw new Error('outlier detection config failure_percentage_ejection must be an object');\n            }\n            validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');\n            validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');\n            validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');\n            validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');\n        }\n        return new OutlierDetectionLoadBalancingConfig(obj.interval ? duration_1.durationToMs(obj.interval) : null, obj.base_ejection_time ? duration_1.durationToMs(obj.base_ejection_time) : null, obj.max_ejection_time ? duration_1.durationToMs(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));\n    }\n}\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, mapEntry) {\n        super(childSubchannel);\n        this.mapEntry = mapEntry;\n        this.stateListeners = [];\n        this.ejected = false;\n        this.refCount = 0;\n        this.childSubchannelState = childSubchannel.getConnectivityState();\n        childSubchannel.addConnectivityStateListener((subchannel, previousState, newState) => {\n            this.childSubchannelState = newState;\n            if (!this.ejected) {\n                for (const listener of this.stateListeners) {\n                    listener(this, previousState, newState);\n                }\n            }\n        });\n    }\n    getConnectivityState() {\n        if (this.ejected) {\n            return connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n        }\n        else {\n            return this.childSubchannelState;\n        }\n    }\n    /**\n     * Add a listener function to be called whenever the wrapper's\n     * connectivity state changes.\n     * @param listener\n     */\n    addConnectivityStateListener(listener) {\n        this.stateListeners.push(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */\n    removeConnectivityStateListener(listener) {\n        const listenerIndex = this.stateListeners.indexOf(listener);\n        if (listenerIndex > -1) {\n            this.stateListeners.splice(listenerIndex, 1);\n        }\n    }\n    ref() {\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            if (this.mapEntry) {\n                const index = this.mapEntry.subchannelWrappers.indexOf(this);\n                if (index >= 0) {\n                    this.mapEntry.subchannelWrappers.splice(index, 1);\n                }\n            }\n        }\n    }\n    eject() {\n        this.ejected = true;\n        for (const listener of this.stateListeners) {\n            listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        }\n    }\n    uneject() {\n        this.ejected = false;\n        for (const listener of this.stateListeners) {\n            listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState);\n        }\n    }\n    getMapEntry() {\n        return this.mapEntry;\n    }\n    getWrappedSubchannel() {\n        return this.child;\n    }\n}\nfunction createEmptyBucket() {\n    return {\n        success: 0,\n        failure: 0\n    };\n}\nclass CallCounter {\n    constructor() {\n        this.activeBucket = createEmptyBucket();\n        this.inactiveBucket = createEmptyBucket();\n    }\n    addSuccess() {\n        this.activeBucket.success += 1;\n    }\n    addFailure() {\n        this.activeBucket.failure += 1;\n    }\n    switchBuckets() {\n        this.inactiveBucket = this.activeBucket;\n        this.activeBucket = createEmptyBucket();\n    }\n    getLastSuccesses() {\n        return this.inactiveBucket.success;\n    }\n    getLastFailures() {\n        return this.inactiveBucket.failure;\n    }\n}\nclass OutlierDetectionCounterFilter extends filter_1.BaseFilter {\n    constructor(callCounter) {\n        super();\n        this.callCounter = callCounter;\n    }\n    receiveTrailers(status) {\n        if (status.code === constants_1.Status.OK) {\n            this.callCounter.addSuccess();\n        }\n        else {\n            this.callCounter.addFailure();\n        }\n        return status;\n    }\n}\nclass OutlierDetectionCounterFilterFactory {\n    constructor(callCounter) {\n        this.callCounter = callCounter;\n    }\n    createFilter(callStream) {\n        return new OutlierDetectionCounterFilter(this.callCounter);\n    }\n}\nclass OutlierDetectionPicker {\n    constructor(wrappedPicker, countCalls) {\n        this.wrappedPicker = wrappedPicker;\n        this.countCalls = countCalls;\n    }\n    pick(pickArgs) {\n        const wrappedPick = this.wrappedPicker.pick(pickArgs);\n        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\n            const subchannelWrapper = wrappedPick.subchannel;\n            const mapEntry = subchannelWrapper.getMapEntry();\n            if (mapEntry) {\n                const extraFilterFactories = [...wrappedPick.extraFilterFactories];\n                if (this.countCalls) {\n                    extraFilterFactories.push(new OutlierDetectionCounterFilterFactory(mapEntry.counter));\n                }\n                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel(), extraFilterFactories: extraFilterFactories });\n            }\n            else {\n                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel() });\n            }\n        }\n        else {\n            return wrappedPick;\n        }\n    }\n}\nclass OutlierDetectionLoadBalancer {\n    constructor(channelControlHelper) {\n        this.addressMap = new Map();\n        this.latestConfig = null;\n        this.timerStartTime = null;\n        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler(experimental_1.createChildChannelControlHelper(channelControlHelper, {\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\n                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n                const mapEntry = this.addressMap.get(subchannel_address_1.subchannelAddressToString(subchannelAddress));\n                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n                if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {\n                    // If the address is ejected, propagate that to the new subchannel wrapper\n                    subchannelWrapper.eject();\n                }\n                mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\n                return subchannelWrapper;\n            },\n            updateState: (connectivityState, picker) => {\n                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\n                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));\n                }\n                else {\n                    channelControlHelper.updateState(connectivityState, picker);\n                }\n            }\n        }));\n        this.ejectionTimer = setInterval(() => { }, 0);\n        clearInterval(this.ejectionTimer);\n    }\n    isCountingEnabled() {\n        return this.latestConfig !== null &&\n            (this.latestConfig.getSuccessRateEjectionConfig() !== null ||\n                this.latestConfig.getFailurePercentageEjectionConfig() !== null);\n    }\n    getCurrentEjectionPercent() {\n        let ejectionCount = 0;\n        for (const mapEntry of this.addressMap.values()) {\n            if (mapEntry.currentEjectionTimestamp !== null) {\n                ejectionCount += 1;\n            }\n        }\n        return (ejectionCount * 100) / this.addressMap.size;\n    }\n    runSuccessRateCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n        if (!successRateConfig) {\n            return;\n        }\n        trace('Running success rate check');\n        // Step 1\n        const targetRequestVolume = successRateConfig.request_volume;\n        let addresesWithTargetVolume = 0;\n        const successRates = [];\n        for (const mapEntry of this.addressMap.values()) {\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures >= targetRequestVolume) {\n                addresesWithTargetVolume += 1;\n                successRates.push(successes / (successes + failures));\n            }\n        }\n        trace('Found ' + addresesWithTargetVolume + ' success rate candidates; currentEjectionPercent=' + this.getCurrentEjectionPercent() + ' successRates=[' + successRates + ']');\n        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;\n        let successRateDeviationSum = 0;\n        for (const rate of successRates) {\n            const deviation = rate - successRateMean;\n            successRateDeviationSum += deviation * deviation;\n        }\n        const successRateVariance = successRateDeviationSum / successRates.length;\n        const successRateStdev = Math.sqrt(successRateVariance);\n        const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000);\n        trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);\n        // Step 3\n        for (const [address, mapEntry] of this.addressMap.entries()) {\n            // Step 3.i\n            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 3.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures < targetRequestVolume) {\n                continue;\n            }\n            // Step 3.iii\n            const successRate = successes / (successes + failures);\n            trace('Checking candidate ' + address + ' successRate=' + successRate);\n            if (successRate < ejectionThreshold) {\n                const randomNumber = Math.random() * 100;\n                trace('Candidate ' + address + ' randomNumber=' + randomNumber + ' enforcement_percentage=' + successRateConfig.enforcement_percentage);\n                if (randomNumber < successRateConfig.enforcement_percentage) {\n                    trace('Ejecting candidate ' + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    runFailurePercentageCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\n        if (!failurePercentageConfig) {\n            return;\n        }\n        trace('Running failure percentage check. threshold=' + failurePercentageConfig.threshold + ' request volume threshold=' + failurePercentageConfig.request_volume);\n        // Step 1\n        let addressesWithTargetVolume = 0;\n        for (const mapEntry of this.addressMap.values()) {\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures >= failurePercentageConfig.request_volume) {\n                addressesWithTargetVolume += 1;\n            }\n        }\n        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        for (const [address, mapEntry] of this.addressMap.entries()) {\n            // Step 2.i\n            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 2.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace('Candidate successes=' + successes + ' failures=' + failures);\n            if (successes + failures < failurePercentageConfig.request_volume) {\n                continue;\n            }\n            // Step 2.iii\n            const failurePercentage = (failures * 100) / (failures + successes);\n            if (failurePercentage > failurePercentageConfig.threshold) {\n                const randomNumber = Math.random() * 100;\n                trace('Candidate ' + address + ' randomNumber=' + randomNumber + ' enforcement_percentage=' + failurePercentageConfig.enforcement_percentage);\n                if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n                    trace('Ejecting candidate ' + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    eject(mapEntry, ejectionTimestamp) {\n        mapEntry.currentEjectionTimestamp = new Date();\n        mapEntry.ejectionTimeMultiplier += 1;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n            subchannelWrapper.eject();\n        }\n    }\n    uneject(mapEntry) {\n        mapEntry.currentEjectionTimestamp = null;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n            subchannelWrapper.uneject();\n        }\n    }\n    switchAllBuckets() {\n        for (const mapEntry of this.addressMap.values()) {\n            mapEntry.counter.switchBuckets();\n        }\n    }\n    startTimer(delayMs) {\n        this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);\n    }\n    runChecks() {\n        const ejectionTimestamp = new Date();\n        trace('Ejection timer running');\n        this.switchAllBuckets();\n        if (!this.latestConfig) {\n            return;\n        }\n        this.timerStartTime = ejectionTimestamp;\n        this.startTimer(this.latestConfig.getIntervalMs());\n        this.runSuccessRateCheck(ejectionTimestamp);\n        this.runFailurePercentageCheck(ejectionTimestamp);\n        for (const [address, mapEntry] of this.addressMap.entries()) {\n            if (mapEntry.currentEjectionTimestamp === null) {\n                if (mapEntry.ejectionTimeMultiplier > 0) {\n                    mapEntry.ejectionTimeMultiplier -= 1;\n                }\n            }\n            else {\n                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n                returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n                if (returnTime < new Date()) {\n                    trace('Unejecting ' + address);\n                    this.uneject(mapEntry);\n                }\n            }\n        }\n    }\n    updateAddressList(addressList, lbConfig, attributes) {\n        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n            return;\n        }\n        const subchannelAddresses = new Set();\n        for (const address of addressList) {\n            subchannelAddresses.add(subchannel_address_1.subchannelAddressToString(address));\n        }\n        for (const address of subchannelAddresses) {\n            if (!this.addressMap.has(address)) {\n                trace('Adding map entry for ' + address);\n                this.addressMap.set(address, {\n                    counter: new CallCounter(),\n                    currentEjectionTimestamp: null,\n                    ejectionTimeMultiplier: 0,\n                    subchannelWrappers: []\n                });\n            }\n        }\n        for (const key of this.addressMap.keys()) {\n            if (!subchannelAddresses.has(key)) {\n                trace('Removing map entry for ' + key);\n                this.addressMap.delete(key);\n            }\n        }\n        const childPolicy = load_balancer_1.getFirstUsableConfig(lbConfig.getChildPolicy(), true);\n        this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n        if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) {\n            if (this.timerStartTime) {\n                trace('Previous timer existed. Replacing timer');\n                clearTimeout(this.ejectionTimer);\n                const remainingDelay = lbConfig.getIntervalMs() - ((new Date()).getTime() - this.timerStartTime.getTime());\n                this.startTimer(remainingDelay);\n            }\n            else {\n                trace('Starting new timer');\n                this.timerStartTime = new Date();\n                this.startTimer(lbConfig.getIntervalMs());\n                this.switchAllBuckets();\n            }\n        }\n        else {\n            trace('Counting disabled. Cancelling timer.');\n            this.timerStartTime = null;\n            clearTimeout(this.ejectionTimer);\n            for (const mapEntry of this.addressMap.values()) {\n                this.uneject(mapEntry);\n                mapEntry.ejectionTimeMultiplier = 0;\n            }\n        }\n        this.latestConfig = lbConfig;\n    }\n    exitIdle() {\n        this.childBalancer.exitIdle();\n    }\n    resetBackoff() {\n        this.childBalancer.resetBackoff();\n    }\n    destroy() {\n        clearTimeout(this.ejectionTimer);\n        this.childBalancer.destroy();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\nfunction setup() {\n    if (OUTLIER_DETECTION_ENABLED) {\n        experimental_1.registerLoadBalancerType(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n    }\n}\nexports.setup = setup;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}