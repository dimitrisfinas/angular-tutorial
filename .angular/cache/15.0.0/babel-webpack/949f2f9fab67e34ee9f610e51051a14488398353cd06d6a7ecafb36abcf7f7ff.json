{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subchannel = void 0;\nconst http2 = require(\"http2\");\nconst tls_1 = require(\"tls\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst resolver_1 = require(\"./resolver\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst net = require(\"net\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst channelz_1 = require(\"./channelz\");\nconst clientVersion = require('../../package.json').version;\nconst TRACER_NAME = 'subchannel';\nconst FLOW_CONTROL_TRACER_NAME = 'subchannel_flowctrl';\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT\n} = http2.constants;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\nclass Subchannel {\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(channelTarget, subchannelAddress, options, credentials) {\n    this.channelTarget = channelTarget;\n    this.subchannelAddress = subchannelAddress;\n    this.options = options;\n    this.credentials = credentials;\n    /**\n     * The subchannel's current connectivity state. Invariant: `session` === `null`\n     * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n     */\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The underlying http2 session used to make requests.\n     */\n    this.session = null;\n    /**\n     * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n     * CONNECTING instead of IDLE when the backoff timeout ends.\n     */\n    this.continueConnecting = false;\n    /**\n     * A list of listener functions that will be called whenever the connectivity\n     * state changes. Will be modified by `addConnectivityStateListener` and\n     * `removeConnectivityStateListener`\n     */\n    this.stateListeners = [];\n    /**\n     * A list of listener functions that will be called when the underlying\n     * socket disconnects. Used for ending active calls with an UNAVAILABLE\n     * status.\n     */\n    this.disconnectListeners = new Set();\n    /**\n     * The amount of time in between sending pings\n     */\n    this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;\n    /**\n     * The amount of time to wait for an acknowledgement after sending a ping\n     */\n    this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    /**\n     * Indicates whether keepalive pings should be sent without any active calls\n     */\n    this.keepaliveWithoutCalls = false;\n    /**\n     * Tracks calls with references to this subchannel\n     */\n    this.callRefcount = 0;\n    /**\n     * Tracks channels and subchannel pools with references to this subchannel\n     */\n    this.refcount = 0;\n    // Channelz info\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n    // Channelz socket info\n    this.channelzSocketRef = null;\n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n    // Build user-agent string.\n    this.userAgent = [options['grpc.primary_user_agent'], `grpc-node-js/${clientVersion}`, options['grpc.secondary_user_agent']].filter(e => e).join(' '); // remove falsey values first\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls = options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    this.keepaliveTimeoutId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveTimeoutId);\n    const backoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = subchannel_address_1.subchannelAddressToString(subchannelAddress);\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.channelzRef = channelz_1.registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    }\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n  getChannelzInfo() {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n  getChannelzSocketInfo() {\n    var _a, _b, _c;\n    if (this.session === null) {\n      return null;\n    }\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo;\n    if (this.session.encrypted) {\n      const tlsSocket = sessionSocket;\n      const cipherInfo = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n      remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n    };\n    return socketInfo;\n  }\n  resetChannelzSocketInfo() {\n    if (!this.channelzEnabled) {\n      return;\n    }\n    if (this.channelzSocketRef) {\n      channelz_1.unregisterChannelzRef(this.channelzSocketRef);\n      this.childrenTracker.unrefChild(this.channelzSocketRef);\n      this.channelzSocketRef = null;\n    }\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  refTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  flowControlTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  internalsTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  keepaliveTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    } else {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n    }\n  }\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n  stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n  sendPing() {\n    var _a, _b;\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n    this.keepaliveTimeoutId = setTimeout(() => {\n      this.keepaliveTrace('Ping timeout passed without response');\n      this.handleDisconnect();\n    }, this.keepaliveTimeoutMs);\n    (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    try {\n      this.session.ping((err, duration, payload) => {\n        this.keepaliveTrace('Received ping response');\n        clearTimeout(this.keepaliveTimeoutId);\n      });\n    } catch (e) {\n      /* If we fail to send a ping, the connection is no longer functional, so\n       * we should discard it. */\n      this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    }\n  }\n  startKeepalivePings() {\n    var _a, _b;\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n  /**\n   * Stop keepalive pings when terminating a connection. This discards the\n   * outstanding ping timeout, so it should not be called if the same\n   * connection will still be used.\n   */\n  stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    clearTimeout(this.keepaliveTimeoutId);\n  }\n  createSession(proxyConnectionResult) {\n    var _a, _b, _c;\n    if (proxyConnectionResult.realTarget) {\n      this.remoteName = uri_parser_1.uriToString(proxyConnectionResult.realTarget);\n      this.trace('creating HTTP/2 session through proxy to ' + proxyConnectionResult.realTarget);\n    } else {\n      this.remoteName = null;\n      this.trace('creating HTTP/2 session');\n    }\n    const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n    let connectionOptions = this.credentials._getConnectionOptions() || {};\n    connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n    if ('grpc-node.max_session_memory' in this.options) {\n      connectionOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n    } else {\n      /* By default, set a very large max session memory limit, to effectively\n       * disable enforcement of the limit. Some testing indicates that Node's\n       * behavior degrades badly when this limit is reached, so we solve that\n       * by disabling the check entirely. */\n      connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n    }\n    let addressScheme = 'http://';\n    if ('secureContext' in connectionOptions) {\n      addressScheme = 'https://';\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost';\n        // We want to always set servername to support SNI\n        connectionOptions.servername = authorityHostname;\n      }\n      if (proxyConnectionResult.socket) {\n        /* This is part of the workaround for\n         * https://github.com/nodejs/node/issues/32922. Without that bug,\n         * proxyConnectionResult.socket would always be a plaintext socket and\n         * this would say\n         * connectionOptions.socket = proxyConnectionResult.socket; */\n        connectionOptions.createConnection = (authority, option) => {\n          return proxyConnectionResult.socket;\n        };\n      }\n    } else {\n      /* In all but the most recent versions of Node, http2.connect does not use\n       * the options when establishing plaintext connections, so we need to\n       * establish that connection explicitly. */\n      connectionOptions.createConnection = (authority, option) => {\n        if (proxyConnectionResult.socket) {\n          return proxyConnectionResult.socket;\n        } else {\n          /* net.NetConnectOpts is declared in a way that is more restrictive\n           * than what net.connect will actually accept, so we use the type\n           * assertion to work around that. */\n          return net.connect(this.subchannelAddress);\n        }\n      };\n    }\n    connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);\n    /* http2.connect uses the options here:\n     * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n     * The spread operator overides earlier values with later ones, so any port\n     * or host values in the options will be used rather than any values extracted\n     * from the first argument. In addition, the path overrides the host and port,\n     * as documented for plaintext connections here:\n     * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n     * and for TLS connections here:\n     * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n     * earlier versions of Node, http2.connect passes these options to\n     * tls.connect but not net.connect, so in the insecure case we still need\n     * to set the createConnection option above to create the connection\n     * explicitly. We cannot do that in the TLS case because http2.connect\n     * passes necessary additional options to tls.connect.\n     * The first argument just needs to be parseable as a URL and the scheme\n     * determines whether the connection will be established over TLS or not.\n     */\n    const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n    this.session = session;\n    this.channelzSocketRef = channelz_1.registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzSocketInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.childrenTracker.refChild(this.channelzSocketRef);\n    }\n    session.unref();\n    /* For all of these events, check if the session at the time of the event\n     * is the same one currently attached to this subchannel, to ensure that\n     * old events from previous connection attempts cannot cause invalid state\n     * transitions. */\n    session.once('connect', () => {\n      if (this.session === session) {\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY);\n      }\n    });\n    session.once('close', () => {\n      if (this.session === session) {\n        this.trace('connection closed');\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        /* Transitioning directly to IDLE here should be OK because we are not\n         * doing any backoff, because a connection was established at some\n         * point */\n        this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n      if (this.session === session) {\n        /* See the last paragraph of\n         * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n        if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {\n          this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);\n          logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${uri_parser_1.uriToString(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);\n        }\n        this.trace('connection closed by GOAWAY with code ' + errorCode);\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('error', error => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace('connection closed with error ' + error.message);\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', settings => {\n        this.trace('new settings received' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n      session.on('localSettings', settings => {\n        this.trace('local settings acknowledged by remote' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n    }\n  }\n  startConnectingInternal() {\n    var _a, _b;\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions = this.credentials._getConnectionOptions() || {};\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in this.options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {\n            path: 'localhost'\n          });\n          const hostPort = uri_parser_1.splitHostPort(targetPath);\n          connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n        }\n      }\n    }\n    http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then(result => {\n      this.createSession(result);\n    }, reason => {\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    });\n  }\n  handleDisconnect() {\n    this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    for (const listener of this.disconnectListeners.values()) {\n      listener();\n    }\n  }\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  transitionToState(oldStates, newState) {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case connectivity_state_1.ConnectivityState.READY:\n        this.stopBackoff();\n        const session = this.session;\n        session.socket.once('close', () => {\n          if (this.session === session) {\n            this.handleDisconnect();\n          }\n        });\n        if (this.keepaliveWithoutCalls) {\n          this.startKeepalivePings();\n        }\n        break;\n      case connectivity_state_1.ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case connectivity_state_1.ConnectivityState.IDLE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState);\n    }\n    return true;\n  }\n  /**\n   * Check if the subchannel associated with zero calls and with zero channels.\n   * If so, shut it down.\n   */\n  checkBothRefcounts() {\n    /* If no calls, channels, or subchannel pools have any more references to\n     * this subchannel, we can be sure it will never be used again. */\n    if (this.callRefcount === 0 && this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      if (this.channelzEnabled) {\n        channelz_1.unregisterChannelzRef(this.channelzRef);\n      }\n    }\n  }\n  callRef() {\n    this.refTrace('callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount + 1));\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.ref();\n      }\n      this.backoffTimeout.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n    this.callRefcount += 1;\n  }\n  callUnref() {\n    this.refTrace('callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount - 1));\n    this.callRefcount -= 1;\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.unref();\n      }\n      this.backoffTimeout.unref();\n      if (!this.keepaliveWithoutCalls) {\n        clearInterval(this.keepaliveIntervalId);\n      }\n      this.checkBothRefcounts();\n    }\n  }\n  ref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n  unref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    this.checkBothRefcounts();\n  }\n  unrefIfOneRef() {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Start a stream on the current session with the given `metadata` as headers\n   * and then attach it to the `callStream`. Must only be called if the\n   * subchannel's current connectivity state is READY.\n   * @param metadata\n   * @param callStream\n   */\n  startCallStream(metadata, callStream, extraFilters) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session.request(headers);\n    } catch (e) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n      throw e;\n    }\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'call_stream', 'Starting stream [' + callStream.getCallNumber() + '] on subchannel ' + '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' with headers\\n' + headersString);\n    this.flowControlTrace('local window size: ' + this.session.state.localWindowSize + ' remote window size: ' + this.session.state.remoteWindowSize);\n    const streamSession = this.session;\n    this.internalsTrace('session.closed=' + streamSession.closed + ' session.destroyed=' + streamSession.destroyed + ' session.socket.destroyed=' + streamSession.socket.destroyed);\n    let statsTracker;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      callStream.addStatusWatcher(status => {\n        if (status.code === constants_1.Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n      this.streamTracker.addCallStarted();\n      callStream.addStreamEndWatcher(success => {\n        if (streamSession === this.session) {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n        }\n      });\n      statsTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n        }\n      };\n    } else {\n      statsTracker = {\n        addMessageSent: () => {},\n        addMessageReceived: () => {}\n      };\n    }\n    callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);\n  }\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n      if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener) {\n    this.stateListeners.push(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n  addDisconnectListener(listener) {\n    this.disconnectListeners.add(listener);\n  }\n  removeDisconnectListener(listener) {\n    this.disconnectListeners.delete(listener);\n  }\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n  }\n  getAddress() {\n    return this.subchannelAddressString;\n  }\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  getRealSubchannel() {\n    return this;\n  }\n}\nexports.Subchannel = Subchannel;\n//# sourceMappingURL=subchannel.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}