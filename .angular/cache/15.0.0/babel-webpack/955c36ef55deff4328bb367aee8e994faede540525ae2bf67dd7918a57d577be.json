{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ROOT_CONTEXT } from '@opentelemetry/api';\nimport { isListenerObject } from './util';\n/* Key name to be used to save a context reference in Zone */\nvar ZONE_CONTEXT_KEY = 'OT_ZONE_CONTEXT';\n/**\n * ZoneContextManager\n * This module provides an easy functionality for tracing action between asynchronous operations in web.\n * It was not possible with standard [StackContextManager]{@link https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-sdk-trace-web/src/StackContextManager.ts}.\n * It heavily depends on [zone.js]{@link https://www.npmjs.com/package/zone.js}.\n * It stores the information about context in zone. Each Context will have always new Zone;\n * It also supports binding a certain Span to a target that has \"addEventListener\" and \"removeEventListener\".\n * When this happens a new zone is being created and the provided Span is being assigned to this zone.\n */\nvar ZoneContextManager = /** @class */function () {\n  function ZoneContextManager() {\n    /**\n     * whether the context manager is enabled or not\n     */\n    this._enabled = false;\n    /**\n     * Helps to create a unique name for the zones - part of zone name\n     */\n    this._zoneCounter = 0;\n  }\n  /**\n   * Returns the active context from certain zone name\n   * @param activeZone\n   */\n  ZoneContextManager.prototype._activeContextFromZone = function (activeZone) {\n    return activeZone && activeZone.get(ZONE_CONTEXT_KEY) || ROOT_CONTEXT;\n  };\n  /**\n   * @param context A context (span) to be executed within target function\n   * @param target Function to be executed within the context\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  ZoneContextManager.prototype._bindFunction = function (context, target) {\n    var manager = this;\n    var contextWrapper = function () {\n      var _this = this;\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return manager.with(context, function () {\n        return target.apply(_this, args);\n      });\n    };\n    Object.defineProperty(contextWrapper, 'length', {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: target.length\n    });\n    return contextWrapper;\n  };\n  /**\n   * @param context A context (span) to be bind to target\n   * @param obj target object on which the listeners will be patched\n   */\n  ZoneContextManager.prototype._bindListener = function (context, obj) {\n    var target = obj;\n    if (target.__ot_listeners !== undefined) {\n      return obj;\n    }\n    target.__ot_listeners = {};\n    if (typeof target.addEventListener === 'function') {\n      target.addEventListener = this._patchAddEventListener(target, target.addEventListener, context);\n    }\n    if (typeof target.removeEventListener === 'function') {\n      target.removeEventListener = this._patchRemoveEventListener(target, target.removeEventListener);\n    }\n    return obj;\n  };\n  /**\n   * Creates a new unique zone name\n   */\n  ZoneContextManager.prototype._createZoneName = function () {\n    this._zoneCounter++;\n    var random = Math.random();\n    return this._zoneCounter + \"-\" + random;\n  };\n  /**\n   * Creates a new zone\n   * @param zoneName zone name\n   * @param context A context (span) to be bind with Zone\n   */\n  ZoneContextManager.prototype._createZone = function (zoneName, context) {\n    var _a;\n    return Zone.current.fork({\n      name: zoneName,\n      properties: (_a = {}, _a[ZONE_CONTEXT_KEY] = context, _a)\n    });\n  };\n  /**\n   * Returns the active zone\n   */\n  ZoneContextManager.prototype._getActiveZone = function () {\n    return Zone.current;\n  };\n  /**\n   * Patches addEventListener method\n   * @param target any target that has \"addEventListener\" method\n   * @param original reference to the patched method\n   * @param [context] context to be bind to the listener\n   */\n  ZoneContextManager.prototype._patchAddEventListener = function (target, original, context) {\n    var contextManager = this;\n    return function (event, listener, opts) {\n      if (target.__ot_listeners === undefined) {\n        target.__ot_listeners = {};\n      }\n      var listeners = target.__ot_listeners[event];\n      if (listeners === undefined) {\n        listeners = new WeakMap();\n        target.__ot_listeners[event] = listeners;\n      }\n      var patchedListener = contextManager.bind(context, listener);\n      // store a weak reference of the user listener to ours\n      listeners.set(listener, patchedListener);\n      return original.call(this, event, patchedListener, opts);\n    };\n  };\n  /**\n   * Patches removeEventListener method\n   * @param target any target that has \"removeEventListener\" method\n   * @param original reference to the patched method\n   */\n  ZoneContextManager.prototype._patchRemoveEventListener = function (target, original) {\n    return function (event, listener) {\n      if (target.__ot_listeners === undefined || target.__ot_listeners[event] === undefined) {\n        return original.call(this, event, listener);\n      }\n      var events = target.__ot_listeners[event];\n      var patchedListener = events.get(listener);\n      events.delete(listener);\n      return original.call(this, event, patchedListener || listener);\n    };\n  };\n  /**\n   * Returns the active context\n   */\n  ZoneContextManager.prototype.active = function () {\n    if (!this._enabled) {\n      return ROOT_CONTEXT;\n    }\n    var activeZone = this._getActiveZone();\n    var active = this._activeContextFromZone(activeZone);\n    if (active) {\n      return active;\n    }\n    return ROOT_CONTEXT;\n  };\n  /**\n   * Binds a the certain context or the active one to the target function and then returns the target\n   * @param context A context (span) to be bind to target\n   * @param target a function or event emitter. When target or one of its callbacks is called,\n   *  the provided context will be used as the active context for the duration of the call.\n   */\n  ZoneContextManager.prototype.bind = function (context, target) {\n    // if no specific context to propagate is given, we use the current one\n    if (context === undefined) {\n      context = this.active();\n    }\n    if (typeof target === 'function') {\n      return this._bindFunction(context, target);\n    } else if (isListenerObject(target)) {\n      this._bindListener(context, target);\n    }\n    return target;\n  };\n  /**\n   * Disable the context manager (clears all the contexts)\n   */\n  ZoneContextManager.prototype.disable = function () {\n    this._enabled = false;\n    return this;\n  };\n  /**\n   * Enables the context manager and creates a default(root) context\n   */\n  ZoneContextManager.prototype.enable = function () {\n    this._enabled = true;\n    return this;\n  };\n  /**\n   * Calls the callback function [fn] with the provided [context].\n   *     If [context] is undefined then it will use the active context.\n   *     The context will be set as active\n   * @param context A context (span) to be called with provided callback\n   * @param fn Callback function\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  ZoneContextManager.prototype.with = function (context, fn, thisArg) {\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n      args[_i - 3] = arguments[_i];\n    }\n    var zoneName = this._createZoneName();\n    var newZone = this._createZone(zoneName, context);\n    return newZone.run(fn, thisArg, args);\n  };\n  return ZoneContextManager;\n}();\nexport { ZoneContextManager };\n//# sourceMappingURL=ZoneContextManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}