{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { diag } from '@opentelemetry/api';\n/** Combines multiple propagators into a single propagator. */\nvar CompositePropagator = /** @class */function () {\n  /**\n   * Construct a composite propagator from a list of propagators.\n   *\n   * @param [config] Configuration object for composite propagator\n   */\n  function CompositePropagator(config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var _a;\n    this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];\n    this._fields = Array.from(new Set(this._propagators\n    // older propagators may not have fields function, null check to be sure\n    .map(function (p) {\n      return typeof p.fields === 'function' ? p.fields() : [];\n    }).reduce(function (x, y) {\n      return x.concat(y);\n    }, [])));\n  }\n  /**\n   * Run each of the configured propagators with the given context and carrier.\n   * Propagators are run in the order they are configured, so if multiple\n   * propagators write the same carrier key, the propagator later in the list\n   * will \"win\".\n   *\n   * @param context Context to inject\n   * @param carrier Carrier into which context will be injected\n   */\n  CompositePropagator.prototype.inject = function (context, carrier, setter) {\n    var e_1, _a;\n    try {\n      for (var _b = __values(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var propagator = _c.value;\n        try {\n          propagator.inject(context, carrier, setter);\n        } catch (err) {\n          diag.warn(\"Failed to inject with \" + propagator.constructor.name + \". Err: \" + err.message);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  /**\n   * Run each of the configured propagators with the given context and carrier.\n   * Propagators are run in the order they are configured, so if multiple\n   * propagators write the same context key, the propagator later in the list\n   * will \"win\".\n   *\n   * @param context Context to add values to\n   * @param carrier Carrier from which to extract context\n   */\n  CompositePropagator.prototype.extract = function (context, carrier, getter) {\n    return this._propagators.reduce(function (ctx, propagator) {\n      try {\n        return propagator.extract(ctx, carrier, getter);\n      } catch (err) {\n        diag.warn(\"Failed to inject with \" + propagator.constructor.name + \". Err: \" + err.message);\n      }\n      return ctx;\n    }, context);\n  };\n  CompositePropagator.prototype.fields = function () {\n    // return a new array so our fields cannot be modified\n    return this._fields.slice();\n  };\n  return CompositePropagator;\n}();\nexport { CompositePropagator };","map":{"version":3,"names":["__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","diag","CompositePropagator","config","_a","_propagators","propagators","_fields","Array","from","Set","map","p","fields","reduce","x","y","concat","prototype","inject","context","carrier","setter","e_1","_b","_c","propagator","err","warn","constructor","name","message","e_1_1","error","return","extract","getter","ctx","slice"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@opentelemetry/core/build/esm/propagation/composite.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { diag, } from '@opentelemetry/api';\n/** Combines multiple propagators into a single propagator. */\nvar CompositePropagator = /** @class */ (function () {\n    /**\n     * Construct a composite propagator from a list of propagators.\n     *\n     * @param [config] Configuration object for composite propagator\n     */\n    function CompositePropagator(config) {\n        if (config === void 0) { config = {}; }\n        var _a;\n        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];\n        this._fields = Array.from(new Set(this._propagators\n            // older propagators may not have fields function, null check to be sure\n            .map(function (p) { return (typeof p.fields === 'function' ? p.fields() : []); })\n            .reduce(function (x, y) { return x.concat(y); }, [])));\n    }\n    /**\n     * Run each of the configured propagators with the given context and carrier.\n     * Propagators are run in the order they are configured, so if multiple\n     * propagators write the same carrier key, the propagator later in the list\n     * will \"win\".\n     *\n     * @param context Context to inject\n     * @param carrier Carrier into which context will be injected\n     */\n    CompositePropagator.prototype.inject = function (context, carrier, setter) {\n        var e_1, _a;\n        try {\n            for (var _b = __values(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var propagator = _c.value;\n                try {\n                    propagator.inject(context, carrier, setter);\n                }\n                catch (err) {\n                    diag.warn(\"Failed to inject with \" + propagator.constructor.name + \". Err: \" + err.message);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    /**\n     * Run each of the configured propagators with the given context and carrier.\n     * Propagators are run in the order they are configured, so if multiple\n     * propagators write the same context key, the propagator later in the list\n     * will \"win\".\n     *\n     * @param context Context to add values to\n     * @param carrier Carrier from which to extract context\n     */\n    CompositePropagator.prototype.extract = function (context, carrier, getter) {\n        return this._propagators.reduce(function (ctx, propagator) {\n            try {\n                return propagator.extract(ctx, carrier, getter);\n            }\n            catch (err) {\n                diag.warn(\"Failed to inject with \" + propagator.constructor.name + \". Err: \" + err.message);\n            }\n            return ctx;\n        }, context);\n    };\n    CompositePropagator.prototype.fields = function () {\n        // return a new array so our fields cannot be modified\n        return this._fields.slice();\n    };\n    return CompositePropagator;\n}());\nexport { CompositePropagator };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}