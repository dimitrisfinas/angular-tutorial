{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { AttributeHashMap } from './HashMap';\n/**\n * Internal interface.\n *\n * Provides unique reporting for each collector. Allows synchronous collection\n * of metrics and reports given temporality values.\n */\nvar TemporalMetricProcessor = /** @class */function () {\n  function TemporalMetricProcessor(_aggregator) {\n    this._aggregator = _aggregator;\n    this._unreportedAccumulations = new Map();\n    this._reportHistory = new Map();\n  }\n  /**\n   * Builds the {@link MetricData} streams to report against a specific MetricCollector.\n   * @param collector The information of the MetricCollector.\n   * @param collectors The registered collectors.\n   * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.\n   * @param currentAccumulations The current accumulation of metric data from instruments.\n   * @param collectionTime The current collection timestamp.\n   * @returns The {@link MetricData} points or `null`.\n   */\n  TemporalMetricProcessor.prototype.buildMetrics = function (collector, collectors, instrumentDescriptor, currentAccumulations, collectionTime) {\n    this._stashAccumulations(collectors, currentAccumulations);\n    var unreportedAccumulations = this._getMergedUnreportedAccumulations(collector);\n    var result = unreportedAccumulations;\n    var aggregationTemporality;\n    // Check our last report time.\n    if (this._reportHistory.has(collector)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      var last = this._reportHistory.get(collector);\n      var lastCollectionTime = last.collectionTime;\n      aggregationTemporality = last.aggregationTemporality;\n      // Use aggregation temporality + instrument to determine if we do a merge or a diff of\n      // previous. We have the following four scenarios:\n      // 1. Cumulative Aggregation (temporality) + Delta recording (sync instrument).\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 2. Cumulative Aggregation + Cumulative recording (async instrument).\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 3. Delta Aggregation + Delta recording\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      // 4. Delta Aggregation + Cumulative recording.\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      if (aggregationTemporality === AggregationTemporality.CUMULATIVE) {\n        // We need to make sure the current delta recording gets merged into the previous cumulative\n        // for the next cumulative recording.\n        result = TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator);\n      } else {\n        result = TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);\n      }\n    } else {\n      // Call into user code to select aggregation temporality for the instrument.\n      aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);\n    }\n    // Update last reported (cumulative) accumulation.\n    this._reportHistory.set(collector, {\n      accumulations: result,\n      collectionTime: collectionTime,\n      aggregationTemporality: aggregationTemporality\n    });\n    return this._aggregator.toMetricData(instrumentDescriptor, aggregationTemporality, AttributesMapToAccumulationRecords(result), /* endTime */collectionTime);\n  };\n  TemporalMetricProcessor.prototype._stashAccumulations = function (collectors, currentAccumulation) {\n    var _this = this;\n    collectors.forEach(function (it) {\n      var stash = _this._unreportedAccumulations.get(it);\n      if (stash === undefined) {\n        stash = [];\n        _this._unreportedAccumulations.set(it, stash);\n      }\n      stash.push(currentAccumulation);\n    });\n  };\n  TemporalMetricProcessor.prototype._getMergedUnreportedAccumulations = function (collector) {\n    var e_1, _a;\n    var result = new AttributeHashMap();\n    var unreportedList = this._unreportedAccumulations.get(collector);\n    this._unreportedAccumulations.set(collector, []);\n    if (unreportedList === undefined) {\n      return result;\n    }\n    try {\n      for (var unreportedList_1 = __values(unreportedList), unreportedList_1_1 = unreportedList_1.next(); !unreportedList_1_1.done; unreportedList_1_1 = unreportedList_1.next()) {\n        var it_1 = unreportedList_1_1.value;\n        result = TemporalMetricProcessor.merge(result, it_1, this._aggregator);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (unreportedList_1_1 && !unreportedList_1_1.done && (_a = unreportedList_1.return)) _a.call(unreportedList_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return result;\n  };\n  TemporalMetricProcessor.merge = function (last, current, aggregator) {\n    var result = last;\n    var iterator = current.entries();\n    var next = iterator.next();\n    while (next.done !== true) {\n      var _a = __read(next.value, 3),\n        key = _a[0],\n        record = _a[1],\n        hash = _a[2];\n      if (last.has(key, hash)) {\n        var lastAccumulation = last.get(key, hash);\n        // last.has() returned true, lastAccumulation is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        var accumulation = aggregator.merge(lastAccumulation, record);\n        result.set(key, accumulation, hash);\n      } else {\n        result.set(key, record, hash);\n      }\n      next = iterator.next();\n    }\n    return result;\n  };\n  /**\n   * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves\n   * the new stream to be the initial observation time unchanged.\n   */\n  TemporalMetricProcessor.calibrateStartTime = function (last, current, lastCollectionTime) {\n    var e_2, _a;\n    try {\n      for (var _b = __values(last.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          key = _d[0],\n          hash = _d[1];\n        var currentAccumulation = current.get(key, hash);\n        currentAccumulation === null || currentAccumulation === void 0 ? void 0 : currentAccumulation.setStartTime(lastCollectionTime);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return current;\n  };\n  return TemporalMetricProcessor;\n}();\nexport { TemporalMetricProcessor };\n// TypeScript complains about converting 3 elements tuple to AccumulationRecord<T>.\nfunction AttributesMapToAccumulationRecords(map) {\n  return Array.from(map.entries());\n}","map":{"version":3,"names":["__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","__read","n","r","ar","e","push","error","AggregationTemporality","AttributeHashMap","TemporalMetricProcessor","_aggregator","_unreportedAccumulations","Map","_reportHistory","prototype","buildMetrics","collector","collectors","instrumentDescriptor","currentAccumulations","collectionTime","_stashAccumulations","unreportedAccumulations","_getMergedUnreportedAccumulations","result","aggregationTemporality","has","last","get","lastCollectionTime","CUMULATIVE","merge","accumulations","calibrateStartTime","selectAggregationTemporality","type","set","toMetricData","AttributesMapToAccumulationRecords","currentAccumulation","_this","forEach","it","stash","undefined","e_1","_a","unreportedList","unreportedList_1","unreportedList_1_1","it_1","e_1_1","return","current","aggregator","entries","key","record","hash","lastAccumulation","accumulation","e_2","_b","keys","_c","_d","setStartTime","e_2_1","map","Array","from"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@opentelemetry/sdk-metrics/build/esm/state/TemporalMetricProcessor.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { AttributeHashMap } from './HashMap';\n/**\n * Internal interface.\n *\n * Provides unique reporting for each collector. Allows synchronous collection\n * of metrics and reports given temporality values.\n */\nvar TemporalMetricProcessor = /** @class */ (function () {\n    function TemporalMetricProcessor(_aggregator) {\n        this._aggregator = _aggregator;\n        this._unreportedAccumulations = new Map();\n        this._reportHistory = new Map();\n    }\n    /**\n     * Builds the {@link MetricData} streams to report against a specific MetricCollector.\n     * @param collector The information of the MetricCollector.\n     * @param collectors The registered collectors.\n     * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.\n     * @param currentAccumulations The current accumulation of metric data from instruments.\n     * @param collectionTime The current collection timestamp.\n     * @returns The {@link MetricData} points or `null`.\n     */\n    TemporalMetricProcessor.prototype.buildMetrics = function (collector, collectors, instrumentDescriptor, currentAccumulations, collectionTime) {\n        this._stashAccumulations(collectors, currentAccumulations);\n        var unreportedAccumulations = this._getMergedUnreportedAccumulations(collector);\n        var result = unreportedAccumulations;\n        var aggregationTemporality;\n        // Check our last report time.\n        if (this._reportHistory.has(collector)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            var last = this._reportHistory.get(collector);\n            var lastCollectionTime = last.collectionTime;\n            aggregationTemporality = last.aggregationTemporality;\n            // Use aggregation temporality + instrument to determine if we do a merge or a diff of\n            // previous. We have the following four scenarios:\n            // 1. Cumulative Aggregation (temporality) + Delta recording (sync instrument).\n            //    Here we merge with our last record to get a cumulative aggregation.\n            // 2. Cumulative Aggregation + Cumulative recording (async instrument).\n            //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n            //    Here we merge with our last record to get a cumulative aggregation.\n            // 3. Delta Aggregation + Delta recording\n            //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n            // 4. Delta Aggregation + Cumulative recording.\n            //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n            //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n            if (aggregationTemporality === AggregationTemporality.CUMULATIVE) {\n                // We need to make sure the current delta recording gets merged into the previous cumulative\n                // for the next cumulative recording.\n                result = TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator);\n            }\n            else {\n                result = TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);\n            }\n        }\n        else {\n            // Call into user code to select aggregation temporality for the instrument.\n            aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);\n        }\n        // Update last reported (cumulative) accumulation.\n        this._reportHistory.set(collector, {\n            accumulations: result,\n            collectionTime: collectionTime,\n            aggregationTemporality: aggregationTemporality,\n        });\n        return this._aggregator.toMetricData(instrumentDescriptor, aggregationTemporality, AttributesMapToAccumulationRecords(result), \n        /* endTime */ collectionTime);\n    };\n    TemporalMetricProcessor.prototype._stashAccumulations = function (collectors, currentAccumulation) {\n        var _this = this;\n        collectors.forEach(function (it) {\n            var stash = _this._unreportedAccumulations.get(it);\n            if (stash === undefined) {\n                stash = [];\n                _this._unreportedAccumulations.set(it, stash);\n            }\n            stash.push(currentAccumulation);\n        });\n    };\n    TemporalMetricProcessor.prototype._getMergedUnreportedAccumulations = function (collector) {\n        var e_1, _a;\n        var result = new AttributeHashMap();\n        var unreportedList = this._unreportedAccumulations.get(collector);\n        this._unreportedAccumulations.set(collector, []);\n        if (unreportedList === undefined) {\n            return result;\n        }\n        try {\n            for (var unreportedList_1 = __values(unreportedList), unreportedList_1_1 = unreportedList_1.next(); !unreportedList_1_1.done; unreportedList_1_1 = unreportedList_1.next()) {\n                var it_1 = unreportedList_1_1.value;\n                result = TemporalMetricProcessor.merge(result, it_1, this._aggregator);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (unreportedList_1_1 && !unreportedList_1_1.done && (_a = unreportedList_1.return)) _a.call(unreportedList_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return result;\n    };\n    TemporalMetricProcessor.merge = function (last, current, aggregator) {\n        var result = last;\n        var iterator = current.entries();\n        var next = iterator.next();\n        while (next.done !== true) {\n            var _a = __read(next.value, 3), key = _a[0], record = _a[1], hash = _a[2];\n            if (last.has(key, hash)) {\n                var lastAccumulation = last.get(key, hash);\n                // last.has() returned true, lastAccumulation is present.\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                var accumulation = aggregator.merge(lastAccumulation, record);\n                result.set(key, accumulation, hash);\n            }\n            else {\n                result.set(key, record, hash);\n            }\n            next = iterator.next();\n        }\n        return result;\n    };\n    /**\n     * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves\n     * the new stream to be the initial observation time unchanged.\n     */\n    TemporalMetricProcessor.calibrateStartTime = function (last, current, lastCollectionTime) {\n        var e_2, _a;\n        try {\n            for (var _b = __values(last.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _d = __read(_c.value, 2), key = _d[0], hash = _d[1];\n                var currentAccumulation = current.get(key, hash);\n                currentAccumulation === null || currentAccumulation === void 0 ? void 0 : currentAccumulation.setStartTime(lastCollectionTime);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return current;\n    };\n    return TemporalMetricProcessor;\n}());\nexport { TemporalMetricProcessor };\n// TypeScript complains about converting 3 elements tuple to AccumulationRecord<T>.\nfunction AttributesMapToAccumulationRecords(map) {\n    return Array.from(map.entries());\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}