{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadPackageDefinition = exports.makeClientConstructor = void 0;\nconst client_1 = require(\"./client\");\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */\nconst requesterFuncs = {\n  unary: client_1.Client.prototype.makeUnaryRequest,\n  server_stream: client_1.Client.prototype.makeServerStreamRequest,\n  client_stream: client_1.Client.prototype.makeClientStreamRequest,\n  bidi: client_1.Client.prototype.makeBidiStreamRequest\n};\n/**\n * Returns true, if given key is included in the blacklisted\n * keys.\n * @param key key for check, string.\n */\nfunction isPrototypePolluted(key) {\n  return ['__proto__', 'prototype', 'constructor'].includes(key);\n}\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @param methods An object mapping method names to\n *     method attributes\n * @param serviceName The fully qualified name of the service\n * @param classOptions An options object.\n * @return New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */\nfunction makeClientConstructor(methods, serviceName, classOptions) {\n  if (!classOptions) {\n    classOptions = {};\n  }\n  class ServiceClientImpl extends client_1.Client {}\n  Object.keys(methods).forEach(name => {\n    if (isPrototypePolluted(name)) {\n      return;\n    }\n    const attrs = methods[name];\n    let methodType;\n    // TODO(murgatroid99): Verify that we don't need this anymore\n    if (typeof name === 'string' && name.charAt(0) === '$') {\n      throw new Error('Method names cannot start with $');\n    }\n    if (attrs.requestStream) {\n      if (attrs.responseStream) {\n        methodType = 'bidi';\n      } else {\n        methodType = 'client_stream';\n      }\n    } else {\n      if (attrs.responseStream) {\n        methodType = 'server_stream';\n      } else {\n        methodType = 'unary';\n      }\n    }\n    const serialize = attrs.requestSerialize;\n    const deserialize = attrs.responseDeserialize;\n    const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\n    ServiceClientImpl.prototype[name] = methodFunc;\n    // Associate all provided attributes with the method\n    Object.assign(ServiceClientImpl.prototype[name], attrs);\n    if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {\n      ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name];\n    }\n  });\n  ServiceClientImpl.service = methods;\n  ServiceClientImpl.serviceName = serviceName;\n  return ServiceClientImpl;\n}\nexports.makeClientConstructor = makeClientConstructor;\nfunction partial(fn, path, serialize, deserialize) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (...args) {\n    return fn.call(this, path, serialize, deserialize, ...args);\n  };\n}\nfunction isProtobufTypeDefinition(obj) {\n  return 'format' in obj;\n}\n/**\n * Load a gRPC package definition as a gRPC object hierarchy.\n * @param packageDef The package definition object.\n * @return The resulting gRPC object.\n */\nfunction loadPackageDefinition(packageDef) {\n  const result = {};\n  for (const serviceFqn in packageDef) {\n    if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {\n      const service = packageDef[serviceFqn];\n      const nameComponents = serviceFqn.split('.');\n      if (nameComponents.some(comp => isPrototypePolluted(comp))) {\n        continue;\n      }\n      const serviceName = nameComponents[nameComponents.length - 1];\n      let current = result;\n      for (const packageName of nameComponents.slice(0, -1)) {\n        if (!current[packageName]) {\n          current[packageName] = {};\n        }\n        current = current[packageName];\n      }\n      if (isProtobufTypeDefinition(service)) {\n        current[serviceName] = service;\n      } else {\n        current[serviceName] = makeClientConstructor(service, serviceName, {});\n      }\n    }\n  }\n  return result;\n}\nexports.loadPackageDefinition = loadPackageDefinition;\n//# sourceMappingURL=make-client.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}