{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.RoundRobinLoadBalancer = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst picker_1 = require(\"./picker\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst TRACER_NAME = 'round_robin';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'round_robin';\nclass RoundRobinLoadBalancingConfig {\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n  constructor() {}\n  toJsonObject() {\n    return {\n      [TYPE_NAME]: {}\n    };\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj) {\n    return new RoundRobinLoadBalancingConfig();\n  }\n}\nclass RoundRobinPicker {\n  constructor(subchannelList, nextIndex = 0) {\n    this.subchannelList = subchannelList;\n    this.nextIndex = nextIndex;\n  }\n  pick(pickArgs) {\n    const pickedSubchannel = this.subchannelList[this.nextIndex];\n    this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n    return {\n      pickResultType: picker_1.PickResultType.COMPLETE,\n      subchannel: pickedSubchannel,\n      status: null,\n      extraFilterFactories: [],\n      onCallStarted: null\n    };\n  }\n  /**\n   * Check what the next subchannel returned would be. Used by the load\n   * balancer implementation to preserve this part of the picker state if\n   * possible when a subchannel connects or disconnects.\n   */\n  peekNextSubchannel() {\n    return this.subchannelList[this.nextIndex];\n  }\n}\nclass RoundRobinLoadBalancer {\n  constructor(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n    this.subchannels = [];\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    this.currentReadyPicker = null;\n    this.subchannelStateCounts = {\n      [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n      [connectivity_state_1.ConnectivityState.IDLE]: 0,\n      [connectivity_state_1.ConnectivityState.READY]: 0,\n      [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n      [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n    this.subchannelStateListener = (subchannel, previousState, newState) => {\n      this.subchannelStateCounts[previousState] -= 1;\n      this.subchannelStateCounts[newState] += 1;\n      this.calculateAndUpdateState();\n      if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE || newState === connectivity_state_1.ConnectivityState.IDLE) {\n        this.channelControlHelper.requestReresolution();\n        subchannel.startConnecting();\n      }\n    };\n  }\n  calculateAndUpdateState() {\n    if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.READY] > 0) {\n      const readySubchannels = this.subchannels.filter(subchannel => subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\n      let index = 0;\n      if (this.currentReadyPicker !== null) {\n        index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\n        if (index < 0) {\n          index = 0;\n        }\n      }\n      this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\n    } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n      this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n    } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n      this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n    } else {\n      this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    }\n  }\n  updateState(newState, picker) {\n    trace(connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    if (newState === connectivity_state_1.ConnectivityState.READY) {\n      this.currentReadyPicker = picker;\n    } else {\n      this.currentReadyPicker = null;\n    }\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n  resetSubchannelList() {\n    for (const subchannel of this.subchannels) {\n      subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n    }\n    this.subchannelStateCounts = {\n      [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n      [connectivity_state_1.ConnectivityState.IDLE]: 0,\n      [connectivity_state_1.ConnectivityState.READY]: 0,\n      [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n      [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n    this.subchannels = [];\n  }\n  updateAddressList(addressList, lbConfig) {\n    this.resetSubchannelList();\n    trace('Connect to address list ' + addressList.map(address => subchannel_address_1.subchannelAddressToString(address)));\n    this.subchannels = addressList.map(address => this.channelControlHelper.createSubchannel(address, {}));\n    for (const subchannel of this.subchannels) {\n      subchannel.ref();\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n      const subchannelState = subchannel.getConnectivityState();\n      this.subchannelStateCounts[subchannelState] += 1;\n      if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        subchannel.startConnecting();\n      }\n    }\n    this.calculateAndUpdateState();\n  }\n  exitIdle() {\n    for (const subchannel of this.subchannels) {\n      subchannel.startConnecting();\n    }\n  }\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n  destroy() {\n    this.resetSubchannelList();\n  }\n  getTypeName() {\n    return TYPE_NAME;\n  }\n}\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\nfunction setup() {\n  load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\n}\nexports.setup = setup;\n//# sourceMappingURL=load-balancer-round-robin.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}