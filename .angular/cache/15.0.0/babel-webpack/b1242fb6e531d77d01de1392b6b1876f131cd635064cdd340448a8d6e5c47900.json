{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subchannel = void 0;\nconst http2 = require(\"http2\");\nconst tls_1 = require(\"tls\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst resolver_1 = require(\"./resolver\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst net = require(\"net\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst channelz_1 = require(\"./channelz\");\nconst clientVersion = require('../../package.json').version;\nconst TRACER_NAME = 'subchannel';\nconst FLOW_CONTROL_TRACER_NAME = 'subchannel_flowctrl';\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT\n} = http2.constants;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\nclass Subchannel {\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(channelTarget, subchannelAddress, options, credentials) {\n    this.channelTarget = channelTarget;\n    this.subchannelAddress = subchannelAddress;\n    this.options = options;\n    this.credentials = credentials;\n    /**\n     * The subchannel's current connectivity state. Invariant: `session` === `null`\n     * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n     */\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The underlying http2 session used to make requests.\n     */\n    this.session = null;\n    /**\n     * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n     * CONNECTING instead of IDLE when the backoff timeout ends.\n     */\n    this.continueConnecting = false;\n    /**\n     * A list of listener functions that will be called whenever the connectivity\n     * state changes. Will be modified by `addConnectivityStateListener` and\n     * `removeConnectivityStateListener`\n     */\n    this.stateListeners = [];\n    /**\n     * A list of listener functions that will be called when the underlying\n     * socket disconnects. Used for ending active calls with an UNAVAILABLE\n     * status.\n     */\n    this.disconnectListeners = new Set();\n    /**\n     * The amount of time in between sending pings\n     */\n    this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;\n    /**\n     * The amount of time to wait for an acknowledgement after sending a ping\n     */\n    this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    /**\n     * Indicates whether keepalive pings should be sent without any active calls\n     */\n    this.keepaliveWithoutCalls = false;\n    /**\n     * Tracks calls with references to this subchannel\n     */\n    this.callRefcount = 0;\n    /**\n     * Tracks channels and subchannel pools with references to this subchannel\n     */\n    this.refcount = 0;\n    // Channelz info\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n    // Channelz socket info\n    this.channelzSocketRef = null;\n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n    // Build user-agent string.\n    this.userAgent = [options['grpc.primary_user_agent'], `grpc-node-js/${clientVersion}`, options['grpc.secondary_user_agent']].filter(e => e).join(' '); // remove falsey values first\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls = options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    this.keepaliveTimeoutId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveTimeoutId);\n    const backoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = subchannel_address_1.subchannelAddressToString(subchannelAddress);\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.channelzRef = channelz_1.registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    }\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n  getChannelzInfo() {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n  getChannelzSocketInfo() {\n    var _a, _b, _c;\n    if (this.session === null) {\n      return null;\n    }\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo;\n    if (this.session.encrypted) {\n      const tlsSocket = sessionSocket;\n      const cipherInfo = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n      remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n    };\n    return socketInfo;\n  }\n  resetChannelzSocketInfo() {\n    if (!this.channelzEnabled) {\n      return;\n    }\n    if (this.channelzSocketRef) {\n      channelz_1.unregisterChannelzRef(this.channelzSocketRef);\n      this.childrenTracker.unrefChild(this.channelzSocketRef);\n      this.channelzSocketRef = null;\n    }\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  refTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  flowControlTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  internalsTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  keepaliveTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    } else {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n    }\n  }\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n  stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n  sendPing() {\n    var _a, _b;\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n    this.keepaliveTimeoutId = setTimeout(() => {\n      this.keepaliveTrace('Ping timeout passed without response');\n      this.handleDisconnect();\n    }, this.keepaliveTimeoutMs);\n    (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    try {\n      this.session.ping((err, duration, payload) => {\n        this.keepaliveTrace('Received ping response');\n        clearTimeout(this.keepaliveTimeoutId);\n      });\n    } catch (e) {\n      /* If we fail to send a ping, the connection is no longer functional, so\n       * we should discard it. */\n      this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    }\n  }\n  startKeepalivePings() {\n    var _a, _b;\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n  /**\n   * Stop keepalive pings when terminating a connection. This discards the\n   * outstanding ping timeout, so it should not be called if the same\n   * connection will still be used.\n   */\n  stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    clearTimeout(this.keepaliveTimeoutId);\n  }\n  createSession(proxyConnectionResult) {\n    var _a, _b, _c;\n    if (proxyConnectionResult.realTarget) {\n      this.remoteName = uri_parser_1.uriToString(proxyConnectionResult.realTarget);\n      this.trace('creating HTTP/2 session through proxy to ' + proxyConnectionResult.realTarget);\n    } else {\n      this.remoteName = null;\n      this.trace('creating HTTP/2 session');\n    }\n    const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n    let connectionOptions = this.credentials._getConnectionOptions() || {};\n    connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n    if ('grpc-node.max_session_memory' in this.options) {\n      connectionOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n    } else {\n      /* By default, set a very large max session memory limit, to effectively\n       * disable enforcement of the limit. Some testing indicates that Node's\n       * behavior degrades badly when this limit is reached, so we solve that\n       * by disabling the check entirely. */\n      connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n    }\n    let addressScheme = 'http://';\n    if ('secureContext' in connectionOptions) {\n      addressScheme = 'https://';\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost';\n        // We want to always set servername to support SNI\n        connectionOptions.servername = authorityHostname;\n      }\n      if (proxyConnectionResult.socket) {\n        /* This is part of the workaround for\n         * https://github.com/nodejs/node/issues/32922. Without that bug,\n         * proxyConnectionResult.socket would always be a plaintext socket and\n         * this would say\n         * connectionOptions.socket = proxyConnectionResult.socket; */\n        connectionOptions.createConnection = (authority, option) => {\n          return proxyConnectionResult.socket;\n        };\n      }\n    } else {\n      /* In all but the most recent versions of Node, http2.connect does not use\n       * the options when establishing plaintext connections, so we need to\n       * establish that connection explicitly. */\n      connectionOptions.createConnection = (authority, option) => {\n        if (proxyConnectionResult.socket) {\n          return proxyConnectionResult.socket;\n        } else {\n          /* net.NetConnectOpts is declared in a way that is more restrictive\n           * than what net.connect will actually accept, so we use the type\n           * assertion to work around that. */\n          return net.connect(this.subchannelAddress);\n        }\n      };\n    }\n    connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);\n    /* http2.connect uses the options here:\n     * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n     * The spread operator overides earlier values with later ones, so any port\n     * or host values in the options will be used rather than any values extracted\n     * from the first argument. In addition, the path overrides the host and port,\n     * as documented for plaintext connections here:\n     * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n     * and for TLS connections here:\n     * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n     * earlier versions of Node, http2.connect passes these options to\n     * tls.connect but not net.connect, so in the insecure case we still need\n     * to set the createConnection option above to create the connection\n     * explicitly. We cannot do that in the TLS case because http2.connect\n     * passes necessary additional options to tls.connect.\n     * The first argument just needs to be parseable as a URL and the scheme\n     * determines whether the connection will be established over TLS or not.\n     */\n    const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n    this.session = session;\n    this.channelzSocketRef = channelz_1.registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzSocketInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.childrenTracker.refChild(this.channelzSocketRef);\n    }\n    session.unref();\n    /* For all of these events, check if the session at the time of the event\n     * is the same one currently attached to this subchannel, to ensure that\n     * old events from previous connection attempts cannot cause invalid state\n     * transitions. */\n    session.once('connect', () => {\n      if (this.session === session) {\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY);\n      }\n    });\n    session.once('close', () => {\n      if (this.session === session) {\n        this.trace('connection closed');\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        /* Transitioning directly to IDLE here should be OK because we are not\n         * doing any backoff, because a connection was established at some\n         * point */\n        this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n      if (this.session === session) {\n        /* See the last paragraph of\n         * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n        if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {\n          this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);\n          logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${uri_parser_1.uriToString(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);\n        }\n        this.trace('connection closed by GOAWAY with code ' + errorCode);\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('error', error => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace('connection closed with error ' + error.message);\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', settings => {\n        this.trace('new settings received' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n      session.on('localSettings', settings => {\n        this.trace('local settings acknowledged by remote' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n    }\n  }\n  startConnectingInternal() {\n    var _a, _b;\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions = this.credentials._getConnectionOptions() || {};\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in this.options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {\n            path: 'localhost'\n          });\n          const hostPort = uri_parser_1.splitHostPort(targetPath);\n          connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n        }\n      }\n    }\n    http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then(result => {\n      this.createSession(result);\n    }, reason => {\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    });\n  }\n  handleDisconnect() {\n    this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    for (const listener of this.disconnectListeners.values()) {\n      listener();\n    }\n  }\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  transitionToState(oldStates, newState) {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case connectivity_state_1.ConnectivityState.READY:\n        this.stopBackoff();\n        const session = this.session;\n        session.socket.once('close', () => {\n          if (this.session === session) {\n            this.handleDisconnect();\n          }\n        });\n        if (this.keepaliveWithoutCalls) {\n          this.startKeepalivePings();\n        }\n        break;\n      case connectivity_state_1.ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case connectivity_state_1.ConnectivityState.IDLE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState);\n    }\n    return true;\n  }\n  /**\n   * Check if the subchannel associated with zero calls and with zero channels.\n   * If so, shut it down.\n   */\n  checkBothRefcounts() {\n    /* If no calls, channels, or subchannel pools have any more references to\n     * this subchannel, we can be sure it will never be used again. */\n    if (this.callRefcount === 0 && this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      if (this.channelzEnabled) {\n        channelz_1.unregisterChannelzRef(this.channelzRef);\n      }\n    }\n  }\n  callRef() {\n    this.refTrace('callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount + 1));\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.ref();\n      }\n      this.backoffTimeout.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n    this.callRefcount += 1;\n  }\n  callUnref() {\n    this.refTrace('callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount - 1));\n    this.callRefcount -= 1;\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.unref();\n      }\n      this.backoffTimeout.unref();\n      if (!this.keepaliveWithoutCalls) {\n        clearInterval(this.keepaliveIntervalId);\n      }\n      this.checkBothRefcounts();\n    }\n  }\n  ref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n  unref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    this.checkBothRefcounts();\n  }\n  unrefIfOneRef() {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Start a stream on the current session with the given `metadata` as headers\n   * and then attach it to the `callStream`. Must only be called if the\n   * subchannel's current connectivity state is READY.\n   * @param metadata\n   * @param callStream\n   */\n  startCallStream(metadata, callStream, extraFilters) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session.request(headers);\n    } catch (e) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n      throw e;\n    }\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'call_stream', 'Starting stream [' + callStream.getCallNumber() + '] on subchannel ' + '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' with headers\\n' + headersString);\n    this.flowControlTrace('local window size: ' + this.session.state.localWindowSize + ' remote window size: ' + this.session.state.remoteWindowSize);\n    const streamSession = this.session;\n    this.internalsTrace('session.closed=' + streamSession.closed + ' session.destroyed=' + streamSession.destroyed + ' session.socket.destroyed=' + streamSession.socket.destroyed);\n    let statsTracker;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      callStream.addStatusWatcher(status => {\n        if (status.code === constants_1.Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n      this.streamTracker.addCallStarted();\n      callStream.addStreamEndWatcher(success => {\n        if (streamSession === this.session) {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n        }\n      });\n      statsTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n        }\n      };\n    } else {\n      statsTracker = {\n        addMessageSent: () => {},\n        addMessageReceived: () => {}\n      };\n    }\n    callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);\n  }\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n      if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener) {\n    this.stateListeners.push(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n  addDisconnectListener(listener) {\n    this.disconnectListeners.add(listener);\n  }\n  removeDisconnectListener(listener) {\n    this.disconnectListeners.delete(listener);\n  }\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n  }\n  getAddress() {\n    return this.subchannelAddressString;\n  }\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  getRealSubchannel() {\n    return this;\n  }\n}\nexports.Subchannel = Subchannel;","map":{"version":3,"names":["Object","defineProperty","exports","value","Subchannel","http2","require","tls_1","connectivity_state_1","backoff_timeout_1","resolver_1","logging","constants_1","http_proxy_1","net","uri_parser_1","subchannel_address_1","channelz_1","clientVersion","version","TRACER_NAME","FLOW_CONTROL_TRACER_NAME","MIN_CONNECT_TIMEOUT_MS","INITIAL_BACKOFF_MS","BACKOFF_MULTIPLIER","MAX_BACKOFF_MS","BACKOFF_JITTER","KEEPALIVE_MAX_TIME_MS","KEEPALIVE_TIMEOUT_MS","HTTP2_HEADER_AUTHORITY","HTTP2_HEADER_CONTENT_TYPE","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_TE","HTTP2_HEADER_USER_AGENT","constants","uniformRandom","min","max","Math","random","tooManyPingsData","Buffer","from","constructor","channelTarget","subchannelAddress","options","credentials","connectivityState","ConnectivityState","IDLE","session","continueConnecting","stateListeners","disconnectListeners","Set","keepaliveTimeMs","keepaliveTimeoutMs","keepaliveWithoutCalls","callRefcount","refcount","channelzEnabled","callTracker","ChannelzCallTracker","childrenTracker","ChannelzChildrenTracker","channelzSocketRef","remoteName","streamTracker","keepalivesSent","messagesSent","messagesReceived","lastMessageSentTimestamp","lastMessageReceivedTimestamp","userAgent","filter","e","join","keepaliveIntervalId","setTimeout","clearTimeout","keepaliveTimeoutId","backoffOptions","initialDelay","maxDelay","backoffTimeout","BackoffTimeout","handleBackoffTimer","subchannelAddressString","subchannelAddressToString","channelzTrace","ChannelzTrace","channelzRef","registerChannelzSubchannel","getChannelzInfo","addTrace","trace","JSON","stringify","undefined","state","children","getChildLists","target","getChannelzSocketInfo","_a","_b","_c","sessionSocket","socket","remoteAddress","stringToSubchannelAddress","remotePort","localAddress","localPort","tlsInfo","encrypted","tlsSocket","cipherInfo","getCipher","certificate","getCertificate","peerCertificate","getPeerCertificate","cipherSuiteStandardName","standardName","cipherSuiteOtherName","name","localCertificate","raw","remoteCertificate","socketInfo","security","streamsStarted","callsStarted","streamsSucceeded","callsSucceeded","streamsFailed","callsFailed","keepAlivesSent","lastLocalStreamCreatedTimestamp","lastCallStartedTimestamp","lastRemoteStreamCreatedTimestamp","localFlowControlWindow","localWindowSize","remoteFlowControlWindow","remoteWindowSize","resetChannelzSocketInfo","unregisterChannelzRef","unrefChild","text","LogVerbosity","DEBUG","id","refTrace","flowControlTrace","internalsTrace","keepaliveTrace","transitionToState","TRANSIENT_FAILURE","CONNECTING","startBackoff","runOnce","stopBackoff","stop","reset","sendPing","handleDisconnect","unref","call","ping","err","duration","payload","READY","startKeepalivePings","setInterval","stopKeepalivePings","clearInterval","createSession","proxyConnectionResult","realTarget","uriToString","targetAuthority","getDefaultAuthority","connectionOptions","_getConnectionOptions","maxSendHeaderBlockLength","Number","MAX_SAFE_INTEGER","maxSessionMemory","addressScheme","sslTargetNameOverride","checkServerIdentity","host","cert","servername","authorityHostname","splitHostPort","createConnection","authority","option","connect","assign","registerChannelzSocket","refChild","once","errorCode","lastStreamID","opaqueData","NGHTTP2_ENHANCE_YOUR_CALM","equals","log","ERROR","error","message","isTracerEnabled","on","settings","startConnectingInternal","ALPNProtocols","targetPath","parseUri","path","hostPort","getProxiedConnection","then","result","reason","listener","values","oldStates","newState","indexOf","previousState","close","isRunning","process","nextTick","Error","checkBothRefcounts","callRef","ref","callUnref","unrefIfOneRef","startCallStream","metadata","callStream","extraFilters","headers","toHttp2Headers","getHost","getMethod","http2Stream","request","headersString","header","keys","getCallNumber","streamSession","closed","destroyed","statsTracker","addCallStarted","addStatusWatcher","status","code","Status","OK","addCallSucceeded","addCallFailed","addStreamEndWatcher","success","addMessageSent","Date","addMessageReceived","attachHttp2Stream","startConnecting","getConnectivityState","addConnectivityStateListener","push","removeConnectivityStateListener","listenerIndex","splice","addDisconnectListener","add","removeDisconnectListener","delete","resetBackoff","getAddress","getChannelzRef","getRealSubchannel"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/subchannel.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subchannel = void 0;\nconst http2 = require(\"http2\");\nconst tls_1 = require(\"tls\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst resolver_1 = require(\"./resolver\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst net = require(\"net\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst channelz_1 = require(\"./channelz\");\nconst clientVersion = require('../../package.json').version;\nconst TRACER_NAME = 'subchannel';\nconst FLOW_CONTROL_TRACER_NAME = 'subchannel_flowctrl';\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT, } = http2.constants;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\nclass Subchannel {\n    /**\n     * A class representing a connection to a single backend.\n     * @param channelTarget The target string for the channel as a whole\n     * @param subchannelAddress The address for the backend that this subchannel\n     *     will connect to\n     * @param options The channel options, plus any specific subchannel options\n     *     for this subchannel\n     * @param credentials The channel credentials used to establish this\n     *     connection\n     */\n    constructor(channelTarget, subchannelAddress, options, credentials) {\n        this.channelTarget = channelTarget;\n        this.subchannelAddress = subchannelAddress;\n        this.options = options;\n        this.credentials = credentials;\n        /**\n         * The subchannel's current connectivity state. Invariant: `session` === `null`\n         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n         */\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The underlying http2 session used to make requests.\n         */\n        this.session = null;\n        /**\n         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n         * CONNECTING instead of IDLE when the backoff timeout ends.\n         */\n        this.continueConnecting = false;\n        /**\n         * A list of listener functions that will be called whenever the connectivity\n         * state changes. Will be modified by `addConnectivityStateListener` and\n         * `removeConnectivityStateListener`\n         */\n        this.stateListeners = [];\n        /**\n         * A list of listener functions that will be called when the underlying\n         * socket disconnects. Used for ending active calls with an UNAVAILABLE\n         * status.\n         */\n        this.disconnectListeners = new Set();\n        /**\n         * The amount of time in between sending pings\n         */\n        this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;\n        /**\n         * The amount of time to wait for an acknowledgement after sending a ping\n         */\n        this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n        /**\n         * Indicates whether keepalive pings should be sent without any active calls\n         */\n        this.keepaliveWithoutCalls = false;\n        /**\n         * Tracks calls with references to this subchannel\n         */\n        this.callRefcount = 0;\n        /**\n         * Tracks channels and subchannel pools with references to this subchannel\n         */\n        this.refcount = 0;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        // Channelz socket info\n        this.channelzSocketRef = null;\n        /**\n         * Name of the remote server, if it is not the same as the subchannel\n         * address, i.e. if connecting through an HTTP CONNECT proxy.\n         */\n        this.remoteName = null;\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        this.keepalivesSent = 0;\n        this.messagesSent = 0;\n        this.messagesReceived = 0;\n        this.lastMessageSentTimestamp = null;\n        this.lastMessageReceivedTimestamp = null;\n        // Build user-agent string.\n        this.userAgent = [\n            options['grpc.primary_user_agent'],\n            `grpc-node-js/${clientVersion}`,\n            options['grpc.secondary_user_agent'],\n        ]\n            .filter((e) => e)\n            .join(' '); // remove falsey values first\n        if ('grpc.keepalive_time_ms' in options) {\n            this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n        }\n        if ('grpc.keepalive_timeout_ms' in options) {\n            this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n        }\n        if ('grpc.keepalive_permit_without_calls' in options) {\n            this.keepaliveWithoutCalls =\n                options['grpc.keepalive_permit_without_calls'] === 1;\n        }\n        else {\n            this.keepaliveWithoutCalls = false;\n        }\n        this.keepaliveIntervalId = setTimeout(() => { }, 0);\n        clearTimeout(this.keepaliveIntervalId);\n        this.keepaliveTimeoutId = setTimeout(() => { }, 0);\n        clearTimeout(this.keepaliveTimeoutId);\n        const backoffOptions = {\n            initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: options['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n            this.handleBackoffTimer();\n        }, backoffOptions);\n        this.subchannelAddressString = subchannel_address_1.subchannelAddressToString(subchannelAddress);\n        if (options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = channelz_1.registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n        }\n        this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n    }\n    getChannelzInfo() {\n        return {\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists(),\n            target: this.subchannelAddressString\n        };\n    }\n    getChannelzSocketInfo() {\n        var _a, _b, _c;\n        if (this.session === null) {\n            return null;\n        }\n        const sessionSocket = this.session.socket;\n        const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n        const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n        let tlsInfo;\n        if (this.session.encrypted) {\n            const tlsSocket = sessionSocket;\n            const cipherInfo = tlsSocket.getCipher();\n            const certificate = tlsSocket.getCertificate();\n            const peerCertificate = tlsSocket.getPeerCertificate();\n            tlsInfo = {\n                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,\n                remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null\n            };\n        }\n        else {\n            tlsInfo = null;\n        }\n        const socketInfo = {\n            remoteAddress: remoteAddress,\n            localAddress: localAddress,\n            security: tlsInfo,\n            remoteName: this.remoteName,\n            streamsStarted: this.streamTracker.callsStarted,\n            streamsSucceeded: this.streamTracker.callsSucceeded,\n            streamsFailed: this.streamTracker.callsFailed,\n            messagesSent: this.messagesSent,\n            messagesReceived: this.messagesReceived,\n            keepAlivesSent: this.keepalivesSent,\n            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n            lastRemoteStreamCreatedTimestamp: null,\n            lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n        };\n        return socketInfo;\n    }\n    resetChannelzSocketInfo() {\n        if (!this.channelzEnabled) {\n            return;\n        }\n        if (this.channelzSocketRef) {\n            channelz_1.unregisterChannelzRef(this.channelzSocketRef);\n            this.childrenTracker.unrefChild(this.channelzSocketRef);\n            this.channelzSocketRef = null;\n        }\n        this.remoteName = null;\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        this.keepalivesSent = 0;\n        this.messagesSent = 0;\n        this.messagesReceived = 0;\n        this.lastMessageSentTimestamp = null;\n        this.lastMessageReceivedTimestamp = null;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n    }\n    refTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n    }\n    flowControlTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n    }\n    internalsTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n    }\n    keepaliveTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n    }\n    handleBackoffTimer() {\n        if (this.continueConnecting) {\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n        }\n        else {\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n        }\n    }\n    /**\n     * Start a backoff timer with the current nextBackoff timeout\n     */\n    startBackoff() {\n        this.backoffTimeout.runOnce();\n    }\n    stopBackoff() {\n        this.backoffTimeout.stop();\n        this.backoffTimeout.reset();\n    }\n    sendPing() {\n        var _a, _b;\n        if (this.channelzEnabled) {\n            this.keepalivesSent += 1;\n        }\n        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n        this.keepaliveTimeoutId = setTimeout(() => {\n            this.keepaliveTrace('Ping timeout passed without response');\n            this.handleDisconnect();\n        }, this.keepaliveTimeoutMs);\n        (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        try {\n            this.session.ping((err, duration, payload) => {\n                this.keepaliveTrace('Received ping response');\n                clearTimeout(this.keepaliveTimeoutId);\n            });\n        }\n        catch (e) {\n            /* If we fail to send a ping, the connection is no longer functional, so\n             * we should discard it. */\n            this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        }\n    }\n    startKeepalivePings() {\n        var _a, _b;\n        this.keepaliveIntervalId = setInterval(() => {\n            this.sendPing();\n        }, this.keepaliveTimeMs);\n        (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        /* Don't send a ping immediately because whatever caused us to start\n         * sending pings should also involve some network activity. */\n    }\n    /**\n     * Stop keepalive pings when terminating a connection. This discards the\n     * outstanding ping timeout, so it should not be called if the same\n     * connection will still be used.\n     */\n    stopKeepalivePings() {\n        clearInterval(this.keepaliveIntervalId);\n        clearTimeout(this.keepaliveTimeoutId);\n    }\n    createSession(proxyConnectionResult) {\n        var _a, _b, _c;\n        if (proxyConnectionResult.realTarget) {\n            this.remoteName = uri_parser_1.uriToString(proxyConnectionResult.realTarget);\n            this.trace('creating HTTP/2 session through proxy to ' + proxyConnectionResult.realTarget);\n        }\n        else {\n            this.remoteName = null;\n            this.trace('creating HTTP/2 session');\n        }\n        const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n        let connectionOptions = this.credentials._getConnectionOptions() || {};\n        connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n        if ('grpc-node.max_session_memory' in this.options) {\n            connectionOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n        }\n        else {\n            /* By default, set a very large max session memory limit, to effectively\n             * disable enforcement of the limit. Some testing indicates that Node's\n             * behavior degrades badly when this limit is reached, so we solve that\n             * by disabling the check entirely. */\n            connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n        }\n        let addressScheme = 'http://';\n        if ('secureContext' in connectionOptions) {\n            addressScheme = 'https://';\n            // If provided, the value of grpc.ssl_target_name_override should be used\n            // to override the target hostname when checking server identity.\n            // This option is used for testing only.\n            if (this.options['grpc.ssl_target_name_override']) {\n                const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n                connectionOptions.checkServerIdentity = (host, cert) => {\n                    return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n                };\n                connectionOptions.servername = sslTargetNameOverride;\n            }\n            else {\n                const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost';\n                // We want to always set servername to support SNI\n                connectionOptions.servername = authorityHostname;\n            }\n            if (proxyConnectionResult.socket) {\n                /* This is part of the workaround for\n                 * https://github.com/nodejs/node/issues/32922. Without that bug,\n                 * proxyConnectionResult.socket would always be a plaintext socket and\n                 * this would say\n                 * connectionOptions.socket = proxyConnectionResult.socket; */\n                connectionOptions.createConnection = (authority, option) => {\n                    return proxyConnectionResult.socket;\n                };\n            }\n        }\n        else {\n            /* In all but the most recent versions of Node, http2.connect does not use\n             * the options when establishing plaintext connections, so we need to\n             * establish that connection explicitly. */\n            connectionOptions.createConnection = (authority, option) => {\n                if (proxyConnectionResult.socket) {\n                    return proxyConnectionResult.socket;\n                }\n                else {\n                    /* net.NetConnectOpts is declared in a way that is more restrictive\n                     * than what net.connect will actually accept, so we use the type\n                     * assertion to work around that. */\n                    return net.connect(this.subchannelAddress);\n                }\n            };\n        }\n        connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);\n        /* http2.connect uses the options here:\n         * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n         * The spread operator overides earlier values with later ones, so any port\n         * or host values in the options will be used rather than any values extracted\n         * from the first argument. In addition, the path overrides the host and port,\n         * as documented for plaintext connections here:\n         * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n         * and for TLS connections here:\n         * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n         * earlier versions of Node, http2.connect passes these options to\n         * tls.connect but not net.connect, so in the insecure case we still need\n         * to set the createConnection option above to create the connection\n         * explicitly. We cannot do that in the TLS case because http2.connect\n         * passes necessary additional options to tls.connect.\n         * The first argument just needs to be parseable as a URL and the scheme\n         * determines whether the connection will be established over TLS or not.\n         */\n        const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n        this.session = session;\n        this.channelzSocketRef = channelz_1.registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzSocketInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.childrenTracker.refChild(this.channelzSocketRef);\n        }\n        session.unref();\n        /* For all of these events, check if the session at the time of the event\n         * is the same one currently attached to this subchannel, to ensure that\n         * old events from previous connection attempts cannot cause invalid state\n         * transitions. */\n        session.once('connect', () => {\n            if (this.session === session) {\n                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY);\n            }\n        });\n        session.once('close', () => {\n            if (this.session === session) {\n                this.trace('connection closed');\n                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n                /* Transitioning directly to IDLE here should be OK because we are not\n                 * doing any backoff, because a connection was established at some\n                 * point */\n                this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n            }\n        });\n        session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n            if (this.session === session) {\n                /* See the last paragraph of\n                 * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n                if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n                    opaqueData.equals(tooManyPingsData)) {\n                    this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);\n                    logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${uri_parser_1.uriToString(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);\n                }\n                this.trace('connection closed by GOAWAY with code ' +\n                    errorCode);\n                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n            }\n        });\n        session.once('error', (error) => {\n            /* Do nothing here. Any error should also trigger a close event, which is\n             * where we want to handle that.  */\n            this.trace('connection closed with error ' +\n                error.message);\n        });\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            session.on('remoteSettings', (settings) => {\n                this.trace('new settings received' +\n                    (this.session !== session ? ' on the old connection' : '') +\n                    ': ' +\n                    JSON.stringify(settings));\n            });\n            session.on('localSettings', (settings) => {\n                this.trace('local settings acknowledged by remote' +\n                    (this.session !== session ? ' on the old connection' : '') +\n                    ': ' +\n                    JSON.stringify(settings));\n            });\n        }\n    }\n    startConnectingInternal() {\n        var _a, _b;\n        /* Pass connection options through to the proxy so that it's able to\n         * upgrade it's connection to support tls if needed.\n         * This is a workaround for https://github.com/nodejs/node/issues/32922\n         * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n        const connectionOptions = this.credentials._getConnectionOptions() || {};\n        if ('secureContext' in connectionOptions) {\n            connectionOptions.ALPNProtocols = ['h2'];\n            // If provided, the value of grpc.ssl_target_name_override should be used\n            // to override the target hostname when checking server identity.\n            // This option is used for testing only.\n            if (this.options['grpc.ssl_target_name_override']) {\n                const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n                connectionOptions.checkServerIdentity = (host, cert) => {\n                    return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n                };\n                connectionOptions.servername = sslTargetNameOverride;\n            }\n            else {\n                if ('grpc.http_connect_target' in this.options) {\n                    /* This is more or less how servername will be set in createSession\n                     * if a connection is successfully established through the proxy.\n                     * If the proxy is not used, these connectionOptions are discarded\n                     * anyway */\n                    const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {\n                        path: 'localhost',\n                    });\n                    const hostPort = uri_parser_1.splitHostPort(targetPath);\n                    connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n                }\n            }\n        }\n        http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then((result) => {\n            this.createSession(result);\n        }, (reason) => {\n            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        });\n    }\n    handleDisconnect() {\n        this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        for (const listener of this.disconnectListeners.values()) {\n            listener();\n        }\n    }\n    /**\n     * Initiate a state transition from any element of oldStates to the new\n     * state. If the current connectivityState is not in oldStates, do nothing.\n     * @param oldStates The set of states to transition from\n     * @param newState The state to transition to\n     * @returns True if the state changed, false otherwise\n     */\n    transitionToState(oldStates, newState) {\n        if (oldStates.indexOf(this.connectivityState) === -1) {\n            return false;\n        }\n        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n        }\n        const previousState = this.connectivityState;\n        this.connectivityState = newState;\n        switch (newState) {\n            case connectivity_state_1.ConnectivityState.READY:\n                this.stopBackoff();\n                const session = this.session;\n                session.socket.once('close', () => {\n                    if (this.session === session) {\n                        this.handleDisconnect();\n                    }\n                });\n                if (this.keepaliveWithoutCalls) {\n                    this.startKeepalivePings();\n                }\n                break;\n            case connectivity_state_1.ConnectivityState.CONNECTING:\n                this.startBackoff();\n                this.startConnectingInternal();\n                this.continueConnecting = false;\n                break;\n            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n                if (this.session) {\n                    this.session.close();\n                }\n                this.session = null;\n                this.resetChannelzSocketInfo();\n                this.stopKeepalivePings();\n                /* If the backoff timer has already ended by the time we get to the\n                 * TRANSIENT_FAILURE state, we want to immediately transition out of\n                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n                if (!this.backoffTimeout.isRunning()) {\n                    process.nextTick(() => {\n                        this.handleBackoffTimer();\n                    });\n                }\n                break;\n            case connectivity_state_1.ConnectivityState.IDLE:\n                if (this.session) {\n                    this.session.close();\n                }\n                this.session = null;\n                this.resetChannelzSocketInfo();\n                this.stopKeepalivePings();\n                break;\n            default:\n                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n        }\n        /* We use a shallow copy of the stateListeners array in case a listener\n         * is removed during this iteration */\n        for (const listener of [...this.stateListeners]) {\n            listener(this, previousState, newState);\n        }\n        return true;\n    }\n    /**\n     * Check if the subchannel associated with zero calls and with zero channels.\n     * If so, shut it down.\n     */\n    checkBothRefcounts() {\n        /* If no calls, channels, or subchannel pools have any more references to\n         * this subchannel, we can be sure it will never be used again. */\n        if (this.callRefcount === 0 && this.refcount === 0) {\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n            }\n            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n            if (this.channelzEnabled) {\n                channelz_1.unregisterChannelzRef(this.channelzRef);\n            }\n        }\n    }\n    callRef() {\n        this.refTrace('callRefcount ' +\n            this.callRefcount +\n            ' -> ' +\n            (this.callRefcount + 1));\n        if (this.callRefcount === 0) {\n            if (this.session) {\n                this.session.ref();\n            }\n            this.backoffTimeout.ref();\n            if (!this.keepaliveWithoutCalls) {\n                this.startKeepalivePings();\n            }\n        }\n        this.callRefcount += 1;\n    }\n    callUnref() {\n        this.refTrace('callRefcount ' +\n            this.callRefcount +\n            ' -> ' +\n            (this.callRefcount - 1));\n        this.callRefcount -= 1;\n        if (this.callRefcount === 0) {\n            if (this.session) {\n                this.session.unref();\n            }\n            this.backoffTimeout.unref();\n            if (!this.keepaliveWithoutCalls) {\n                clearInterval(this.keepaliveIntervalId);\n            }\n            this.checkBothRefcounts();\n        }\n    }\n    ref() {\n        this.refTrace('refcount ' +\n            this.refcount +\n            ' -> ' +\n            (this.refcount + 1));\n        this.refcount += 1;\n    }\n    unref() {\n        this.refTrace('refcount ' +\n            this.refcount +\n            ' -> ' +\n            (this.refcount - 1));\n        this.refcount -= 1;\n        this.checkBothRefcounts();\n    }\n    unrefIfOneRef() {\n        if (this.refcount === 1) {\n            this.unref();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Start a stream on the current session with the given `metadata` as headers\n     * and then attach it to the `callStream`. Must only be called if the\n     * subchannel's current connectivity state is READY.\n     * @param metadata\n     * @param callStream\n     */\n    startCallStream(metadata, callStream, extraFilters) {\n        const headers = metadata.toHttp2Headers();\n        headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n        headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n        headers[HTTP2_HEADER_METHOD] = 'POST';\n        headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n        headers[HTTP2_HEADER_TE] = 'trailers';\n        let http2Stream;\n        /* In theory, if an error is thrown by session.request because session has\n         * become unusable (e.g. because it has received a goaway), this subchannel\n         * should soon see the corresponding close or goaway event anyway and leave\n         * READY. But we have seen reports that this does not happen\n         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n         * so for defense in depth, we just discard the session when we see an\n         * error here.\n         */\n        try {\n            http2Stream = this.session.request(headers);\n        }\n        catch (e) {\n            this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n            throw e;\n        }\n        let headersString = '';\n        for (const header of Object.keys(headers)) {\n            headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n        }\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'call_stream', 'Starting stream [' + callStream.getCallNumber() + '] on subchannel ' +\n            '(' + this.channelzRef.id + ') ' +\n            this.subchannelAddressString +\n            ' with headers\\n' +\n            headersString);\n        this.flowControlTrace('local window size: ' +\n            this.session.state.localWindowSize +\n            ' remote window size: ' +\n            this.session.state.remoteWindowSize);\n        const streamSession = this.session;\n        this.internalsTrace('session.closed=' +\n            streamSession.closed +\n            ' session.destroyed=' +\n            streamSession.destroyed +\n            ' session.socket.destroyed=' +\n            streamSession.socket.destroyed);\n        let statsTracker;\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n            callStream.addStatusWatcher(status => {\n                if (status.code === constants_1.Status.OK) {\n                    this.callTracker.addCallSucceeded();\n                }\n                else {\n                    this.callTracker.addCallFailed();\n                }\n            });\n            this.streamTracker.addCallStarted();\n            callStream.addStreamEndWatcher(success => {\n                if (streamSession === this.session) {\n                    if (success) {\n                        this.streamTracker.addCallSucceeded();\n                    }\n                    else {\n                        this.streamTracker.addCallFailed();\n                    }\n                }\n            });\n            statsTracker = {\n                addMessageSent: () => {\n                    this.messagesSent += 1;\n                    this.lastMessageSentTimestamp = new Date();\n                },\n                addMessageReceived: () => {\n                    this.messagesReceived += 1;\n                }\n            };\n        }\n        else {\n            statsTracker = {\n                addMessageSent: () => { },\n                addMessageReceived: () => { }\n            };\n        }\n        callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);\n    }\n    /**\n     * If the subchannel is currently IDLE, start connecting and switch to the\n     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n     * the next time it would transition to IDLE, start connecting again instead.\n     * Otherwise, do nothing.\n     */\n    startConnecting() {\n        /* First, try to transition from IDLE to connecting. If that doesn't happen\n         * because the state is not currently IDLE, check if it is\n         * TRANSIENT_FAILURE, and if so indicate that it should go back to\n         * connecting after the backoff timer ends. Otherwise do nothing */\n        if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n            if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                this.continueConnecting = true;\n            }\n        }\n    }\n    /**\n     * Get the subchannel's current connectivity state.\n     */\n    getConnectivityState() {\n        return this.connectivityState;\n    }\n    /**\n     * Add a listener function to be called whenever the subchannel's\n     * connectivity state changes.\n     * @param listener\n     */\n    addConnectivityStateListener(listener) {\n        this.stateListeners.push(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */\n    removeConnectivityStateListener(listener) {\n        const listenerIndex = this.stateListeners.indexOf(listener);\n        if (listenerIndex > -1) {\n            this.stateListeners.splice(listenerIndex, 1);\n        }\n    }\n    addDisconnectListener(listener) {\n        this.disconnectListeners.add(listener);\n    }\n    removeDisconnectListener(listener) {\n        this.disconnectListeners.delete(listener);\n    }\n    /**\n     * Reset the backoff timeout, and immediately start connecting if in backoff.\n     */\n    resetBackoff() {\n        this.backoffTimeout.reset();\n        this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    }\n    getAddress() {\n        return this.subchannelAddressString;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    getRealSubchannel() {\n        return this;\n    }\n}\nexports.Subchannel = Subchannel;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}