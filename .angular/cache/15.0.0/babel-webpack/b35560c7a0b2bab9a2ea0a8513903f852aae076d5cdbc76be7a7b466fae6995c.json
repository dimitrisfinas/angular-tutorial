{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { isPlainObject } from './lodash.merge';\nvar MAX_LEVEL = 20;\n/**\n * Merges objects together\n * @param args - objects / values to be merged\n */\nexport function merge() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  var result = args.shift();\n  var objects = new WeakMap();\n  while (args.length > 0) {\n    result = mergeTwoObjects(result, args.shift(), 0, objects);\n  }\n  return result;\n}\nfunction takeValue(value) {\n  if (isArray(value)) {\n    return value.slice();\n  }\n  return value;\n}\n/**\n * Merges two objects\n * @param one - first object\n * @param two - second object\n * @param level - current deep level\n * @param objects - objects holder that has been already referenced - to prevent\n * cyclic dependency\n */\nfunction mergeTwoObjects(one, two, level, objects) {\n  if (level === void 0) {\n    level = 0;\n  }\n  var result;\n  if (level > MAX_LEVEL) {\n    return undefined;\n  }\n  level++;\n  if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {\n    result = takeValue(two);\n  } else if (isArray(one)) {\n    result = one.slice();\n    if (isArray(two)) {\n      for (var i = 0, j = two.length; i < j; i++) {\n        result.push(takeValue(two[i]));\n      }\n    } else if (isObject(two)) {\n      var keys = Object.keys(two);\n      for (var i = 0, j = keys.length; i < j; i++) {\n        var key = keys[i];\n        result[key] = takeValue(two[key]);\n      }\n    }\n  } else if (isObject(one)) {\n    if (isObject(two)) {\n      if (!shouldMerge(one, two)) {\n        return two;\n      }\n      result = Object.assign({}, one);\n      var keys = Object.keys(two);\n      for (var i = 0, j = keys.length; i < j; i++) {\n        var key = keys[i];\n        var twoValue = two[key];\n        if (isPrimitive(twoValue)) {\n          if (typeof twoValue === 'undefined') {\n            delete result[key];\n          } else {\n            // result[key] = takeValue(twoValue);\n            result[key] = twoValue;\n          }\n        } else {\n          var obj1 = result[key];\n          var obj2 = twoValue;\n          if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {\n            delete result[key];\n          } else {\n            if (isObject(obj1) && isObject(obj2)) {\n              var arr1 = objects.get(obj1) || [];\n              var arr2 = objects.get(obj2) || [];\n              arr1.push({\n                obj: one,\n                key: key\n              });\n              arr2.push({\n                obj: two,\n                key: key\n              });\n              objects.set(obj1, arr1);\n              objects.set(obj2, arr2);\n            }\n            result[key] = mergeTwoObjects(result[key], twoValue, level, objects);\n          }\n        }\n      }\n    } else {\n      result = two;\n    }\n  }\n  return result;\n}\n/**\n * Function to check if object has been already reference\n * @param obj\n * @param key\n * @param objects\n */\nfunction wasObjectReferenced(obj, key, objects) {\n  var arr = objects.get(obj[key]) || [];\n  for (var i = 0, j = arr.length; i < j; i++) {\n    var info = arr[i];\n    if (info.key === key && info.obj === obj) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\nfunction isObject(value) {\n  return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === 'object';\n}\nfunction isPrimitive(value) {\n  return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || typeof value === 'undefined' || value instanceof Date || value instanceof RegExp || value === null;\n}\nfunction shouldMerge(one, two) {\n  if (!isPlainObject(one) || !isPlainObject(two)) {\n    return false;\n  }\n  return true;\n}\n//# sourceMappingURL=merge.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}