{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\nconst call_1 = require(\"./call\");\nconst channel_1 = require(\"./channel\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst client_interceptors_1 = require(\"./client-interceptors\");\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nfunction getErrorStackString(error) {\n  return error.stack.split('\\n').slice(1).join('\\n');\n}\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\nclass Client {\n  constructor(address, credentials, options = {}) {\n    var _a, _b;\n    options = Object.assign({}, options);\n    this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n    delete options.interceptors;\n    this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n    delete options.interceptor_providers;\n    if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n      throw new Error('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n    }\n    this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;\n    delete options.callInvocationTransformer;\n    if (options.channelOverride) {\n      this[CHANNEL_SYMBOL] = options.channelOverride;\n    } else if (options.channelFactoryOverride) {\n      const channelFactoryOverride = options.channelFactoryOverride;\n      delete options.channelFactoryOverride;\n      this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n    } else {\n      this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n    }\n  }\n  close() {\n    this[CHANNEL_SYMBOL].close();\n  }\n  getChannel() {\n    return this[CHANNEL_SYMBOL];\n  }\n  waitForReady(deadline, callback) {\n    const checkState = err => {\n      if (err) {\n        callback(new Error('Failed to connect before the deadline'));\n        return;\n      }\n      let newState;\n      try {\n        newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n      } catch (e) {\n        callback(new Error('The channel has been closed'));\n        return;\n      }\n      if (newState === connectivity_state_1.ConnectivityState.READY) {\n        callback();\n      } else {\n        try {\n          this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n        } catch (e) {\n          callback(new Error('The channel has been closed'));\n        }\n      }\n    };\n    setImmediate(checkState);\n  }\n  checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n    if (isFunction(arg1)) {\n      return {\n        metadata: new metadata_1.Metadata(),\n        options: {},\n        callback: arg1\n      };\n    } else if (isFunction(arg2)) {\n      if (arg1 instanceof metadata_1.Metadata) {\n        return {\n          metadata: arg1,\n          options: {},\n          callback: arg2\n        };\n      } else {\n        return {\n          metadata: new metadata_1.Metadata(),\n          options: arg1,\n          callback: arg2\n        };\n      }\n    } else {\n      if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && isFunction(arg3))) {\n        throw new Error('Incorrect arguments passed');\n      }\n      return {\n        metadata: arg1,\n        options: arg2,\n        callback: arg3\n      };\n    }\n  }\n  makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n    var _a, _b;\n    const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n    const methodDefinition = {\n      path: method,\n      requestStream: false,\n      responseStream: false,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      argument: argument,\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientUnaryCallImpl(),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n      callback: checkedArguments.callback\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n    const emitter = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    emitter.call = call;\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n    let responseMessage = null;\n    let receivedStatus = false;\n    const callerStackError = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata: metadata => {\n        emitter.emit('metadata', metadata);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message) {\n        if (responseMessage !== null) {\n          call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n        }\n        responseMessage = message;\n      },\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        if (status.code === constants_1.Status.OK) {\n          if (responseMessage === null) {\n            const callerStack = getErrorStackString(callerStackError);\n            callProperties.callback(call_1.callErrorFromStatus({\n              code: constants_1.Status.INTERNAL,\n              details: 'No message received',\n              metadata: status.metadata\n            }, callerStack));\n          } else {\n            callProperties.callback(null, responseMessage);\n          }\n        } else {\n          const callerStack = getErrorStackString(callerStackError);\n          callProperties.callback(call_1.callErrorFromStatus(status, callerStack));\n        }\n        emitter.emit('status', status);\n      }\n    });\n    call.sendMessage(argument);\n    call.halfClose();\n    return emitter;\n  }\n  makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n    var _a, _b;\n    const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n    const methodDefinition = {\n      path: method,\n      requestStream: true,\n      responseStream: false,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientWritableStreamImpl(serialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n      callback: checkedArguments.callback\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n    const emitter = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    emitter.call = call;\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n    let responseMessage = null;\n    let receivedStatus = false;\n    const callerStackError = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata: metadata => {\n        emitter.emit('metadata', metadata);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message) {\n        if (responseMessage !== null) {\n          call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n        }\n        responseMessage = message;\n      },\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        if (status.code === constants_1.Status.OK) {\n          if (responseMessage === null) {\n            const callerStack = getErrorStackString(callerStackError);\n            callProperties.callback(call_1.callErrorFromStatus({\n              code: constants_1.Status.INTERNAL,\n              details: 'No message received',\n              metadata: status.metadata\n            }, callerStack));\n          } else {\n            callProperties.callback(null, responseMessage);\n          }\n        } else {\n          const callerStack = getErrorStackString(callerStackError);\n          callProperties.callback(call_1.callErrorFromStatus(status, callerStack));\n        }\n        emitter.emit('status', status);\n      }\n    });\n    return emitter;\n  }\n  checkMetadataAndOptions(arg1, arg2) {\n    let metadata;\n    let options;\n    if (arg1 instanceof metadata_1.Metadata) {\n      metadata = arg1;\n      if (arg2) {\n        options = arg2;\n      } else {\n        options = {};\n      }\n    } else {\n      if (arg1) {\n        options = arg1;\n      } else {\n        options = {};\n      }\n      metadata = new metadata_1.Metadata();\n    }\n    return {\n      metadata,\n      options\n    };\n  }\n  makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n    var _a, _b;\n    const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n    const methodDefinition = {\n      path: method,\n      requestStream: false,\n      responseStream: true,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      argument: argument,\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientReadableStreamImpl(deserialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n    const stream = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    stream.call = call;\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n    let receivedStatus = false;\n    const callerStackError = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata(metadata) {\n        stream.emit('metadata', metadata);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message) {\n        stream.push(message);\n      },\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        stream.push(null);\n        if (status.code !== constants_1.Status.OK) {\n          const callerStack = getErrorStackString(callerStackError);\n          stream.emit('error', call_1.callErrorFromStatus(status, callerStack));\n        }\n        stream.emit('status', status);\n      }\n    });\n    call.sendMessage(argument);\n    call.halfClose();\n    return stream;\n  }\n  makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n    var _a, _b;\n    const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n    const methodDefinition = {\n      path: method,\n      requestStream: true,\n      responseStream: true,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n    const stream = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    stream.call = call;\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n    let receivedStatus = false;\n    const callerStackError = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata(metadata) {\n        stream.emit('metadata', metadata);\n      },\n      onReceiveMessage(message) {\n        stream.push(message);\n      },\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        stream.push(null);\n        if (status.code !== constants_1.Status.OK) {\n          const callerStack = getErrorStackString(callerStackError);\n          stream.emit('error', call_1.callErrorFromStatus(status, callerStack));\n        }\n        stream.emit('status', status);\n      }\n    });\n    return stream;\n  }\n}\nexports.Client = Client;","map":{"version":3,"names":["Object","defineProperty","exports","value","Client","call_1","require","channel_1","connectivity_state_1","constants_1","metadata_1","client_interceptors_1","CHANNEL_SYMBOL","Symbol","INTERCEPTOR_SYMBOL","INTERCEPTOR_PROVIDER_SYMBOL","CALL_INVOCATION_TRANSFORMER_SYMBOL","isFunction","arg","getErrorStackString","error","stack","split","slice","join","constructor","address","credentials","options","_a","_b","assign","interceptors","interceptor_providers","length","Error","callInvocationTransformer","channelOverride","channelFactoryOverride","ChannelImplementation","close","getChannel","waitForReady","deadline","callback","checkState","err","newState","getConnectivityState","e","ConnectivityState","READY","watchConnectivityState","setImmediate","checkOptionalUnaryResponseArguments","arg1","arg2","arg3","metadata","Metadata","makeUnaryRequest","method","serialize","deserialize","argument","checkedArguments","methodDefinition","path","requestStream","responseStream","requestSerialize","responseDeserialize","callProperties","call","ClientUnaryCallImpl","channel","callOptions","emitter","interceptorArgs","clientInterceptors","clientInterceptorProviders","callInterceptors","callInterceptorProviders","getInterceptingCall","setCredentials","responseMessage","receivedStatus","callerStackError","start","onReceiveMetadata","emit","onReceiveMessage","message","cancelWithStatus","Status","INTERNAL","onReceiveStatus","status","code","OK","callerStack","callErrorFromStatus","details","sendMessage","halfClose","makeClientStreamRequest","ClientWritableStreamImpl","checkMetadataAndOptions","makeServerStreamRequest","ClientReadableStreamImpl","stream","push","makeBidiStreamRequest","ClientDuplexStreamImpl"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/client.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Client = void 0;\nconst call_1 = require(\"./call\");\nconst channel_1 = require(\"./channel\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst client_interceptors_1 = require(\"./client-interceptors\");\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\nfunction getErrorStackString(error) {\n    return error.stack.split('\\n').slice(1).join('\\n');\n}\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\nclass Client {\n    constructor(address, credentials, options = {}) {\n        var _a, _b;\n        options = Object.assign({}, options);\n        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n        delete options.interceptors;\n        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n        delete options.interceptor_providers;\n        if (this[INTERCEPTOR_SYMBOL].length > 0 &&\n            this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n            throw new Error('Both interceptors and interceptor_providers were passed as options ' +\n                'to the client constructor. Only one of these is allowed.');\n        }\n        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =\n            options.callInvocationTransformer;\n        delete options.callInvocationTransformer;\n        if (options.channelOverride) {\n            this[CHANNEL_SYMBOL] = options.channelOverride;\n        }\n        else if (options.channelFactoryOverride) {\n            const channelFactoryOverride = options.channelFactoryOverride;\n            delete options.channelFactoryOverride;\n            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n        }\n        else {\n            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n        }\n    }\n    close() {\n        this[CHANNEL_SYMBOL].close();\n    }\n    getChannel() {\n        return this[CHANNEL_SYMBOL];\n    }\n    waitForReady(deadline, callback) {\n        const checkState = (err) => {\n            if (err) {\n                callback(new Error('Failed to connect before the deadline'));\n                return;\n            }\n            let newState;\n            try {\n                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n            }\n            catch (e) {\n                callback(new Error('The channel has been closed'));\n                return;\n            }\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\n                callback();\n            }\n            else {\n                try {\n                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n                }\n                catch (e) {\n                    callback(new Error('The channel has been closed'));\n                }\n            }\n        };\n        setImmediate(checkState);\n    }\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n        if (isFunction(arg1)) {\n            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };\n        }\n        else if (isFunction(arg2)) {\n            if (arg1 instanceof metadata_1.Metadata) {\n                return { metadata: arg1, options: {}, callback: arg2 };\n            }\n            else {\n                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };\n            }\n        }\n        else {\n            if (!(arg1 instanceof metadata_1.Metadata &&\n                arg2 instanceof Object &&\n                isFunction(arg3))) {\n                throw new Error('Incorrect arguments passed');\n            }\n            return { metadata: arg1, options: arg2, callback: arg3 };\n        }\n    }\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientUnaryCallImpl(),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        emitter.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let responseMessage = null;\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: (metadata) => {\n                emitter.emit('metadata', metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage(message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback(call_1.callErrorFromStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: 'No message received',\n                            metadata: status.metadata\n                        }, callerStack));\n                    }\n                    else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                }\n                else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback(call_1.callErrorFromStatus(status, callerStack));\n                }\n                emitter.emit('status', status);\n            },\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return emitter;\n    }\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientWritableStreamImpl(serialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        emitter.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let responseMessage = null;\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: (metadata) => {\n                emitter.emit('metadata', metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage(message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback(call_1.callErrorFromStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: 'No message received',\n                            metadata: status.metadata\n                        }, callerStack));\n                    }\n                    else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                }\n                else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback(call_1.callErrorFromStatus(status, callerStack));\n                }\n                emitter.emit('status', status);\n            },\n        });\n        return emitter;\n    }\n    checkMetadataAndOptions(arg1, arg2) {\n        let metadata;\n        let options;\n        if (arg1 instanceof metadata_1.Metadata) {\n            metadata = arg1;\n            if (arg2) {\n                options = arg2;\n            }\n            else {\n                options = {};\n            }\n        }\n        else {\n            if (arg1) {\n                options = arg1;\n            }\n            else {\n                options = {};\n            }\n            metadata = new metadata_1.Metadata();\n        }\n        return { metadata, options };\n    }\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientReadableStreamImpl(deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        stream.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata(metadata) {\n                stream.emit('metadata', metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage(message) {\n                stream.push(message);\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit('error', call_1.callErrorFromStatus(status, callerStack));\n                }\n                stream.emit('status', status);\n            },\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return stream;\n    }\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        stream.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata(metadata) {\n                stream.emit('metadata', metadata);\n            },\n            onReceiveMessage(message) {\n                stream.push(message);\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit('error', call_1.callErrorFromStatus(status, callerStack));\n                }\n                stream.emit('status', status);\n            },\n        });\n        return stream;\n    }\n}\nexports.Client = Client;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}