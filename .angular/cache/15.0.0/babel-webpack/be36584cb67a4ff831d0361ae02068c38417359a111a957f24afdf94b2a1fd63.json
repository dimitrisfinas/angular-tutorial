{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2CallStream = exports.InterceptingListenerImpl = exports.isInterceptingListener = void 0;\nconst http2 = require(\"http2\");\nconst os = require(\"os\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst TRACER_NAME = 'call_stream';\nconst {\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_CONTENT_TYPE,\n  NGHTTP2_CANCEL\n} = http2.constants;\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno) {\n  for (const [name, num] of Object.entries(os.constants.errno)) {\n    if (num === errno) {\n      return name;\n    }\n  }\n  return 'Unknown system error ' + errno;\n}\nfunction getMinDeadline(deadlineList) {\n  let minValue = Infinity;\n  for (const deadline of deadlineList) {\n    const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;\n    if (deadlineMsecs < minValue) {\n      minValue = deadlineMsecs;\n    }\n  }\n  return minValue;\n}\nfunction isInterceptingListener(listener) {\n  return listener.onReceiveMetadata !== undefined && listener.onReceiveMetadata.length === 1;\n}\nexports.isInterceptingListener = isInterceptingListener;\nclass InterceptingListenerImpl {\n  constructor(listener, nextListener) {\n    this.listener = listener;\n    this.nextListener = nextListener;\n    this.processingMetadata = false;\n    this.hasPendingMessage = false;\n    this.processingMessage = false;\n    this.pendingStatus = null;\n  }\n  processPendingMessage() {\n    if (this.hasPendingMessage) {\n      this.nextListener.onReceiveMessage(this.pendingMessage);\n      this.pendingMessage = null;\n      this.hasPendingMessage = false;\n    }\n  }\n  processPendingStatus() {\n    if (this.pendingStatus) {\n      this.nextListener.onReceiveStatus(this.pendingStatus);\n    }\n  }\n  onReceiveMetadata(metadata) {\n    this.processingMetadata = true;\n    this.listener.onReceiveMetadata(metadata, metadata => {\n      this.processingMetadata = false;\n      this.nextListener.onReceiveMetadata(metadata);\n      this.processPendingMessage();\n      this.processPendingStatus();\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  onReceiveMessage(message) {\n    /* If this listener processes messages asynchronously, the last message may\n     * be reordered with respect to the status */\n    this.processingMessage = true;\n    this.listener.onReceiveMessage(message, msg => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessage = msg;\n        this.hasPendingMessage = true;\n      } else {\n        this.nextListener.onReceiveMessage(msg);\n        this.processPendingStatus();\n      }\n    });\n  }\n  onReceiveStatus(status) {\n    this.listener.onReceiveStatus(status, processedStatus => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingStatus = processedStatus;\n      } else {\n        this.nextListener.onReceiveStatus(processedStatus);\n      }\n    });\n  }\n}\nexports.InterceptingListenerImpl = InterceptingListenerImpl;\nclass Http2CallStream {\n  constructor(methodName, channel, options, filterStackFactory, channelCallCredentials, callNumber) {\n    this.methodName = methodName;\n    this.channel = channel;\n    this.options = options;\n    this.channelCallCredentials = channelCallCredentials;\n    this.callNumber = callNumber;\n    this.http2Stream = null;\n    this.pendingRead = false;\n    this.isWriteFilterPending = false;\n    this.pendingWrite = null;\n    this.pendingWriteCallback = null;\n    this.writesClosed = false;\n    this.decoder = new stream_decoder_1.StreamDecoder();\n    this.isReadFilterPending = false;\n    this.canPush = false;\n    /**\n     * Indicates that an 'end' event has come from the http2 stream, so there\n     * will be no more data events.\n     */\n    this.readsClosed = false;\n    this.statusOutput = false;\n    this.unpushedReadMessages = [];\n    this.unfilteredReadMessages = [];\n    // Status code mapped from :status. To be used if grpc-status is not received\n    this.mappedStatusCode = constants_1.Status.UNKNOWN;\n    // This is populated (non-null) if and only if the call has ended\n    this.finalStatus = null;\n    this.subchannel = null;\n    this.listener = null;\n    this.internalError = null;\n    this.configDeadline = Infinity;\n    this.statusWatchers = [];\n    this.streamEndWatchers = [];\n    this.callStatsTracker = null;\n    this.filterStack = filterStackFactory.createFilter(this);\n    this.credentials = channelCallCredentials;\n    this.disconnectListener = () => {\n      this.endCall({\n        code: constants_1.Status.UNAVAILABLE,\n        details: 'Connection dropped',\n        metadata: new metadata_1.Metadata()\n      });\n    };\n    if (this.options.parentCall && this.options.flags & constants_1.Propagate.CANCELLATION) {\n      this.options.parentCall.on('cancelled', () => {\n        this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');\n      });\n    }\n  }\n  outputStatus() {\n    var _a;\n    /* Precondition: this.finalStatus !== null */\n    if (this.listener && !this.statusOutput) {\n      this.statusOutput = true;\n      const filteredStatus = this.filterStack.receiveTrailers(this.finalStatus);\n      this.trace('ended with status: code=' + filteredStatus.code + ' details=\"' + filteredStatus.details + '\"');\n      this.statusWatchers.forEach(watcher => watcher(filteredStatus));\n      /* We delay the actual action of bubbling up the status to insulate the\n       * cleanup code in this class from any errors that may be thrown in the\n       * upper layers as a result of bubbling up the status. In particular,\n       * if the status is not OK, the \"error\" event may be emitted\n       * synchronously at the top level, which will result in a thrown error if\n       * the user does not handle that event. */\n      process.nextTick(() => {\n        var _a;\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n      });\n      /* Leave the http2 stream in flowing state to drain incoming messages, to\n       * ensure that the stream closure completes. The call stream already does\n       * not push more messages after the status is output, so the messages go\n       * nowhere either way. */\n      (_a = this.http2Stream) === null || _a === void 0 ? void 0 : _a.resume();\n      if (this.subchannel) {\n        this.subchannel.callUnref();\n        this.subchannel.removeDisconnectListener(this.disconnectListener);\n      }\n    }\n  }\n  trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n  }\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n  endCall(status) {\n    /* If the status is OK and a new status comes in (e.g. from a\n     * deserialization failure), that new status takes priority */\n    if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n      this.finalStatus = status;\n      this.maybeOutputStatus();\n    }\n    this.destroyHttp2Stream();\n  }\n  maybeOutputStatus() {\n    if (this.finalStatus !== null) {\n      /* The combination check of readsClosed and that the two message buffer\n       * arrays are empty checks that there all incoming data has been fully\n       * processed */\n      if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && this.unfilteredReadMessages.length === 0 && !this.isReadFilterPending) {\n        this.outputStatus();\n      }\n    }\n  }\n  push(message) {\n    this.trace('pushing to reader message of length ' + (message instanceof Buffer ? message.length : null));\n    this.canPush = false;\n    process.nextTick(() => {\n      var _a;\n      /* If we have already output the status any later messages should be\n       * ignored, and can cause out-of-order operation errors higher up in the\n       * stack. Checking as late as possible here to avoid any race conditions.\n       */\n      if (this.statusOutput) {\n        return;\n      }\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMessage(message);\n      this.maybeOutputStatus();\n    });\n  }\n  handleFilterError(error) {\n    this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n  }\n  handleFilteredRead(message) {\n    /* If we the call has already ended with an error, we don't want to do\n     * anything with this message. Dropping it on the floor is correct\n     * behavior */\n    if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n      this.maybeOutputStatus();\n      return;\n    }\n    this.isReadFilterPending = false;\n    if (this.canPush) {\n      this.http2Stream.pause();\n      this.push(message);\n    } else {\n      this.trace('unpushedReadMessages.push message of length ' + message.length);\n      this.unpushedReadMessages.push(message);\n    }\n    if (this.unfilteredReadMessages.length > 0) {\n      /* nextMessage is guaranteed not to be undefined because\n         unfilteredReadMessages is non-empty */\n      const nextMessage = this.unfilteredReadMessages.shift();\n      this.filterReceivedMessage(nextMessage);\n    }\n  }\n  filterReceivedMessage(framedMessage) {\n    /* If we the call has already ended with an error, we don't want to do\n     * anything with this message. Dropping it on the floor is correct\n     * behavior */\n    if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n      this.maybeOutputStatus();\n      return;\n    }\n    this.trace('filterReceivedMessage of length ' + framedMessage.length);\n    this.isReadFilterPending = true;\n    this.filterStack.receiveMessage(Promise.resolve(framedMessage)).then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n  }\n  tryPush(messageBytes) {\n    if (this.isReadFilterPending) {\n      this.trace('unfilteredReadMessages.push message of length ' + (messageBytes && messageBytes.length));\n      this.unfilteredReadMessages.push(messageBytes);\n    } else {\n      this.filterReceivedMessage(messageBytes);\n    }\n  }\n  handleTrailers(headers) {\n    this.streamEndWatchers.forEach(watcher => watcher(true));\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    this.trace('Received server trailers:\\n' + headersString);\n    let metadata;\n    try {\n      metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new metadata_1.Metadata();\n    }\n    const metadataMap = metadata.getMap();\n    let code = this.mappedStatusCode;\n    if (code === constants_1.Status.UNKNOWN && typeof metadataMap['grpc-status'] === 'string') {\n      const receivedStatus = Number(metadataMap['grpc-status']);\n      if (receivedStatus in constants_1.Status) {\n        code = receivedStatus;\n        this.trace('received status code ' + receivedStatus + ' from server');\n      }\n      metadata.remove('grpc-status');\n    }\n    let details = '';\n    if (typeof metadataMap['grpc-message'] === 'string') {\n      try {\n        details = decodeURI(metadataMap['grpc-message']);\n      } catch (e) {\n        details = metadataMap['grpc-message'];\n      }\n      metadata.remove('grpc-message');\n      this.trace('received status details string \"' + details + '\" from server');\n    }\n    const status = {\n      code,\n      details,\n      metadata\n    };\n    // This is a no-op if the call was already ended when handling headers.\n    this.endCall(status);\n  }\n  writeMessageToStream(message, callback) {\n    var _a;\n    (_a = this.callStatsTracker) === null || _a === void 0 ? void 0 : _a.addMessageSent();\n    this.http2Stream.write(message, callback);\n  }\n  attachHttp2Stream(stream, subchannel, extraFilters, callStatsTracker) {\n    this.filterStack.push(extraFilters);\n    if (this.finalStatus !== null) {\n      stream.close(NGHTTP2_CANCEL);\n    } else {\n      this.trace('attachHttp2Stream from subchannel ' + subchannel.getAddress());\n      this.http2Stream = stream;\n      this.subchannel = subchannel;\n      this.callStatsTracker = callStatsTracker;\n      subchannel.addDisconnectListener(this.disconnectListener);\n      subchannel.callRef();\n      stream.on('response', (headers, flags) => {\n        var _a;\n        let headersString = '';\n        for (const header of Object.keys(headers)) {\n          headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n        }\n        this.trace('Received server headers:\\n' + headersString);\n        switch (headers[':status']) {\n          // TODO(murgatroid99): handle 100 and 101\n          case 400:\n            this.mappedStatusCode = constants_1.Status.INTERNAL;\n            break;\n          case 401:\n            this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n            break;\n          case 403:\n            this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n            break;\n          case 404:\n            this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n            break;\n          case 429:\n          case 502:\n          case 503:\n          case 504:\n            this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n            break;\n          default:\n            this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        }\n        if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n          this.handleTrailers(headers);\n        } else {\n          let metadata;\n          try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n          } catch (error) {\n            this.endCall({\n              code: constants_1.Status.UNKNOWN,\n              details: error.message,\n              metadata: new metadata_1.Metadata()\n            });\n            return;\n          }\n          try {\n            const finalMetadata = this.filterStack.receiveMetadata(metadata);\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMetadata(finalMetadata);\n          } catch (error) {\n            this.endCall({\n              code: constants_1.Status.UNKNOWN,\n              details: error.message,\n              metadata: new metadata_1.Metadata()\n            });\n          }\n        }\n      });\n      stream.on('trailers', headers => {\n        this.handleTrailers(headers);\n      });\n      stream.on('data', data => {\n        /* If the status has already been output, allow the http2 stream to\n         * drain without processing the data. */\n        if (this.statusOutput) {\n          return;\n        }\n        this.trace('receive HTTP/2 data frame of length ' + data.length);\n        const messages = this.decoder.write(data);\n        for (const message of messages) {\n          this.trace('parsed message of length ' + message.length);\n          this.callStatsTracker.addMessageReceived();\n          this.tryPush(message);\n        }\n      });\n      stream.on('end', () => {\n        this.readsClosed = true;\n        this.maybeOutputStatus();\n      });\n      stream.on('close', () => {\n        /* Use process.next tick to ensure that this code happens after any\n         * \"error\" event that may be emitted at about the same time, so that\n         * we can bubble up the error message from that event. */\n        process.nextTick(() => {\n          var _a;\n          this.trace('HTTP/2 stream closed with code ' + stream.rstCode);\n          /* If we have a final status with an OK status code, that means that\n           * we have received all of the messages and we have processed the\n           * trailers and the call completed successfully, so it doesn't matter\n           * how the stream ends after that */\n          if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n            return;\n          }\n          let code;\n          let details = '';\n          switch (stream.rstCode) {\n            case http2.constants.NGHTTP2_NO_ERROR:\n              /* If we get a NO_ERROR code and we already have a status, the\n               * stream completed properly and we just haven't fully processed\n               * it yet */\n              if (this.finalStatus !== null) {\n                return;\n              }\n              code = constants_1.Status.INTERNAL;\n              details = `Received RST_STREAM with code ${stream.rstCode}`;\n              break;\n            case http2.constants.NGHTTP2_REFUSED_STREAM:\n              code = constants_1.Status.UNAVAILABLE;\n              details = 'Stream refused by server';\n              break;\n            case http2.constants.NGHTTP2_CANCEL:\n              code = constants_1.Status.CANCELLED;\n              details = 'Call cancelled';\n              break;\n            case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n              code = constants_1.Status.RESOURCE_EXHAUSTED;\n              details = 'Bandwidth exhausted or memory limit exceeded';\n              break;\n            case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n              code = constants_1.Status.PERMISSION_DENIED;\n              details = 'Protocol not secure enough';\n              break;\n            case http2.constants.NGHTTP2_INTERNAL_ERROR:\n              code = constants_1.Status.INTERNAL;\n              if (this.internalError === null) {\n                /* This error code was previously handled in the default case, and\n                 * there are several instances of it online, so I wanted to\n                 * preserve the original error message so that people find existing\n                 * information in searches, but also include the more recognizable\n                 * \"Internal server error\" message. */\n                details = `Received RST_STREAM with code ${stream.rstCode} (Internal server error)`;\n              } else {\n                if (this.internalError.code === 'ECONNRESET' || this.internalError.code === 'ETIMEDOUT') {\n                  code = constants_1.Status.UNAVAILABLE;\n                  details = this.internalError.message;\n                } else {\n                  /* The \"Received RST_STREAM with code ...\" error is preserved\n                   * here for continuity with errors reported online, but the\n                   * error message at the end will probably be more relevant in\n                   * most cases. */\n                  details = `Received RST_STREAM with code ${stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n                }\n              }\n              break;\n            default:\n              code = constants_1.Status.INTERNAL;\n              details = `Received RST_STREAM with code ${stream.rstCode}`;\n          }\n          // This is a no-op if trailers were received at all.\n          // This is OK, because status codes emitted here correspond to more\n          // catastrophic issues that prevent us from receiving trailers in the\n          // first place.\n          this.endCall({\n            code,\n            details,\n            metadata: new metadata_1.Metadata()\n          });\n        });\n      });\n      stream.on('error', err => {\n        /* We need an error handler here to stop \"Uncaught Error\" exceptions\n         * from bubbling up. However, errors here should all correspond to\n         * \"close\" events, where we will handle the error more granularly */\n        /* Specifically looking for stream errors that were *not* constructed\n         * from a RST_STREAM response here:\n         * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n         */\n        if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n          this.trace('Node error event: message=' + err.message + ' code=' + err.code + ' errno=' + getSystemErrorName(err.errno) + ' syscall=' + err.syscall);\n          this.internalError = err;\n        }\n        this.streamEndWatchers.forEach(watcher => watcher(false));\n      });\n      if (this.pendingWrite) {\n        if (!this.pendingWriteCallback) {\n          throw new Error('Invalid state in write handling code');\n        }\n        this.trace('sending data chunk of length ' + this.pendingWrite.length + ' (deferred)');\n        try {\n          this.writeMessageToStream(this.pendingWrite, this.pendingWriteCallback);\n        } catch (error) {\n          this.endCall({\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Write failed with error ${error.message}`,\n            metadata: new metadata_1.Metadata()\n          });\n        }\n      }\n      this.maybeCloseWrites();\n    }\n  }\n  start(metadata, listener) {\n    this.trace('Sending metadata');\n    this.listener = listener;\n    this.channel._startCallStream(this, metadata);\n    this.maybeOutputStatus();\n  }\n  destroyHttp2Stream() {\n    var _a;\n    // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n    if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n      /* If the call has ended with an OK status, communicate that when closing\n       * the stream, partly to avoid a situation in which we detect an error\n       * RST_STREAM as a result after we have the status */\n      let code;\n      if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n        code = http2.constants.NGHTTP2_NO_ERROR;\n      } else {\n        code = http2.constants.NGHTTP2_CANCEL;\n      }\n      this.trace('close http2 stream with code ' + code);\n      this.http2Stream.close(code);\n    }\n  }\n  cancelWithStatus(status, details) {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.endCall({\n      code: status,\n      details,\n      metadata: new metadata_1.Metadata()\n    });\n  }\n  getDeadline() {\n    const deadlineList = [this.options.deadline];\n    if (this.options.parentCall && this.options.flags & constants_1.Propagate.DEADLINE) {\n      deadlineList.push(this.options.parentCall.getDeadline());\n    }\n    if (this.configDeadline) {\n      deadlineList.push(this.configDeadline);\n    }\n    return getMinDeadline(deadlineList);\n  }\n  getCredentials() {\n    return this.credentials;\n  }\n  setCredentials(credentials) {\n    this.credentials = this.channelCallCredentials.compose(credentials);\n  }\n  getStatus() {\n    return this.finalStatus;\n  }\n  getPeer() {\n    var _a, _b;\n    return (_b = (_a = this.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n  }\n  getMethod() {\n    return this.methodName;\n  }\n  getHost() {\n    return this.options.host;\n  }\n  setConfigDeadline(configDeadline) {\n    this.configDeadline = configDeadline;\n  }\n  addStatusWatcher(watcher) {\n    this.statusWatchers.push(watcher);\n  }\n  addStreamEndWatcher(watcher) {\n    this.streamEndWatchers.push(watcher);\n  }\n  addFilters(extraFilters) {\n    this.filterStack.push(extraFilters);\n  }\n  getCallNumber() {\n    return this.callNumber;\n  }\n  startRead() {\n    /* If the stream has ended with an error, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n      return;\n    }\n    this.canPush = true;\n    if (this.http2Stream === null) {\n      this.pendingRead = true;\n    } else {\n      if (this.unpushedReadMessages.length > 0) {\n        const nextMessage = this.unpushedReadMessages.shift();\n        this.push(nextMessage);\n        return;\n      }\n      /* Only resume reading from the http2Stream if we don't have any pending\n       * messages to emit */\n      this.http2Stream.resume();\n    }\n  }\n  maybeCloseWrites() {\n    if (this.writesClosed && !this.isWriteFilterPending && this.http2Stream !== null) {\n      this.trace('calling end() on HTTP/2 stream');\n      this.http2Stream.end();\n    }\n  }\n  sendMessageWithContext(context, message) {\n    this.trace('write() called with message of length ' + message.length);\n    const writeObj = {\n      message,\n      flags: context.flags\n    };\n    const cb = error => {\n      var _a, _b;\n      let code = constants_1.Status.UNAVAILABLE;\n      if (((_a = error) === null || _a === void 0 ? void 0 : _a.code) === 'ERR_STREAM_WRITE_AFTER_END') {\n        code = constants_1.Status.INTERNAL;\n      }\n      if (error) {\n        this.cancelWithStatus(code, `Write error: ${error.message}`);\n      }\n      (_b = context.callback) === null || _b === void 0 ? void 0 : _b.call(context);\n    };\n    this.isWriteFilterPending = true;\n    this.filterStack.sendMessage(Promise.resolve(writeObj)).then(message => {\n      this.isWriteFilterPending = false;\n      if (this.http2Stream === null) {\n        this.trace('deferring writing data chunk of length ' + message.message.length);\n        this.pendingWrite = message.message;\n        this.pendingWriteCallback = cb;\n      } else {\n        this.trace('sending data chunk of length ' + message.message.length);\n        try {\n          this.writeMessageToStream(message.message, cb);\n        } catch (error) {\n          this.endCall({\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Write failed with error ${error.message}`,\n            metadata: new metadata_1.Metadata()\n          });\n        }\n        this.maybeCloseWrites();\n      }\n    }, this.handleFilterError.bind(this));\n  }\n  halfClose() {\n    this.trace('end() called');\n    this.writesClosed = true;\n    this.maybeCloseWrites();\n  }\n}\nexports.Http2CallStream = Http2CallStream;","map":{"version":3,"names":["Object","defineProperty","exports","value","Http2CallStream","InterceptingListenerImpl","isInterceptingListener","http2","require","os","constants_1","metadata_1","stream_decoder_1","logging","constants_2","TRACER_NAME","HTTP2_HEADER_STATUS","HTTP2_HEADER_CONTENT_TYPE","NGHTTP2_CANCEL","constants","getSystemErrorName","errno","name","num","entries","getMinDeadline","deadlineList","minValue","Infinity","deadline","deadlineMsecs","Date","getTime","listener","onReceiveMetadata","undefined","length","constructor","nextListener","processingMetadata","hasPendingMessage","processingMessage","pendingStatus","processPendingMessage","onReceiveMessage","pendingMessage","processPendingStatus","onReceiveStatus","metadata","message","msg","status","processedStatus","methodName","channel","options","filterStackFactory","channelCallCredentials","callNumber","http2Stream","pendingRead","isWriteFilterPending","pendingWrite","pendingWriteCallback","writesClosed","decoder","StreamDecoder","isReadFilterPending","canPush","readsClosed","statusOutput","unpushedReadMessages","unfilteredReadMessages","mappedStatusCode","Status","UNKNOWN","finalStatus","subchannel","internalError","configDeadline","statusWatchers","streamEndWatchers","callStatsTracker","filterStack","createFilter","credentials","disconnectListener","endCall","code","UNAVAILABLE","details","Metadata","parentCall","flags","Propagate","CANCELLATION","on","cancelWithStatus","CANCELLED","outputStatus","_a","filteredStatus","receiveTrailers","trace","forEach","watcher","process","nextTick","resume","callUnref","removeDisconnectListener","text","LogVerbosity","DEBUG","OK","maybeOutputStatus","destroyHttp2Stream","push","Buffer","handleFilterError","error","INTERNAL","handleFilteredRead","pause","nextMessage","shift","filterReceivedMessage","framedMessage","receiveMessage","Promise","resolve","then","bind","tryPush","messageBytes","handleTrailers","headers","headersString","header","keys","fromHttp2Headers","e","metadataMap","getMap","receivedStatus","Number","remove","decodeURI","writeMessageToStream","callback","addMessageSent","write","attachHttp2Stream","stream","extraFilters","close","getAddress","addDisconnectListener","callRef","UNAUTHENTICATED","PERMISSION_DENIED","UNIMPLEMENTED","NGHTTP2_FLAG_END_STREAM","finalMetadata","receiveMetadata","data","messages","addMessageReceived","rstCode","NGHTTP2_NO_ERROR","NGHTTP2_REFUSED_STREAM","NGHTTP2_ENHANCE_YOUR_CALM","RESOURCE_EXHAUSTED","NGHTTP2_INADEQUATE_SECURITY","NGHTTP2_INTERNAL_ERROR","err","syscall","Error","maybeCloseWrites","start","_startCallStream","destroyed","getDeadline","DEADLINE","getCredentials","setCredentials","compose","getStatus","getPeer","_b","getTarget","getMethod","getHost","host","setConfigDeadline","addStatusWatcher","addStreamEndWatcher","addFilters","getCallNumber","startRead","end","sendMessageWithContext","context","writeObj","cb","call","sendMessage","halfClose"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/call-stream.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Http2CallStream = exports.InterceptingListenerImpl = exports.isInterceptingListener = void 0;\nconst http2 = require(\"http2\");\nconst os = require(\"os\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst TRACER_NAME = 'call_stream';\nconst { HTTP2_HEADER_STATUS, HTTP2_HEADER_CONTENT_TYPE, NGHTTP2_CANCEL, } = http2.constants;\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno) {\n    for (const [name, num] of Object.entries(os.constants.errno)) {\n        if (num === errno) {\n            return name;\n        }\n    }\n    return 'Unknown system error ' + errno;\n}\nfunction getMinDeadline(deadlineList) {\n    let minValue = Infinity;\n    for (const deadline of deadlineList) {\n        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;\n        if (deadlineMsecs < minValue) {\n            minValue = deadlineMsecs;\n        }\n    }\n    return minValue;\n}\nfunction isInterceptingListener(listener) {\n    return (listener.onReceiveMetadata !== undefined &&\n        listener.onReceiveMetadata.length === 1);\n}\nexports.isInterceptingListener = isInterceptingListener;\nclass InterceptingListenerImpl {\n    constructor(listener, nextListener) {\n        this.listener = listener;\n        this.nextListener = nextListener;\n        this.processingMetadata = false;\n        this.hasPendingMessage = false;\n        this.processingMessage = false;\n        this.pendingStatus = null;\n    }\n    processPendingMessage() {\n        if (this.hasPendingMessage) {\n            this.nextListener.onReceiveMessage(this.pendingMessage);\n            this.pendingMessage = null;\n            this.hasPendingMessage = false;\n        }\n    }\n    processPendingStatus() {\n        if (this.pendingStatus) {\n            this.nextListener.onReceiveStatus(this.pendingStatus);\n        }\n    }\n    onReceiveMetadata(metadata) {\n        this.processingMetadata = true;\n        this.listener.onReceiveMetadata(metadata, (metadata) => {\n            this.processingMetadata = false;\n            this.nextListener.onReceiveMetadata(metadata);\n            this.processPendingMessage();\n            this.processPendingStatus();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onReceiveMessage(message) {\n        /* If this listener processes messages asynchronously, the last message may\n         * be reordered with respect to the status */\n        this.processingMessage = true;\n        this.listener.onReceiveMessage(message, (msg) => {\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessage = msg;\n                this.hasPendingMessage = true;\n            }\n            else {\n                this.nextListener.onReceiveMessage(msg);\n                this.processPendingStatus();\n            }\n        });\n    }\n    onReceiveStatus(status) {\n        this.listener.onReceiveStatus(status, (processedStatus) => {\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingStatus = processedStatus;\n            }\n            else {\n                this.nextListener.onReceiveStatus(processedStatus);\n            }\n        });\n    }\n}\nexports.InterceptingListenerImpl = InterceptingListenerImpl;\nclass Http2CallStream {\n    constructor(methodName, channel, options, filterStackFactory, channelCallCredentials, callNumber) {\n        this.methodName = methodName;\n        this.channel = channel;\n        this.options = options;\n        this.channelCallCredentials = channelCallCredentials;\n        this.callNumber = callNumber;\n        this.http2Stream = null;\n        this.pendingRead = false;\n        this.isWriteFilterPending = false;\n        this.pendingWrite = null;\n        this.pendingWriteCallback = null;\n        this.writesClosed = false;\n        this.decoder = new stream_decoder_1.StreamDecoder();\n        this.isReadFilterPending = false;\n        this.canPush = false;\n        /**\n         * Indicates that an 'end' event has come from the http2 stream, so there\n         * will be no more data events.\n         */\n        this.readsClosed = false;\n        this.statusOutput = false;\n        this.unpushedReadMessages = [];\n        this.unfilteredReadMessages = [];\n        // Status code mapped from :status. To be used if grpc-status is not received\n        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        // This is populated (non-null) if and only if the call has ended\n        this.finalStatus = null;\n        this.subchannel = null;\n        this.listener = null;\n        this.internalError = null;\n        this.configDeadline = Infinity;\n        this.statusWatchers = [];\n        this.streamEndWatchers = [];\n        this.callStatsTracker = null;\n        this.filterStack = filterStackFactory.createFilter(this);\n        this.credentials = channelCallCredentials;\n        this.disconnectListener = () => {\n            this.endCall({\n                code: constants_1.Status.UNAVAILABLE,\n                details: 'Connection dropped',\n                metadata: new metadata_1.Metadata(),\n            });\n        };\n        if (this.options.parentCall &&\n            this.options.flags & constants_1.Propagate.CANCELLATION) {\n            this.options.parentCall.on('cancelled', () => {\n                this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');\n            });\n        }\n    }\n    outputStatus() {\n        var _a;\n        /* Precondition: this.finalStatus !== null */\n        if (this.listener && !this.statusOutput) {\n            this.statusOutput = true;\n            const filteredStatus = this.filterStack.receiveTrailers(this.finalStatus);\n            this.trace('ended with status: code=' +\n                filteredStatus.code +\n                ' details=\"' +\n                filteredStatus.details +\n                '\"');\n            this.statusWatchers.forEach(watcher => watcher(filteredStatus));\n            /* We delay the actual action of bubbling up the status to insulate the\n             * cleanup code in this class from any errors that may be thrown in the\n             * upper layers as a result of bubbling up the status. In particular,\n             * if the status is not OK, the \"error\" event may be emitted\n             * synchronously at the top level, which will result in a thrown error if\n             * the user does not handle that event. */\n            process.nextTick(() => {\n                var _a;\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n            });\n            /* Leave the http2 stream in flowing state to drain incoming messages, to\n             * ensure that the stream closure completes. The call stream already does\n             * not push more messages after the status is output, so the messages go\n             * nowhere either way. */\n            (_a = this.http2Stream) === null || _a === void 0 ? void 0 : _a.resume();\n            if (this.subchannel) {\n                this.subchannel.callUnref();\n                this.subchannel.removeDisconnectListener(this.disconnectListener);\n            }\n        }\n    }\n    trace(text) {\n        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n    }\n    /**\n     * On first call, emits a 'status' event with the given StatusObject.\n     * Subsequent calls are no-ops.\n     * @param status The status of the call.\n     */\n    endCall(status) {\n        /* If the status is OK and a new status comes in (e.g. from a\n         * deserialization failure), that new status takes priority */\n        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n            this.finalStatus = status;\n            this.maybeOutputStatus();\n        }\n        this.destroyHttp2Stream();\n    }\n    maybeOutputStatus() {\n        if (this.finalStatus !== null) {\n            /* The combination check of readsClosed and that the two message buffer\n             * arrays are empty checks that there all incoming data has been fully\n             * processed */\n            if (this.finalStatus.code !== constants_1.Status.OK ||\n                (this.readsClosed &&\n                    this.unpushedReadMessages.length === 0 &&\n                    this.unfilteredReadMessages.length === 0 &&\n                    !this.isReadFilterPending)) {\n                this.outputStatus();\n            }\n        }\n    }\n    push(message) {\n        this.trace('pushing to reader message of length ' +\n            (message instanceof Buffer ? message.length : null));\n        this.canPush = false;\n        process.nextTick(() => {\n            var _a;\n            /* If we have already output the status any later messages should be\n             * ignored, and can cause out-of-order operation errors higher up in the\n             * stack. Checking as late as possible here to avoid any race conditions.\n             */\n            if (this.statusOutput) {\n                return;\n            }\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMessage(message);\n            this.maybeOutputStatus();\n        });\n    }\n    handleFilterError(error) {\n        this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n    }\n    handleFilteredRead(message) {\n        /* If we the call has already ended with an error, we don't want to do\n         * anything with this message. Dropping it on the floor is correct\n         * behavior */\n        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.maybeOutputStatus();\n            return;\n        }\n        this.isReadFilterPending = false;\n        if (this.canPush) {\n            this.http2Stream.pause();\n            this.push(message);\n        }\n        else {\n            this.trace('unpushedReadMessages.push message of length ' + message.length);\n            this.unpushedReadMessages.push(message);\n        }\n        if (this.unfilteredReadMessages.length > 0) {\n            /* nextMessage is guaranteed not to be undefined because\n               unfilteredReadMessages is non-empty */\n            const nextMessage = this.unfilteredReadMessages.shift();\n            this.filterReceivedMessage(nextMessage);\n        }\n    }\n    filterReceivedMessage(framedMessage) {\n        /* If we the call has already ended with an error, we don't want to do\n         * anything with this message. Dropping it on the floor is correct\n         * behavior */\n        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.maybeOutputStatus();\n            return;\n        }\n        this.trace('filterReceivedMessage of length ' + framedMessage.length);\n        this.isReadFilterPending = true;\n        this.filterStack\n            .receiveMessage(Promise.resolve(framedMessage))\n            .then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n    }\n    tryPush(messageBytes) {\n        if (this.isReadFilterPending) {\n            this.trace('unfilteredReadMessages.push message of length ' +\n                (messageBytes && messageBytes.length));\n            this.unfilteredReadMessages.push(messageBytes);\n        }\n        else {\n            this.filterReceivedMessage(messageBytes);\n        }\n    }\n    handleTrailers(headers) {\n        this.streamEndWatchers.forEach(watcher => watcher(true));\n        let headersString = '';\n        for (const header of Object.keys(headers)) {\n            headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n        }\n        this.trace('Received server trailers:\\n' + headersString);\n        let metadata;\n        try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        }\n        catch (e) {\n            metadata = new metadata_1.Metadata();\n        }\n        const metadataMap = metadata.getMap();\n        let code = this.mappedStatusCode;\n        if (code === constants_1.Status.UNKNOWN &&\n            typeof metadataMap['grpc-status'] === 'string') {\n            const receivedStatus = Number(metadataMap['grpc-status']);\n            if (receivedStatus in constants_1.Status) {\n                code = receivedStatus;\n                this.trace('received status code ' + receivedStatus + ' from server');\n            }\n            metadata.remove('grpc-status');\n        }\n        let details = '';\n        if (typeof metadataMap['grpc-message'] === 'string') {\n            try {\n                details = decodeURI(metadataMap['grpc-message']);\n            }\n            catch (e) {\n                details = metadataMap['grpc-message'];\n            }\n            metadata.remove('grpc-message');\n            this.trace('received status details string \"' + details + '\" from server');\n        }\n        const status = { code, details, metadata };\n        // This is a no-op if the call was already ended when handling headers.\n        this.endCall(status);\n    }\n    writeMessageToStream(message, callback) {\n        var _a;\n        (_a = this.callStatsTracker) === null || _a === void 0 ? void 0 : _a.addMessageSent();\n        this.http2Stream.write(message, callback);\n    }\n    attachHttp2Stream(stream, subchannel, extraFilters, callStatsTracker) {\n        this.filterStack.push(extraFilters);\n        if (this.finalStatus !== null) {\n            stream.close(NGHTTP2_CANCEL);\n        }\n        else {\n            this.trace('attachHttp2Stream from subchannel ' + subchannel.getAddress());\n            this.http2Stream = stream;\n            this.subchannel = subchannel;\n            this.callStatsTracker = callStatsTracker;\n            subchannel.addDisconnectListener(this.disconnectListener);\n            subchannel.callRef();\n            stream.on('response', (headers, flags) => {\n                var _a;\n                let headersString = '';\n                for (const header of Object.keys(headers)) {\n                    headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n                }\n                this.trace('Received server headers:\\n' + headersString);\n                switch (headers[':status']) {\n                    // TODO(murgatroid99): handle 100 and 101\n                    case 400:\n                        this.mappedStatusCode = constants_1.Status.INTERNAL;\n                        break;\n                    case 401:\n                        this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n                        break;\n                    case 403:\n                        this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n                        break;\n                    case 404:\n                        this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n                        break;\n                    case 429:\n                    case 502:\n                    case 503:\n                    case 504:\n                        this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n                        break;\n                    default:\n                        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n                }\n                if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n                    this.handleTrailers(headers);\n                }\n                else {\n                    let metadata;\n                    try {\n                        metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n                    }\n                    catch (error) {\n                        this.endCall({\n                            code: constants_1.Status.UNKNOWN,\n                            details: error.message,\n                            metadata: new metadata_1.Metadata(),\n                        });\n                        return;\n                    }\n                    try {\n                        const finalMetadata = this.filterStack.receiveMetadata(metadata);\n                        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMetadata(finalMetadata);\n                    }\n                    catch (error) {\n                        this.endCall({\n                            code: constants_1.Status.UNKNOWN,\n                            details: error.message,\n                            metadata: new metadata_1.Metadata(),\n                        });\n                    }\n                }\n            });\n            stream.on('trailers', (headers) => {\n                this.handleTrailers(headers);\n            });\n            stream.on('data', (data) => {\n                /* If the status has already been output, allow the http2 stream to\n                 * drain without processing the data. */\n                if (this.statusOutput) {\n                    return;\n                }\n                this.trace('receive HTTP/2 data frame of length ' + data.length);\n                const messages = this.decoder.write(data);\n                for (const message of messages) {\n                    this.trace('parsed message of length ' + message.length);\n                    this.callStatsTracker.addMessageReceived();\n                    this.tryPush(message);\n                }\n            });\n            stream.on('end', () => {\n                this.readsClosed = true;\n                this.maybeOutputStatus();\n            });\n            stream.on('close', () => {\n                /* Use process.next tick to ensure that this code happens after any\n                 * \"error\" event that may be emitted at about the same time, so that\n                 * we can bubble up the error message from that event. */\n                process.nextTick(() => {\n                    var _a;\n                    this.trace('HTTP/2 stream closed with code ' + stream.rstCode);\n                    /* If we have a final status with an OK status code, that means that\n                     * we have received all of the messages and we have processed the\n                     * trailers and the call completed successfully, so it doesn't matter\n                     * how the stream ends after that */\n                    if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                        return;\n                    }\n                    let code;\n                    let details = '';\n                    switch (stream.rstCode) {\n                        case http2.constants.NGHTTP2_NO_ERROR:\n                            /* If we get a NO_ERROR code and we already have a status, the\n                             * stream completed properly and we just haven't fully processed\n                             * it yet */\n                            if (this.finalStatus !== null) {\n                                return;\n                            }\n                            code = constants_1.Status.INTERNAL;\n                            details = `Received RST_STREAM with code ${stream.rstCode}`;\n                            break;\n                        case http2.constants.NGHTTP2_REFUSED_STREAM:\n                            code = constants_1.Status.UNAVAILABLE;\n                            details = 'Stream refused by server';\n                            break;\n                        case http2.constants.NGHTTP2_CANCEL:\n                            code = constants_1.Status.CANCELLED;\n                            details = 'Call cancelled';\n                            break;\n                        case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n                            code = constants_1.Status.RESOURCE_EXHAUSTED;\n                            details = 'Bandwidth exhausted or memory limit exceeded';\n                            break;\n                        case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n                            code = constants_1.Status.PERMISSION_DENIED;\n                            details = 'Protocol not secure enough';\n                            break;\n                        case http2.constants.NGHTTP2_INTERNAL_ERROR:\n                            code = constants_1.Status.INTERNAL;\n                            if (this.internalError === null) {\n                                /* This error code was previously handled in the default case, and\n                                 * there are several instances of it online, so I wanted to\n                                 * preserve the original error message so that people find existing\n                                 * information in searches, but also include the more recognizable\n                                 * \"Internal server error\" message. */\n                                details = `Received RST_STREAM with code ${stream.rstCode} (Internal server error)`;\n                            }\n                            else {\n                                if (this.internalError.code === 'ECONNRESET' || this.internalError.code === 'ETIMEDOUT') {\n                                    code = constants_1.Status.UNAVAILABLE;\n                                    details = this.internalError.message;\n                                }\n                                else {\n                                    /* The \"Received RST_STREAM with code ...\" error is preserved\n                                     * here for continuity with errors reported online, but the\n                                     * error message at the end will probably be more relevant in\n                                     * most cases. */\n                                    details = `Received RST_STREAM with code ${stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n                                }\n                            }\n                            break;\n                        default:\n                            code = constants_1.Status.INTERNAL;\n                            details = `Received RST_STREAM with code ${stream.rstCode}`;\n                    }\n                    // This is a no-op if trailers were received at all.\n                    // This is OK, because status codes emitted here correspond to more\n                    // catastrophic issues that prevent us from receiving trailers in the\n                    // first place.\n                    this.endCall({ code, details, metadata: new metadata_1.Metadata() });\n                });\n            });\n            stream.on('error', (err) => {\n                /* We need an error handler here to stop \"Uncaught Error\" exceptions\n                 * from bubbling up. However, errors here should all correspond to\n                 * \"close\" events, where we will handle the error more granularly */\n                /* Specifically looking for stream errors that were *not* constructed\n                 * from a RST_STREAM response here:\n                 * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n                 */\n                if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n                    this.trace('Node error event: message=' +\n                        err.message +\n                        ' code=' +\n                        err.code +\n                        ' errno=' +\n                        getSystemErrorName(err.errno) +\n                        ' syscall=' +\n                        err.syscall);\n                    this.internalError = err;\n                }\n                this.streamEndWatchers.forEach(watcher => watcher(false));\n            });\n            if (this.pendingWrite) {\n                if (!this.pendingWriteCallback) {\n                    throw new Error('Invalid state in write handling code');\n                }\n                this.trace('sending data chunk of length ' +\n                    this.pendingWrite.length +\n                    ' (deferred)');\n                try {\n                    this.writeMessageToStream(this.pendingWrite, this.pendingWriteCallback);\n                }\n                catch (error) {\n                    this.endCall({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: `Write failed with error ${error.message}`,\n                        metadata: new metadata_1.Metadata()\n                    });\n                }\n            }\n            this.maybeCloseWrites();\n        }\n    }\n    start(metadata, listener) {\n        this.trace('Sending metadata');\n        this.listener = listener;\n        this.channel._startCallStream(this, metadata);\n        this.maybeOutputStatus();\n    }\n    destroyHttp2Stream() {\n        var _a;\n        // The http2 stream could already have been destroyed if cancelWithStatus\n        // is called in response to an internal http2 error.\n        if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n            /* If the call has ended with an OK status, communicate that when closing\n             * the stream, partly to avoid a situation in which we detect an error\n             * RST_STREAM as a result after we have the status */\n            let code;\n            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                code = http2.constants.NGHTTP2_NO_ERROR;\n            }\n            else {\n                code = http2.constants.NGHTTP2_CANCEL;\n            }\n            this.trace('close http2 stream with code ' + code);\n            this.http2Stream.close(code);\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });\n    }\n    getDeadline() {\n        const deadlineList = [this.options.deadline];\n        if (this.options.parentCall && this.options.flags & constants_1.Propagate.DEADLINE) {\n            deadlineList.push(this.options.parentCall.getDeadline());\n        }\n        if (this.configDeadline) {\n            deadlineList.push(this.configDeadline);\n        }\n        return getMinDeadline(deadlineList);\n    }\n    getCredentials() {\n        return this.credentials;\n    }\n    setCredentials(credentials) {\n        this.credentials = this.channelCallCredentials.compose(credentials);\n    }\n    getStatus() {\n        return this.finalStatus;\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    getMethod() {\n        return this.methodName;\n    }\n    getHost() {\n        return this.options.host;\n    }\n    setConfigDeadline(configDeadline) {\n        this.configDeadline = configDeadline;\n    }\n    addStatusWatcher(watcher) {\n        this.statusWatchers.push(watcher);\n    }\n    addStreamEndWatcher(watcher) {\n        this.streamEndWatchers.push(watcher);\n    }\n    addFilters(extraFilters) {\n        this.filterStack.push(extraFilters);\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n    startRead() {\n        /* If the stream has ended with an error, we should not emit any more\n         * messages and we should communicate that the stream has ended */\n        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n            return;\n        }\n        this.canPush = true;\n        if (this.http2Stream === null) {\n            this.pendingRead = true;\n        }\n        else {\n            if (this.unpushedReadMessages.length > 0) {\n                const nextMessage = this.unpushedReadMessages.shift();\n                this.push(nextMessage);\n                return;\n            }\n            /* Only resume reading from the http2Stream if we don't have any pending\n             * messages to emit */\n            this.http2Stream.resume();\n        }\n    }\n    maybeCloseWrites() {\n        if (this.writesClosed &&\n            !this.isWriteFilterPending &&\n            this.http2Stream !== null) {\n            this.trace('calling end() on HTTP/2 stream');\n            this.http2Stream.end();\n        }\n    }\n    sendMessageWithContext(context, message) {\n        this.trace('write() called with message of length ' + message.length);\n        const writeObj = {\n            message,\n            flags: context.flags,\n        };\n        const cb = (error) => {\n            var _a, _b;\n            let code = constants_1.Status.UNAVAILABLE;\n            if (((_a = error) === null || _a === void 0 ? void 0 : _a.code) === 'ERR_STREAM_WRITE_AFTER_END') {\n                code = constants_1.Status.INTERNAL;\n            }\n            if (error) {\n                this.cancelWithStatus(code, `Write error: ${error.message}`);\n            }\n            (_b = context.callback) === null || _b === void 0 ? void 0 : _b.call(context);\n        };\n        this.isWriteFilterPending = true;\n        this.filterStack.sendMessage(Promise.resolve(writeObj)).then((message) => {\n            this.isWriteFilterPending = false;\n            if (this.http2Stream === null) {\n                this.trace('deferring writing data chunk of length ' + message.message.length);\n                this.pendingWrite = message.message;\n                this.pendingWriteCallback = cb;\n            }\n            else {\n                this.trace('sending data chunk of length ' + message.message.length);\n                try {\n                    this.writeMessageToStream(message.message, cb);\n                }\n                catch (error) {\n                    this.endCall({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: `Write failed with error ${error.message}`,\n                        metadata: new metadata_1.Metadata()\n                    });\n                }\n                this.maybeCloseWrites();\n            }\n        }, this.handleFilterError.bind(this));\n    }\n    halfClose() {\n        this.trace('end() called');\n        this.writesClosed = true;\n        this.maybeCloseWrites();\n    }\n}\nexports.Http2CallStream = Http2CallStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}