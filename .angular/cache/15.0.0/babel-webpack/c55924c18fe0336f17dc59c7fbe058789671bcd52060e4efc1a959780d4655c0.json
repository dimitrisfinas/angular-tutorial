{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { AggregatorKind } from './types';\nimport { DataPointType } from '../export/MetricData';\nvar SumAccumulation = /** @class */function () {\n  function SumAccumulation(startTime, monotonic, _current, reset) {\n    if (_current === void 0) {\n      _current = 0;\n    }\n    if (reset === void 0) {\n      reset = false;\n    }\n    this.startTime = startTime;\n    this.monotonic = monotonic;\n    this._current = _current;\n    this.reset = reset;\n  }\n  SumAccumulation.prototype.record = function (value) {\n    if (this.monotonic && value < 0) {\n      return;\n    }\n    this._current += value;\n  };\n  SumAccumulation.prototype.setStartTime = function (startTime) {\n    this.startTime = startTime;\n  };\n  SumAccumulation.prototype.toPointValue = function () {\n    return this._current;\n  };\n  return SumAccumulation;\n}();\nexport { SumAccumulation };\n/** Basic aggregator which calculates a Sum from individual measurements. */\nvar SumAggregator = /** @class */function () {\n  function SumAggregator(monotonic) {\n    this.monotonic = monotonic;\n    this.kind = AggregatorKind.SUM;\n  }\n  SumAggregator.prototype.createAccumulation = function (startTime) {\n    return new SumAccumulation(startTime, this.monotonic);\n  };\n  /**\n   * Returns the result of the merge of the given accumulations.\n   */\n  SumAggregator.prototype.merge = function (previous, delta) {\n    var prevPv = previous.toPointValue();\n    var deltaPv = delta.toPointValue();\n    if (delta.reset) {\n      return new SumAccumulation(delta.startTime, this.monotonic, deltaPv, delta.reset);\n    }\n    return new SumAccumulation(previous.startTime, this.monotonic, prevPv + deltaPv);\n  };\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  SumAggregator.prototype.diff = function (previous, current) {\n    var prevPv = previous.toPointValue();\n    var currPv = current.toPointValue();\n    /**\n     * If the SumAggregator is a monotonic one and the previous point value is\n     * greater than the current one, a reset is deemed to be happened.\n     * Return the current point value to prevent the value from been reset.\n     */\n    if (this.monotonic && prevPv > currPv) {\n      return new SumAccumulation(current.startTime, this.monotonic, currPv, true);\n    }\n    return new SumAccumulation(current.startTime, this.monotonic, currPv - prevPv);\n  };\n  SumAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor: descriptor,\n      aggregationTemporality: aggregationTemporality,\n      dataPointType: DataPointType.SUM,\n      dataPoints: accumulationByAttributes.map(function (_a) {\n        var _b = __read(_a, 2),\n          attributes = _b[0],\n          accumulation = _b[1];\n        return {\n          attributes: attributes,\n          startTime: accumulation.startTime,\n          endTime: endTime,\n          value: accumulation.toPointValue()\n        };\n      }),\n      isMonotonic: this.monotonic\n    };\n  };\n  return SumAggregator;\n}();\nexport { SumAggregator };","map":{"version":3,"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","AggregatorKind","DataPointType","SumAccumulation","startTime","monotonic","_current","reset","prototype","record","setStartTime","toPointValue","SumAggregator","kind","SUM","createAccumulation","merge","previous","delta","prevPv","deltaPv","diff","current","currPv","toMetricData","descriptor","aggregationTemporality","accumulationByAttributes","endTime","dataPointType","dataPoints","map","_a","_b","attributes","accumulation","isMonotonic"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@opentelemetry/sdk-metrics/build/esm/aggregator/Sum.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { AggregatorKind } from './types';\nimport { DataPointType } from '../export/MetricData';\nvar SumAccumulation = /** @class */ (function () {\n    function SumAccumulation(startTime, monotonic, _current, reset) {\n        if (_current === void 0) { _current = 0; }\n        if (reset === void 0) { reset = false; }\n        this.startTime = startTime;\n        this.monotonic = monotonic;\n        this._current = _current;\n        this.reset = reset;\n    }\n    SumAccumulation.prototype.record = function (value) {\n        if (this.monotonic && value < 0) {\n            return;\n        }\n        this._current += value;\n    };\n    SumAccumulation.prototype.setStartTime = function (startTime) {\n        this.startTime = startTime;\n    };\n    SumAccumulation.prototype.toPointValue = function () {\n        return this._current;\n    };\n    return SumAccumulation;\n}());\nexport { SumAccumulation };\n/** Basic aggregator which calculates a Sum from individual measurements. */\nvar SumAggregator = /** @class */ (function () {\n    function SumAggregator(monotonic) {\n        this.monotonic = monotonic;\n        this.kind = AggregatorKind.SUM;\n    }\n    SumAggregator.prototype.createAccumulation = function (startTime) {\n        return new SumAccumulation(startTime, this.monotonic);\n    };\n    /**\n     * Returns the result of the merge of the given accumulations.\n     */\n    SumAggregator.prototype.merge = function (previous, delta) {\n        var prevPv = previous.toPointValue();\n        var deltaPv = delta.toPointValue();\n        if (delta.reset) {\n            return new SumAccumulation(delta.startTime, this.monotonic, deltaPv, delta.reset);\n        }\n        return new SumAccumulation(previous.startTime, this.monotonic, prevPv + deltaPv);\n    };\n    /**\n     * Returns a new DELTA aggregation by comparing two cumulative measurements.\n     */\n    SumAggregator.prototype.diff = function (previous, current) {\n        var prevPv = previous.toPointValue();\n        var currPv = current.toPointValue();\n        /**\n         * If the SumAggregator is a monotonic one and the previous point value is\n         * greater than the current one, a reset is deemed to be happened.\n         * Return the current point value to prevent the value from been reset.\n         */\n        if (this.monotonic && (prevPv > currPv)) {\n            return new SumAccumulation(current.startTime, this.monotonic, currPv, true);\n        }\n        return new SumAccumulation(current.startTime, this.monotonic, currPv - prevPv);\n    };\n    SumAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n        return {\n            descriptor: descriptor,\n            aggregationTemporality: aggregationTemporality,\n            dataPointType: DataPointType.SUM,\n            dataPoints: accumulationByAttributes.map(function (_a) {\n                var _b = __read(_a, 2), attributes = _b[0], accumulation = _b[1];\n                return {\n                    attributes: attributes,\n                    startTime: accumulation.startTime,\n                    endTime: endTime,\n                    value: accumulation.toPointValue(),\n                };\n            }),\n            isMonotonic: this.monotonic\n        };\n    };\n    return SumAggregator;\n}());\nexport { SumAggregator };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}