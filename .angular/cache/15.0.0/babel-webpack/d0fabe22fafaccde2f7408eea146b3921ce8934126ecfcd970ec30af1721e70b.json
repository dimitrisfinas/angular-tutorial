{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamDecoder = void 0;\nvar ReadState;\n(function (ReadState) {\n  ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n  ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n  ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\nclass StreamDecoder {\n  constructor() {\n    this.readState = ReadState.NO_DATA;\n    this.readCompressFlag = Buffer.alloc(1);\n    this.readPartialSize = Buffer.alloc(4);\n    this.readSizeRemaining = 4;\n    this.readMessageSize = 0;\n    this.readPartialMessage = [];\n    this.readMessageRemaining = 0;\n  }\n  write(data) {\n    let readHead = 0;\n    let toRead;\n    const result = [];\n    while (readHead < data.length) {\n      switch (this.readState) {\n        case ReadState.NO_DATA:\n          this.readCompressFlag = data.slice(readHead, readHead + 1);\n          readHead += 1;\n          this.readState = ReadState.READING_SIZE;\n          this.readPartialSize.fill(0);\n          this.readSizeRemaining = 4;\n          this.readMessageSize = 0;\n          this.readMessageRemaining = 0;\n          this.readPartialMessage = [];\n          break;\n        case ReadState.READING_SIZE:\n          toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n          data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n          this.readSizeRemaining -= toRead;\n          readHead += toRead;\n          // readSizeRemaining >=0 here\n          if (this.readSizeRemaining === 0) {\n            this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n            this.readMessageRemaining = this.readMessageSize;\n            if (this.readMessageRemaining > 0) {\n              this.readState = ReadState.READING_MESSAGE;\n            } else {\n              const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);\n              this.readState = ReadState.NO_DATA;\n              result.push(message);\n            }\n          }\n          break;\n        case ReadState.READING_MESSAGE:\n          toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n          this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n          this.readMessageRemaining -= toRead;\n          readHead += toRead;\n          // readMessageRemaining >=0 here\n          if (this.readMessageRemaining === 0) {\n            // At this point, we have read a full message\n            const framedMessageBuffers = [this.readCompressFlag, this.readPartialSize].concat(this.readPartialMessage);\n            const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n            this.readState = ReadState.NO_DATA;\n            result.push(framedMessage);\n          }\n          break;\n        default:\n          throw new Error('Unexpected read state');\n      }\n    }\n    return result;\n  }\n}\nexports.StreamDecoder = StreamDecoder;","map":{"version":3,"names":["Object","defineProperty","exports","value","StreamDecoder","ReadState","constructor","readState","NO_DATA","readCompressFlag","Buffer","alloc","readPartialSize","readSizeRemaining","readMessageSize","readPartialMessage","readMessageRemaining","write","data","readHead","toRead","result","length","slice","READING_SIZE","fill","Math","min","copy","readUInt32BE","READING_MESSAGE","message","concat","push","framedMessageBuffers","framedMessage","Error"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/stream-decoder.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StreamDecoder = void 0;\nvar ReadState;\n(function (ReadState) {\n    ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n    ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n    ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\nclass StreamDecoder {\n    constructor() {\n        this.readState = ReadState.NO_DATA;\n        this.readCompressFlag = Buffer.alloc(1);\n        this.readPartialSize = Buffer.alloc(4);\n        this.readSizeRemaining = 4;\n        this.readMessageSize = 0;\n        this.readPartialMessage = [];\n        this.readMessageRemaining = 0;\n    }\n    write(data) {\n        let readHead = 0;\n        let toRead;\n        const result = [];\n        while (readHead < data.length) {\n            switch (this.readState) {\n                case ReadState.NO_DATA:\n                    this.readCompressFlag = data.slice(readHead, readHead + 1);\n                    readHead += 1;\n                    this.readState = ReadState.READING_SIZE;\n                    this.readPartialSize.fill(0);\n                    this.readSizeRemaining = 4;\n                    this.readMessageSize = 0;\n                    this.readMessageRemaining = 0;\n                    this.readPartialMessage = [];\n                    break;\n                case ReadState.READING_SIZE:\n                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n                    this.readSizeRemaining -= toRead;\n                    readHead += toRead;\n                    // readSizeRemaining >=0 here\n                    if (this.readSizeRemaining === 0) {\n                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n                        this.readMessageRemaining = this.readMessageSize;\n                        if (this.readMessageRemaining > 0) {\n                            this.readState = ReadState.READING_MESSAGE;\n                        }\n                        else {\n                            const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);\n                            this.readState = ReadState.NO_DATA;\n                            result.push(message);\n                        }\n                    }\n                    break;\n                case ReadState.READING_MESSAGE:\n                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n                    this.readMessageRemaining -= toRead;\n                    readHead += toRead;\n                    // readMessageRemaining >=0 here\n                    if (this.readMessageRemaining === 0) {\n                        // At this point, we have read a full message\n                        const framedMessageBuffers = [\n                            this.readCompressFlag,\n                            this.readPartialSize,\n                        ].concat(this.readPartialMessage);\n                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n                        this.readState = ReadState.NO_DATA;\n                        result.push(framedMessage);\n                    }\n                    break;\n                default:\n                    throw new Error('Unexpected read state');\n            }\n        }\n        return result;\n    }\n}\nexports.StreamDecoder = StreamDecoder;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}