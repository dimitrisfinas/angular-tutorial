{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSubchannelPool = exports.SubchannelPool = void 0;\nconst channel_options_1 = require(\"./channel-options\");\nconst subchannel_1 = require(\"./subchannel\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\nconst REF_CHECK_INTERVAL = 10000;\nclass SubchannelPool {\n  /**\n   * A pool of subchannels use for making connections. Subchannels with the\n   * exact same parameters will be reused.\n   */\n  constructor() {\n    this.pool = Object.create(null);\n    /**\n     * A timer of a task performing a periodic subchannel cleanup.\n     */\n    this.cleanupTimer = null;\n  }\n  /**\n   * Unrefs all unused subchannels and cancels the cleanup task if all\n   * subchannels have been unrefed.\n   */\n  unrefUnusedSubchannels() {\n    let allSubchannelsUnrefed = true;\n    /* These objects are created with Object.create(null), so they do not\n     * have a prototype, which means that for (... in ...) loops over them\n     * do not need to be filtered */\n    // eslint-disable-disable-next-line:forin\n    for (const channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n      const refedSubchannels = subchannelObjArray.filter(value => !value.subchannel.unrefIfOneRef());\n      if (refedSubchannels.length > 0) {\n        allSubchannelsUnrefed = false;\n      }\n      /* For each subchannel in the pool, try to unref it if it has\n       * exactly one ref (which is the ref from the pool itself). If that\n       * does happen, remove the subchannel from the pool */\n      this.pool[channelTarget] = refedSubchannels;\n    }\n    /* Currently we do not delete keys with empty values. If that results\n     * in significant memory usage we should change it. */\n    // Cancel the cleanup task if all subchannels have been unrefed.\n    if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n  /**\n   * Ensures that the cleanup task is spawned.\n   */\n  ensureCleanupTask() {\n    var _a, _b;\n    if (this.cleanupTimer === null) {\n      this.cleanupTimer = setInterval(() => {\n        this.unrefUnusedSubchannels();\n      }, REF_CHECK_INTERVAL);\n      // Unref because this timer should not keep the event loop running.\n      // Call unref only if it exists to address electron/electron#21162\n      (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n  /**\n   * Get a subchannel if one already exists with exactly matching parameters.\n   * Otherwise, create and save a subchannel with those parameters.\n   * @param channelTarget\n   * @param subchannelTarget\n   * @param channelArguments\n   * @param channelCredentials\n   */\n  getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\n    this.ensureCleanupTask();\n    const channelTarget = uri_parser_1.uriToString(channelTargetUri);\n    if (channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n      for (const subchannelObj of subchannelObjArray) {\n        if (subchannel_address_1.subchannelAddressEqual(subchannelTarget, subchannelObj.subchannelAddress) && channel_options_1.channelOptionsEqual(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {\n          return subchannelObj.subchannel;\n        }\n      }\n    }\n    // If we get here, no matching subchannel was found\n    const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials);\n    if (!(channelTarget in this.pool)) {\n      this.pool[channelTarget] = [];\n    }\n    this.pool[channelTarget].push({\n      subchannelAddress: subchannelTarget,\n      channelArguments,\n      channelCredentials,\n      subchannel\n    });\n    subchannel.ref();\n    return subchannel;\n  }\n}\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool();\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\nfunction getSubchannelPool(global) {\n  if (global) {\n    return globalSubchannelPool;\n  } else {\n    return new SubchannelPool();\n  }\n}\nexports.getSubchannelPool = getSubchannelPool;","map":{"version":3,"names":["Object","defineProperty","exports","value","getSubchannelPool","SubchannelPool","channel_options_1","require","subchannel_1","subchannel_address_1","uri_parser_1","REF_CHECK_INTERVAL","constructor","pool","create","cleanupTimer","unrefUnusedSubchannels","allSubchannelsUnrefed","channelTarget","subchannelObjArray","refedSubchannels","filter","subchannel","unrefIfOneRef","length","clearInterval","ensureCleanupTask","_a","_b","setInterval","unref","call","getOrCreateSubchannel","channelTargetUri","subchannelTarget","channelArguments","channelCredentials","uriToString","subchannelObj","subchannelAddressEqual","subchannelAddress","channelOptionsEqual","_equals","Subchannel","push","ref","globalSubchannelPool","global"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/subchannel-pool.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSubchannelPool = exports.SubchannelPool = void 0;\nconst channel_options_1 = require(\"./channel-options\");\nconst subchannel_1 = require(\"./subchannel\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\nconst REF_CHECK_INTERVAL = 10000;\nclass SubchannelPool {\n    /**\n     * A pool of subchannels use for making connections. Subchannels with the\n     * exact same parameters will be reused.\n     */\n    constructor() {\n        this.pool = Object.create(null);\n        /**\n         * A timer of a task performing a periodic subchannel cleanup.\n         */\n        this.cleanupTimer = null;\n    }\n    /**\n     * Unrefs all unused subchannels and cancels the cleanup task if all\n     * subchannels have been unrefed.\n     */\n    unrefUnusedSubchannels() {\n        let allSubchannelsUnrefed = true;\n        /* These objects are created with Object.create(null), so they do not\n         * have a prototype, which means that for (... in ...) loops over them\n         * do not need to be filtered */\n        // eslint-disable-disable-next-line:forin\n        for (const channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            const refedSubchannels = subchannelObjArray.filter((value) => !value.subchannel.unrefIfOneRef());\n            if (refedSubchannels.length > 0) {\n                allSubchannelsUnrefed = false;\n            }\n            /* For each subchannel in the pool, try to unref it if it has\n             * exactly one ref (which is the ref from the pool itself). If that\n             * does happen, remove the subchannel from the pool */\n            this.pool[channelTarget] = refedSubchannels;\n        }\n        /* Currently we do not delete keys with empty values. If that results\n         * in significant memory usage we should change it. */\n        // Cancel the cleanup task if all subchannels have been unrefed.\n        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n            clearInterval(this.cleanupTimer);\n            this.cleanupTimer = null;\n        }\n    }\n    /**\n     * Ensures that the cleanup task is spawned.\n     */\n    ensureCleanupTask() {\n        var _a, _b;\n        if (this.cleanupTimer === null) {\n            this.cleanupTimer = setInterval(() => {\n                this.unrefUnusedSubchannels();\n            }, REF_CHECK_INTERVAL);\n            // Unref because this timer should not keep the event loop running.\n            // Call unref only if it exists to address electron/electron#21162\n            (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Get a subchannel if one already exists with exactly matching parameters.\n     * Otherwise, create and save a subchannel with those parameters.\n     * @param channelTarget\n     * @param subchannelTarget\n     * @param channelArguments\n     * @param channelCredentials\n     */\n    getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\n        this.ensureCleanupTask();\n        const channelTarget = uri_parser_1.uriToString(channelTargetUri);\n        if (channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            for (const subchannelObj of subchannelObjArray) {\n                if (subchannel_address_1.subchannelAddressEqual(subchannelTarget, subchannelObj.subchannelAddress) &&\n                    channel_options_1.channelOptionsEqual(channelArguments, subchannelObj.channelArguments) &&\n                    channelCredentials._equals(subchannelObj.channelCredentials)) {\n                    return subchannelObj.subchannel;\n                }\n            }\n        }\n        // If we get here, no matching subchannel was found\n        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials);\n        if (!(channelTarget in this.pool)) {\n            this.pool[channelTarget] = [];\n        }\n        this.pool[channelTarget].push({\n            subchannelAddress: subchannelTarget,\n            channelArguments,\n            channelCredentials,\n            subchannel,\n        });\n        subchannel.ref();\n        return subchannel;\n    }\n}\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool();\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\nfunction getSubchannelPool(global) {\n    if (global) {\n        return globalSubchannelPool;\n    }\n    else {\n        return new SubchannelPool();\n    }\n}\nexports.getSubchannelPool = getSubchannelPool;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}