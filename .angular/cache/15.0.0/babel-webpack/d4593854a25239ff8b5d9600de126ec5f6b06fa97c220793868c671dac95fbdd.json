{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\nconst metadata_1 = require(\"./metadata\");\nconst call_stream_1 = require(\"./call-stream\");\nconst constants_1 = require(\"./constants\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nclass InterceptorConfigurationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'InterceptorConfigurationError';\n    Error.captureStackTrace(this, InterceptorConfigurationError);\n  }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n  constructor() {\n    this.metadata = undefined;\n    this.message = undefined;\n    this.status = undefined;\n  }\n  withOnReceiveMetadata(onReceiveMetadata) {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n  withOnReceiveMessage(onReceiveMessage) {\n    this.message = onReceiveMessage;\n    return this;\n  }\n  withOnReceiveStatus(onReceiveStatus) {\n    this.status = onReceiveStatus;\n    return this;\n  }\n  build() {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveStatus: this.status\n    };\n  }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n  constructor() {\n    this.start = undefined;\n    this.message = undefined;\n    this.halfClose = undefined;\n    this.cancel = undefined;\n  }\n  withStart(start) {\n    this.start = start;\n    return this;\n  }\n  withSendMessage(sendMessage) {\n    this.message = sendMessage;\n    return this;\n  }\n  withHalfClose(halfClose) {\n    this.halfClose = halfClose;\n    return this;\n  }\n  withCancel(cancel) {\n    this.cancel = cancel;\n    return this;\n  }\n  build() {\n    return {\n      start: this.start,\n      sendMessage: this.message,\n      halfClose: this.halfClose,\n      cancel: this.cancel\n    };\n  }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveStatus: (status, next) => {\n    next(status);\n  }\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester = {\n  start: (metadata, listener, next) => {\n    next(metadata, listener);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  halfClose: next => {\n    next();\n  },\n  cancel: next => {\n    next();\n  }\n};\nclass InterceptingCall {\n  constructor(nextCall, requester) {\n    var _a, _b, _c, _d;\n    this.nextCall = nextCall;\n    /**\n     * Indicates that metadata has been passed to the requester's start\n     * method but it has not been passed to the corresponding next callback\n     */\n    this.processingMetadata = false;\n    /**\n     * Message context for a pending message that is waiting for\n     */\n    this.pendingMessageContext = null;\n    /**\n     * Indicates that a message has been passed to the requester's sendMessage\n     * method but it has not been passed to the corresponding next callback\n     */\n    this.processingMessage = false;\n    /**\n     * Indicates that a status was received but could not be propagated because\n     * a message was still being processed.\n     */\n    this.pendingHalfClose = false;\n    if (requester) {\n      this.requester = {\n        start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n        sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n        halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n        cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel\n      };\n    } else {\n      this.requester = defaultRequester;\n    }\n  }\n  cancelWithStatus(status, details) {\n    this.requester.cancel(() => {\n      this.nextCall.cancelWithStatus(status, details);\n    });\n  }\n  getPeer() {\n    return this.nextCall.getPeer();\n  }\n  processPendingMessage() {\n    if (this.pendingMessageContext) {\n      this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n      this.pendingMessageContext = null;\n      this.pendingMessage = null;\n    }\n  }\n  processPendingHalfClose() {\n    if (this.pendingHalfClose) {\n      this.nextCall.halfClose();\n    }\n  }\n  start(metadata, interceptingListener) {\n    var _a, _b, _c, _d, _e, _f;\n    const fullInterceptingListener = {\n      onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : metadata => {},\n      onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : message => {},\n      onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : status => {}\n    };\n    this.processingMetadata = true;\n    this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n      var _a, _b, _c;\n      this.processingMetadata = false;\n      let finalInterceptingListener;\n      if (call_stream_1.isInterceptingListener(listener)) {\n        finalInterceptingListener = listener;\n      } else {\n        const fullListener = {\n          onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n          onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n          onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus\n        };\n        finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n      }\n      this.nextCall.start(md, finalInterceptingListener);\n      this.processPendingMessage();\n      this.processPendingHalfClose();\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context, message) {\n    this.processingMessage = true;\n    this.requester.sendMessage(message, finalMessage => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessageContext = context;\n        this.pendingMessage = message;\n      } else {\n        this.nextCall.sendMessageWithContext(context, finalMessage);\n        this.processPendingHalfClose();\n      }\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n  startRead() {\n    this.nextCall.startRead();\n  }\n  halfClose() {\n    this.requester.halfClose(() => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingHalfClose = true;\n      } else {\n        this.nextCall.halfClose();\n      }\n    });\n  }\n  setCredentials(credentials) {\n    this.nextCall.setCredentials(credentials);\n  }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n  var _a, _b;\n  const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n  const host = options.host;\n  const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n  const propagateFlags = options.propagate_flags;\n  const credentials = options.credentials;\n  const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall {\n  constructor(call,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition) {\n    this.call = call;\n    this.methodDefinition = methodDefinition;\n  }\n  cancelWithStatus(status, details) {\n    this.call.cancelWithStatus(status, details);\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  setCredentials(credentials) {\n    this.call.setCredentials(credentials);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context, message) {\n    let serialized;\n    try {\n      serialized = this.methodDefinition.requestSerialize(message);\n    } catch (e) {\n      this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${e.message}`);\n      return;\n    }\n    this.call.sendMessageWithContext(context, serialized);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n  start(metadata, interceptingListener) {\n    let readError = null;\n    this.call.start(metadata, {\n      onReceiveMetadata: metadata => {\n        var _a;\n        (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n      },\n      onReceiveMessage: message => {\n        var _a;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let deserialized;\n        try {\n          deserialized = this.methodDefinition.responseDeserialize(message);\n        } catch (e) {\n          readError = {\n            code: constants_1.Status.INTERNAL,\n            details: `Response message parsing error: ${e.message}`,\n            metadata: new metadata_1.Metadata()\n          };\n          this.call.cancelWithStatus(readError.code, readError.details);\n          return;\n        }\n        (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n        if (readError) {\n          (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n        } else {\n          (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n        }\n      }\n    });\n  }\n  startRead() {\n    this.call.startRead();\n  }\n  halfClose() {\n    this.call.halfClose();\n  }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(call, methodDefinition) {\n    super(call, methodDefinition);\n  }\n  start(metadata, listener) {\n    var _a, _b;\n    let receivedMessage = false;\n    const wrapperListener = {\n      onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : metadata => {},\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage: message => {\n        var _a;\n        receivedMessage = true;\n        (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n        if (!receivedMessage) {\n          (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n        }\n        (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n      }\n    };\n    super.start(metadata, wrapperListener);\n    this.call.startRead();\n  }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {}\nfunction getBottomInterceptingCall(channel, options,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n  const call = getCall(channel, methodDefinition.path, options);\n  if (methodDefinition.responseStream) {\n    return new BaseStreamingInterceptingCall(call, methodDefinition);\n  } else {\n    return new BaseUnaryInterceptingCall(call, methodDefinition);\n  }\n}\nfunction getInterceptingCall(interceptorArgs,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n  if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n  }\n  if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' + 'options. Only one of these is allowed.');\n  }\n  let interceptors = [];\n  // Interceptors passed to the call override interceptors passed to the client constructor\n  if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {\n    interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor);\n    // Filter out falsy values when providers return nothing\n  } else {\n    interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor);\n    // Filter out falsy values when providers return nothing\n  }\n\n  const interceptorOptions = Object.assign({}, options, {\n    method_definition: methodDefinition\n  });\n  /* For each interceptor in the list, the nextCall function passed to it is\n   * based on the next interceptor in the list, using a nextCall function\n   * constructed with the following interceptor in the list, and so on. The\n   * initialValue, which is effectively at the end of the list, is a nextCall\n   * function that invokes getBottomInterceptingCall, the result of which\n   * handles (de)serialization and also gets the underlying call from the\n   * channel. */\n  const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\n    return currentOptions => nextInterceptor(currentOptions, nextCall);\n  }, finalOptions => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n  return getCall(interceptorOptions);\n}\nexports.getInterceptingCall = getInterceptingCall;","map":{"version":3,"names":["Object","defineProperty","exports","value","getInterceptingCall","InterceptingCall","RequesterBuilder","ListenerBuilder","InterceptorConfigurationError","metadata_1","require","call_stream_1","constants_1","Error","constructor","message","name","captureStackTrace","metadata","undefined","status","withOnReceiveMetadata","onReceiveMetadata","withOnReceiveMessage","onReceiveMessage","withOnReceiveStatus","onReceiveStatus","build","start","halfClose","cancel","withStart","withSendMessage","sendMessage","withHalfClose","withCancel","defaultListener","next","defaultRequester","listener","nextCall","requester","_a","_b","_c","_d","processingMetadata","pendingMessageContext","processingMessage","pendingHalfClose","cancelWithStatus","details","getPeer","processPendingMessage","sendMessageWithContext","pendingMessage","processPendingHalfClose","interceptingListener","_e","_f","fullInterceptingListener","bind","md","finalInterceptingListener","isInterceptingListener","fullListener","InterceptingListenerImpl","context","finalMessage","startRead","setCredentials","credentials","getCall","channel","path","options","deadline","Infinity","host","parent","propagateFlags","propagate_flags","call","createCall","BaseInterceptingCall","methodDefinition","serialized","requestSerialize","e","Status","INTERNAL","readError","deserialized","responseDeserialize","code","Metadata","BaseUnaryInterceptingCall","receivedMessage","wrapperListener","BaseStreamingInterceptingCall","getBottomInterceptingCall","responseStream","interceptorArgs","clientInterceptors","length","clientInterceptorProviders","callInterceptors","callInterceptorProviders","interceptors","concat","map","provider","filter","interceptor","interceptorOptions","assign","method_definition","reduceRight","nextInterceptor","currentOptions","finalOptions"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/client-interceptors.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\nconst metadata_1 = require(\"./metadata\");\nconst call_stream_1 = require(\"./call-stream\");\nconst constants_1 = require(\"./constants\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nclass InterceptorConfigurationError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'InterceptorConfigurationError';\n        Error.captureStackTrace(this, InterceptorConfigurationError);\n    }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n    constructor() {\n        this.metadata = undefined;\n        this.message = undefined;\n        this.status = undefined;\n    }\n    withOnReceiveMetadata(onReceiveMetadata) {\n        this.metadata = onReceiveMetadata;\n        return this;\n    }\n    withOnReceiveMessage(onReceiveMessage) {\n        this.message = onReceiveMessage;\n        return this;\n    }\n    withOnReceiveStatus(onReceiveStatus) {\n        this.status = onReceiveStatus;\n        return this;\n    }\n    build() {\n        return {\n            onReceiveMetadata: this.metadata,\n            onReceiveMessage: this.message,\n            onReceiveStatus: this.status,\n        };\n    }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n    constructor() {\n        this.start = undefined;\n        this.message = undefined;\n        this.halfClose = undefined;\n        this.cancel = undefined;\n    }\n    withStart(start) {\n        this.start = start;\n        return this;\n    }\n    withSendMessage(sendMessage) {\n        this.message = sendMessage;\n        return this;\n    }\n    withHalfClose(halfClose) {\n        this.halfClose = halfClose;\n        return this;\n    }\n    withCancel(cancel) {\n        this.cancel = cancel;\n        return this;\n    }\n    build() {\n        return {\n            start: this.start,\n            sendMessage: this.message,\n            halfClose: this.halfClose,\n            cancel: this.cancel,\n        };\n    }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener = {\n    onReceiveMetadata: (metadata, next) => {\n        next(metadata);\n    },\n    onReceiveMessage: (message, next) => {\n        next(message);\n    },\n    onReceiveStatus: (status, next) => {\n        next(status);\n    },\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester = {\n    start: (metadata, listener, next) => {\n        next(metadata, listener);\n    },\n    sendMessage: (message, next) => {\n        next(message);\n    },\n    halfClose: (next) => {\n        next();\n    },\n    cancel: (next) => {\n        next();\n    },\n};\nclass InterceptingCall {\n    constructor(nextCall, requester) {\n        var _a, _b, _c, _d;\n        this.nextCall = nextCall;\n        /**\n         * Indicates that metadata has been passed to the requester's start\n         * method but it has not been passed to the corresponding next callback\n         */\n        this.processingMetadata = false;\n        /**\n         * Message context for a pending message that is waiting for\n         */\n        this.pendingMessageContext = null;\n        /**\n         * Indicates that a message has been passed to the requester's sendMessage\n         * method but it has not been passed to the corresponding next callback\n         */\n        this.processingMessage = false;\n        /**\n         * Indicates that a status was received but could not be propagated because\n         * a message was still being processed.\n         */\n        this.pendingHalfClose = false;\n        if (requester) {\n            this.requester = {\n                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel,\n            };\n        }\n        else {\n            this.requester = defaultRequester;\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.requester.cancel(() => {\n            this.nextCall.cancelWithStatus(status, details);\n        });\n    }\n    getPeer() {\n        return this.nextCall.getPeer();\n    }\n    processPendingMessage() {\n        if (this.pendingMessageContext) {\n            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n            this.pendingMessageContext = null;\n            this.pendingMessage = null;\n        }\n    }\n    processPendingHalfClose() {\n        if (this.pendingHalfClose) {\n            this.nextCall.halfClose();\n        }\n    }\n    start(metadata, interceptingListener) {\n        var _a, _b, _c, _d, _e, _f;\n        const fullInterceptingListener = {\n            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : ((metadata) => { }),\n            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : ((message) => { }),\n            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : ((status) => { }),\n        };\n        this.processingMetadata = true;\n        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n            var _a, _b, _c;\n            this.processingMetadata = false;\n            let finalInterceptingListener;\n            if (call_stream_1.isInterceptingListener(listener)) {\n                finalInterceptingListener = listener;\n            }\n            else {\n                const fullListener = {\n                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus,\n                };\n                finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n            }\n            this.nextCall.start(md, finalInterceptingListener);\n            this.processPendingMessage();\n            this.processPendingHalfClose();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        this.processingMessage = true;\n        this.requester.sendMessage(message, (finalMessage) => {\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessageContext = context;\n                this.pendingMessage = message;\n            }\n            else {\n                this.nextCall.sendMessageWithContext(context, finalMessage);\n                this.processPendingHalfClose();\n            }\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    startRead() {\n        this.nextCall.startRead();\n    }\n    halfClose() {\n        this.requester.halfClose(() => {\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingHalfClose = true;\n            }\n            else {\n                this.nextCall.halfClose();\n            }\n        });\n    }\n    setCredentials(credentials) {\n        this.nextCall.setCredentials(credentials);\n    }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n    var _a, _b;\n    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n    const host = options.host;\n    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n    const propagateFlags = options.propagate_flags;\n    const credentials = options.credentials;\n    const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n    if (credentials) {\n        call.setCredentials(credentials);\n    }\n    return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall {\n    constructor(call, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    methodDefinition) {\n        this.call = call;\n        this.methodDefinition = methodDefinition;\n    }\n    cancelWithStatus(status, details) {\n        this.call.cancelWithStatus(status, details);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    setCredentials(credentials) {\n        this.call.setCredentials(credentials);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        let serialized;\n        try {\n            serialized = this.methodDefinition.requestSerialize(message);\n        }\n        catch (e) {\n            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${e.message}`);\n            return;\n        }\n        this.call.sendMessageWithContext(context, serialized);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    start(metadata, interceptingListener) {\n        let readError = null;\n        this.call.start(metadata, {\n            onReceiveMetadata: (metadata) => {\n                var _a;\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n            },\n            onReceiveMessage: (message) => {\n                var _a;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                let deserialized;\n                try {\n                    deserialized = this.methodDefinition.responseDeserialize(message);\n                }\n                catch (e) {\n                    readError = {\n                        code: constants_1.Status.INTERNAL,\n                        details: `Response message parsing error: ${e.message}`,\n                        metadata: new metadata_1.Metadata(),\n                    };\n                    this.call.cancelWithStatus(readError.code, readError.details);\n                    return;\n                }\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n            },\n            onReceiveStatus: (status) => {\n                var _a, _b;\n                if (readError) {\n                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n                }\n                else {\n                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n                }\n            },\n        });\n    }\n    startRead() {\n        this.call.startRead();\n    }\n    halfClose() {\n        this.call.halfClose();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(call, methodDefinition) {\n        super(call, methodDefinition);\n    }\n    start(metadata, listener) {\n        var _a, _b;\n        let receivedMessage = false;\n        const wrapperListener = {\n            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : ((metadata) => { }),\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage: (message) => {\n                var _a;\n                receivedMessage = true;\n                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n            },\n            onReceiveStatus: (status) => {\n                var _a, _b;\n                if (!receivedMessage) {\n                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n                }\n                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n            },\n        };\n        super.start(metadata, wrapperListener);\n        this.call.startRead();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {\n}\nfunction getBottomInterceptingCall(channel, options, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n    const call = getCall(channel, methodDefinition.path, options);\n    if (methodDefinition.responseStream) {\n        return new BaseStreamingInterceptingCall(call, methodDefinition);\n    }\n    else {\n        return new BaseUnaryInterceptingCall(call, methodDefinition);\n    }\n}\nfunction getInterceptingCall(interceptorArgs, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n    if (interceptorArgs.clientInterceptors.length > 0 &&\n        interceptorArgs.clientInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' +\n            'to the client constructor. Only one of these is allowed.');\n    }\n    if (interceptorArgs.callInterceptors.length > 0 &&\n        interceptorArgs.callInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' +\n            'options. Only one of these is allowed.');\n    }\n    let interceptors = [];\n    // Interceptors passed to the call override interceptors passed to the client constructor\n    if (interceptorArgs.callInterceptors.length > 0 ||\n        interceptorArgs.callInterceptorProviders.length > 0) {\n        interceptors = []\n            .concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider) => provider(methodDefinition)))\n            .filter((interceptor) => interceptor);\n        // Filter out falsy values when providers return nothing\n    }\n    else {\n        interceptors = []\n            .concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider) => provider(methodDefinition)))\n            .filter((interceptor) => interceptor);\n        // Filter out falsy values when providers return nothing\n    }\n    const interceptorOptions = Object.assign({}, options, {\n        method_definition: methodDefinition,\n    });\n    /* For each interceptor in the list, the nextCall function passed to it is\n     * based on the next interceptor in the list, using a nextCall function\n     * constructed with the following interceptor in the list, and so on. The\n     * initialValue, which is effectively at the end of the list, is a nextCall\n     * function that invokes getBottomInterceptingCall, the result of which\n     * handles (de)serialization and also gets the underlying call from the\n     * channel. */\n    const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\n        return (currentOptions) => nextInterceptor(currentOptions, nextCall);\n    }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n    return getCall(interceptorOptions);\n}\nexports.getInterceptingCall = getInterceptingCall;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}