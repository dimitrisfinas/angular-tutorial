{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ROOT_CONTEXT } from '@opentelemetry/api';\nimport { isListenerObject } from './util';\n/* Key name to be used to save a context reference in Zone */\nvar ZONE_CONTEXT_KEY = 'OT_ZONE_CONTEXT';\n/**\n * ZoneContextManager\n * This module provides an easy functionality for tracing action between asynchronous operations in web.\n * It was not possible with standard [StackContextManager]{@link https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-sdk-trace-web/src/StackContextManager.ts}.\n * It heavily depends on [zone.js]{@link https://www.npmjs.com/package/zone.js}.\n * It stores the information about context in zone. Each Context will have always new Zone;\n * It also supports binding a certain Span to a target that has \"addEventListener\" and \"removeEventListener\".\n * When this happens a new zone is being created and the provided Span is being assigned to this zone.\n */\nvar ZoneContextManager = /** @class */function () {\n  function ZoneContextManager() {\n    /**\n     * whether the context manager is enabled or not\n     */\n    this._enabled = false;\n    /**\n     * Helps to create a unique name for the zones - part of zone name\n     */\n    this._zoneCounter = 0;\n  }\n  /**\n   * Returns the active context from certain zone name\n   * @param activeZone\n   */\n  ZoneContextManager.prototype._activeContextFromZone = function (activeZone) {\n    return activeZone && activeZone.get(ZONE_CONTEXT_KEY) || ROOT_CONTEXT;\n  };\n  /**\n   * @param context A context (span) to be executed within target function\n   * @param target Function to be executed within the context\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  ZoneContextManager.prototype._bindFunction = function (context, target) {\n    var manager = this;\n    var contextWrapper = function () {\n      var _this = this;\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return manager.with(context, function () {\n        return target.apply(_this, args);\n      });\n    };\n    Object.defineProperty(contextWrapper, 'length', {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: target.length\n    });\n    return contextWrapper;\n  };\n  /**\n   * @param context A context (span) to be bind to target\n   * @param obj target object on which the listeners will be patched\n   */\n  ZoneContextManager.prototype._bindListener = function (context, obj) {\n    var target = obj;\n    if (target.__ot_listeners !== undefined) {\n      return obj;\n    }\n    target.__ot_listeners = {};\n    if (typeof target.addEventListener === 'function') {\n      target.addEventListener = this._patchAddEventListener(target, target.addEventListener, context);\n    }\n    if (typeof target.removeEventListener === 'function') {\n      target.removeEventListener = this._patchRemoveEventListener(target, target.removeEventListener);\n    }\n    return obj;\n  };\n  /**\n   * Creates a new unique zone name\n   */\n  ZoneContextManager.prototype._createZoneName = function () {\n    this._zoneCounter++;\n    var random = Math.random();\n    return this._zoneCounter + \"-\" + random;\n  };\n  /**\n   * Creates a new zone\n   * @param zoneName zone name\n   * @param context A context (span) to be bind with Zone\n   */\n  ZoneContextManager.prototype._createZone = function (zoneName, context) {\n    var _a;\n    return Zone.current.fork({\n      name: zoneName,\n      properties: (_a = {}, _a[ZONE_CONTEXT_KEY] = context, _a)\n    });\n  };\n  /**\n   * Returns the active zone\n   */\n  ZoneContextManager.prototype._getActiveZone = function () {\n    return Zone.current;\n  };\n  /**\n   * Patches addEventListener method\n   * @param target any target that has \"addEventListener\" method\n   * @param original reference to the patched method\n   * @param [context] context to be bind to the listener\n   */\n  ZoneContextManager.prototype._patchAddEventListener = function (target, original, context) {\n    var contextManager = this;\n    return function (event, listener, opts) {\n      if (target.__ot_listeners === undefined) {\n        target.__ot_listeners = {};\n      }\n      var listeners = target.__ot_listeners[event];\n      if (listeners === undefined) {\n        listeners = new WeakMap();\n        target.__ot_listeners[event] = listeners;\n      }\n      var patchedListener = contextManager.bind(context, listener);\n      // store a weak reference of the user listener to ours\n      listeners.set(listener, patchedListener);\n      return original.call(this, event, patchedListener, opts);\n    };\n  };\n  /**\n   * Patches removeEventListener method\n   * @param target any target that has \"removeEventListener\" method\n   * @param original reference to the patched method\n   */\n  ZoneContextManager.prototype._patchRemoveEventListener = function (target, original) {\n    return function (event, listener) {\n      if (target.__ot_listeners === undefined || target.__ot_listeners[event] === undefined) {\n        return original.call(this, event, listener);\n      }\n      var events = target.__ot_listeners[event];\n      var patchedListener = events.get(listener);\n      events.delete(listener);\n      return original.call(this, event, patchedListener || listener);\n    };\n  };\n  /**\n   * Returns the active context\n   */\n  ZoneContextManager.prototype.active = function () {\n    if (!this._enabled) {\n      return ROOT_CONTEXT;\n    }\n    var activeZone = this._getActiveZone();\n    var active = this._activeContextFromZone(activeZone);\n    if (active) {\n      return active;\n    }\n    return ROOT_CONTEXT;\n  };\n  /**\n   * Binds a the certain context or the active one to the target function and then returns the target\n   * @param context A context (span) to be bind to target\n   * @param target a function or event emitter. When target or one of its callbacks is called,\n   *  the provided context will be used as the active context for the duration of the call.\n   */\n  ZoneContextManager.prototype.bind = function (context, target) {\n    // if no specific context to propagate is given, we use the current one\n    if (context === undefined) {\n      context = this.active();\n    }\n    if (typeof target === 'function') {\n      return this._bindFunction(context, target);\n    } else if (isListenerObject(target)) {\n      this._bindListener(context, target);\n    }\n    return target;\n  };\n  /**\n   * Disable the context manager (clears all the contexts)\n   */\n  ZoneContextManager.prototype.disable = function () {\n    this._enabled = false;\n    return this;\n  };\n  /**\n   * Enables the context manager and creates a default(root) context\n   */\n  ZoneContextManager.prototype.enable = function () {\n    this._enabled = true;\n    return this;\n  };\n  /**\n   * Calls the callback function [fn] with the provided [context].\n   *     If [context] is undefined then it will use the active context.\n   *     The context will be set as active\n   * @param context A context (span) to be called with provided callback\n   * @param fn Callback function\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  ZoneContextManager.prototype.with = function (context, fn, thisArg) {\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n      args[_i - 3] = arguments[_i];\n    }\n    var zoneName = this._createZoneName();\n    var newZone = this._createZone(zoneName, context);\n    return newZone.run(fn, thisArg, args);\n  };\n  return ZoneContextManager;\n}();\nexport { ZoneContextManager };","map":{"version":3,"names":["ROOT_CONTEXT","isListenerObject","ZONE_CONTEXT_KEY","ZoneContextManager","_enabled","_zoneCounter","prototype","_activeContextFromZone","activeZone","get","_bindFunction","context","target","manager","contextWrapper","_this","args","_i","arguments","length","with","apply","Object","defineProperty","enumerable","configurable","writable","value","_bindListener","obj","__ot_listeners","undefined","addEventListener","_patchAddEventListener","removeEventListener","_patchRemoveEventListener","_createZoneName","random","Math","_createZone","zoneName","_a","Zone","current","fork","name","properties","_getActiveZone","original","contextManager","event","listener","opts","listeners","WeakMap","patchedListener","bind","set","call","events","delete","active","disable","enable","fn","thisArg","newZone","run"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@opentelemetry/context-zone-peer-dep/build/esm/ZoneContextManager.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ROOT_CONTEXT } from '@opentelemetry/api';\nimport { isListenerObject } from './util';\n/* Key name to be used to save a context reference in Zone */\nvar ZONE_CONTEXT_KEY = 'OT_ZONE_CONTEXT';\n/**\n * ZoneContextManager\n * This module provides an easy functionality for tracing action between asynchronous operations in web.\n * It was not possible with standard [StackContextManager]{@link https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-sdk-trace-web/src/StackContextManager.ts}.\n * It heavily depends on [zone.js]{@link https://www.npmjs.com/package/zone.js}.\n * It stores the information about context in zone. Each Context will have always new Zone;\n * It also supports binding a certain Span to a target that has \"addEventListener\" and \"removeEventListener\".\n * When this happens a new zone is being created and the provided Span is being assigned to this zone.\n */\nvar ZoneContextManager = /** @class */ (function () {\n    function ZoneContextManager() {\n        /**\n         * whether the context manager is enabled or not\n         */\n        this._enabled = false;\n        /**\n         * Helps to create a unique name for the zones - part of zone name\n         */\n        this._zoneCounter = 0;\n    }\n    /**\n     * Returns the active context from certain zone name\n     * @param activeZone\n     */\n    ZoneContextManager.prototype._activeContextFromZone = function (activeZone) {\n        return (activeZone && activeZone.get(ZONE_CONTEXT_KEY)) || ROOT_CONTEXT;\n    };\n    /**\n     * @param context A context (span) to be executed within target function\n     * @param target Function to be executed within the context\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    ZoneContextManager.prototype._bindFunction = function (context, target) {\n        var manager = this;\n        var contextWrapper = function () {\n            var _this = this;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return manager.with(context, function () { return target.apply(_this, args); });\n        };\n        Object.defineProperty(contextWrapper, 'length', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: target.length,\n        });\n        return contextWrapper;\n    };\n    /**\n     * @param context A context (span) to be bind to target\n     * @param obj target object on which the listeners will be patched\n     */\n    ZoneContextManager.prototype._bindListener = function (context, obj) {\n        var target = obj;\n        if (target.__ot_listeners !== undefined) {\n            return obj;\n        }\n        target.__ot_listeners = {};\n        if (typeof target.addEventListener === 'function') {\n            target.addEventListener = this._patchAddEventListener(target, target.addEventListener, context);\n        }\n        if (typeof target.removeEventListener === 'function') {\n            target.removeEventListener = this._patchRemoveEventListener(target, target.removeEventListener);\n        }\n        return obj;\n    };\n    /**\n     * Creates a new unique zone name\n     */\n    ZoneContextManager.prototype._createZoneName = function () {\n        this._zoneCounter++;\n        var random = Math.random();\n        return this._zoneCounter + \"-\" + random;\n    };\n    /**\n     * Creates a new zone\n     * @param zoneName zone name\n     * @param context A context (span) to be bind with Zone\n     */\n    ZoneContextManager.prototype._createZone = function (zoneName, context) {\n        var _a;\n        return Zone.current.fork({\n            name: zoneName,\n            properties: (_a = {},\n                _a[ZONE_CONTEXT_KEY] = context,\n                _a),\n        });\n    };\n    /**\n     * Returns the active zone\n     */\n    ZoneContextManager.prototype._getActiveZone = function () {\n        return Zone.current;\n    };\n    /**\n     * Patches addEventListener method\n     * @param target any target that has \"addEventListener\" method\n     * @param original reference to the patched method\n     * @param [context] context to be bind to the listener\n     */\n    ZoneContextManager.prototype._patchAddEventListener = function (target, original, context) {\n        var contextManager = this;\n        return function (event, listener, opts) {\n            if (target.__ot_listeners === undefined) {\n                target.__ot_listeners = {};\n            }\n            var listeners = target.__ot_listeners[event];\n            if (listeners === undefined) {\n                listeners = new WeakMap();\n                target.__ot_listeners[event] = listeners;\n            }\n            var patchedListener = contextManager.bind(context, listener);\n            // store a weak reference of the user listener to ours\n            listeners.set(listener, patchedListener);\n            return original.call(this, event, patchedListener, opts);\n        };\n    };\n    /**\n     * Patches removeEventListener method\n     * @param target any target that has \"removeEventListener\" method\n     * @param original reference to the patched method\n     */\n    ZoneContextManager.prototype._patchRemoveEventListener = function (target, original) {\n        return function (event, listener) {\n            if (target.__ot_listeners === undefined ||\n                target.__ot_listeners[event] === undefined) {\n                return original.call(this, event, listener);\n            }\n            var events = target.__ot_listeners[event];\n            var patchedListener = events.get(listener);\n            events.delete(listener);\n            return original.call(this, event, patchedListener || listener);\n        };\n    };\n    /**\n     * Returns the active context\n     */\n    ZoneContextManager.prototype.active = function () {\n        if (!this._enabled) {\n            return ROOT_CONTEXT;\n        }\n        var activeZone = this._getActiveZone();\n        var active = this._activeContextFromZone(activeZone);\n        if (active) {\n            return active;\n        }\n        return ROOT_CONTEXT;\n    };\n    /**\n     * Binds a the certain context or the active one to the target function and then returns the target\n     * @param context A context (span) to be bind to target\n     * @param target a function or event emitter. When target or one of its callbacks is called,\n     *  the provided context will be used as the active context for the duration of the call.\n     */\n    ZoneContextManager.prototype.bind = function (context, target) {\n        // if no specific context to propagate is given, we use the current one\n        if (context === undefined) {\n            context = this.active();\n        }\n        if (typeof target === 'function') {\n            return this._bindFunction(context, target);\n        }\n        else if (isListenerObject(target)) {\n            this._bindListener(context, target);\n        }\n        return target;\n    };\n    /**\n     * Disable the context manager (clears all the contexts)\n     */\n    ZoneContextManager.prototype.disable = function () {\n        this._enabled = false;\n        return this;\n    };\n    /**\n     * Enables the context manager and creates a default(root) context\n     */\n    ZoneContextManager.prototype.enable = function () {\n        this._enabled = true;\n        return this;\n    };\n    /**\n     * Calls the callback function [fn] with the provided [context].\n     *     If [context] is undefined then it will use the active context.\n     *     The context will be set as active\n     * @param context A context (span) to be called with provided callback\n     * @param fn Callback function\n     * @param thisArg optional receiver to be used for calling fn\n     * @param args optional arguments forwarded to fn\n     */\n    ZoneContextManager.prototype.with = function (context, fn, thisArg) {\n        var args = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            args[_i - 3] = arguments[_i];\n        }\n        var zoneName = this._createZoneName();\n        var newZone = this._createZone(zoneName, context);\n        return newZone.run(fn, thisArg, args);\n    };\n    return ZoneContextManager;\n}());\nexport { ZoneContextManager };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}