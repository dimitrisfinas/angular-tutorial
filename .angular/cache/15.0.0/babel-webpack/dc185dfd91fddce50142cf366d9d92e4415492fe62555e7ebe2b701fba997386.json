{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\nconst metadata_1 = require(\"./metadata\");\nconst call_stream_1 = require(\"./call-stream\");\nconst constants_1 = require(\"./constants\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nclass InterceptorConfigurationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'InterceptorConfigurationError';\n    Error.captureStackTrace(this, InterceptorConfigurationError);\n  }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n  constructor() {\n    this.metadata = undefined;\n    this.message = undefined;\n    this.status = undefined;\n  }\n  withOnReceiveMetadata(onReceiveMetadata) {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n  withOnReceiveMessage(onReceiveMessage) {\n    this.message = onReceiveMessage;\n    return this;\n  }\n  withOnReceiveStatus(onReceiveStatus) {\n    this.status = onReceiveStatus;\n    return this;\n  }\n  build() {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveStatus: this.status\n    };\n  }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n  constructor() {\n    this.start = undefined;\n    this.message = undefined;\n    this.halfClose = undefined;\n    this.cancel = undefined;\n  }\n  withStart(start) {\n    this.start = start;\n    return this;\n  }\n  withSendMessage(sendMessage) {\n    this.message = sendMessage;\n    return this;\n  }\n  withHalfClose(halfClose) {\n    this.halfClose = halfClose;\n    return this;\n  }\n  withCancel(cancel) {\n    this.cancel = cancel;\n    return this;\n  }\n  build() {\n    return {\n      start: this.start,\n      sendMessage: this.message,\n      halfClose: this.halfClose,\n      cancel: this.cancel\n    };\n  }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveStatus: (status, next) => {\n    next(status);\n  }\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester = {\n  start: (metadata, listener, next) => {\n    next(metadata, listener);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  halfClose: next => {\n    next();\n  },\n  cancel: next => {\n    next();\n  }\n};\nclass InterceptingCall {\n  constructor(nextCall, requester) {\n    var _a, _b, _c, _d;\n    this.nextCall = nextCall;\n    /**\n     * Indicates that metadata has been passed to the requester's start\n     * method but it has not been passed to the corresponding next callback\n     */\n    this.processingMetadata = false;\n    /**\n     * Message context for a pending message that is waiting for\n     */\n    this.pendingMessageContext = null;\n    /**\n     * Indicates that a message has been passed to the requester's sendMessage\n     * method but it has not been passed to the corresponding next callback\n     */\n    this.processingMessage = false;\n    /**\n     * Indicates that a status was received but could not be propagated because\n     * a message was still being processed.\n     */\n    this.pendingHalfClose = false;\n    if (requester) {\n      this.requester = {\n        start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n        sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n        halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n        cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel\n      };\n    } else {\n      this.requester = defaultRequester;\n    }\n  }\n  cancelWithStatus(status, details) {\n    this.requester.cancel(() => {\n      this.nextCall.cancelWithStatus(status, details);\n    });\n  }\n  getPeer() {\n    return this.nextCall.getPeer();\n  }\n  processPendingMessage() {\n    if (this.pendingMessageContext) {\n      this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n      this.pendingMessageContext = null;\n      this.pendingMessage = null;\n    }\n  }\n  processPendingHalfClose() {\n    if (this.pendingHalfClose) {\n      this.nextCall.halfClose();\n    }\n  }\n  start(metadata, interceptingListener) {\n    var _a, _b, _c, _d, _e, _f;\n    const fullInterceptingListener = {\n      onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : metadata => {},\n      onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : message => {},\n      onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : status => {}\n    };\n    this.processingMetadata = true;\n    this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n      var _a, _b, _c;\n      this.processingMetadata = false;\n      let finalInterceptingListener;\n      if (call_stream_1.isInterceptingListener(listener)) {\n        finalInterceptingListener = listener;\n      } else {\n        const fullListener = {\n          onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n          onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n          onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus\n        };\n        finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n      }\n      this.nextCall.start(md, finalInterceptingListener);\n      this.processPendingMessage();\n      this.processPendingHalfClose();\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context, message) {\n    this.processingMessage = true;\n    this.requester.sendMessage(message, finalMessage => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessageContext = context;\n        this.pendingMessage = message;\n      } else {\n        this.nextCall.sendMessageWithContext(context, finalMessage);\n        this.processPendingHalfClose();\n      }\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n  startRead() {\n    this.nextCall.startRead();\n  }\n  halfClose() {\n    this.requester.halfClose(() => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingHalfClose = true;\n      } else {\n        this.nextCall.halfClose();\n      }\n    });\n  }\n  setCredentials(credentials) {\n    this.nextCall.setCredentials(credentials);\n  }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n  var _a, _b;\n  const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n  const host = options.host;\n  const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n  const propagateFlags = options.propagate_flags;\n  const credentials = options.credentials;\n  const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall {\n  constructor(call,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition) {\n    this.call = call;\n    this.methodDefinition = methodDefinition;\n  }\n  cancelWithStatus(status, details) {\n    this.call.cancelWithStatus(status, details);\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  setCredentials(credentials) {\n    this.call.setCredentials(credentials);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context, message) {\n    let serialized;\n    try {\n      serialized = this.methodDefinition.requestSerialize(message);\n    } catch (e) {\n      this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${e.message}`);\n      return;\n    }\n    this.call.sendMessageWithContext(context, serialized);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n  start(metadata, interceptingListener) {\n    let readError = null;\n    this.call.start(metadata, {\n      onReceiveMetadata: metadata => {\n        var _a;\n        (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n      },\n      onReceiveMessage: message => {\n        var _a;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let deserialized;\n        try {\n          deserialized = this.methodDefinition.responseDeserialize(message);\n        } catch (e) {\n          readError = {\n            code: constants_1.Status.INTERNAL,\n            details: `Response message parsing error: ${e.message}`,\n            metadata: new metadata_1.Metadata()\n          };\n          this.call.cancelWithStatus(readError.code, readError.details);\n          return;\n        }\n        (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n        if (readError) {\n          (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n        } else {\n          (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n        }\n      }\n    });\n  }\n  startRead() {\n    this.call.startRead();\n  }\n  halfClose() {\n    this.call.halfClose();\n  }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(call, methodDefinition) {\n    super(call, methodDefinition);\n  }\n  start(metadata, listener) {\n    var _a, _b;\n    let receivedMessage = false;\n    const wrapperListener = {\n      onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : metadata => {},\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage: message => {\n        var _a;\n        receivedMessage = true;\n        (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n        if (!receivedMessage) {\n          (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n        }\n        (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n      }\n    };\n    super.start(metadata, wrapperListener);\n    this.call.startRead();\n  }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {}\nfunction getBottomInterceptingCall(channel, options,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n  const call = getCall(channel, methodDefinition.path, options);\n  if (methodDefinition.responseStream) {\n    return new BaseStreamingInterceptingCall(call, methodDefinition);\n  } else {\n    return new BaseUnaryInterceptingCall(call, methodDefinition);\n  }\n}\nfunction getInterceptingCall(interceptorArgs,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n  if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n  }\n  if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' + 'options. Only one of these is allowed.');\n  }\n  let interceptors = [];\n  // Interceptors passed to the call override interceptors passed to the client constructor\n  if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {\n    interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor);\n    // Filter out falsy values when providers return nothing\n  } else {\n    interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor);\n    // Filter out falsy values when providers return nothing\n  }\n\n  const interceptorOptions = Object.assign({}, options, {\n    method_definition: methodDefinition\n  });\n  /* For each interceptor in the list, the nextCall function passed to it is\n   * based on the next interceptor in the list, using a nextCall function\n   * constructed with the following interceptor in the list, and so on. The\n   * initialValue, which is effectively at the end of the list, is a nextCall\n   * function that invokes getBottomInterceptingCall, the result of which\n   * handles (de)serialization and also gets the underlying call from the\n   * channel. */\n  const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\n    return currentOptions => nextInterceptor(currentOptions, nextCall);\n  }, finalOptions => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n  return getCall(interceptorOptions);\n}\nexports.getInterceptingCall = getInterceptingCall;\n//# sourceMappingURL=client-interceptors.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}