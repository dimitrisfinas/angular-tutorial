{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// https://tc39.es/proposal-regex-escaping\n// escape ^ $ \\ .  + ? ( ) [ ] { } |\n// do not need to escape * as we interpret it as wildcard\nvar ESCAPE = /[\\^$\\\\.+?()[\\]{}|]/g;\n/**\n * Wildcard pattern predicate, supports patterns like `*`, `foo*`, `*bar`.\n */\nvar PatternPredicate = /** @class */function () {\n  function PatternPredicate(pattern) {\n    if (pattern === '*') {\n      this._matchAll = true;\n      this._regexp = /.*/;\n    } else {\n      this._matchAll = false;\n      this._regexp = new RegExp(PatternPredicate.escapePattern(pattern));\n    }\n  }\n  PatternPredicate.prototype.match = function (str) {\n    if (this._matchAll) {\n      return true;\n    }\n    return this._regexp.test(str);\n  };\n  PatternPredicate.escapePattern = function (pattern) {\n    return \"^\" + pattern.replace(ESCAPE, '\\\\$&').replace('*', '.*') + \"$\";\n  };\n  PatternPredicate.hasWildcard = function (pattern) {\n    return pattern.includes('*');\n  };\n  return PatternPredicate;\n}();\nexport { PatternPredicate };\nvar ExactPredicate = /** @class */function () {\n  function ExactPredicate(pattern) {\n    this._matchAll = pattern === undefined;\n    this._pattern = pattern;\n  }\n  ExactPredicate.prototype.match = function (str) {\n    if (this._matchAll) {\n      return true;\n    }\n    if (str === this._pattern) {\n      return true;\n    }\n    return false;\n  };\n  return ExactPredicate;\n}();\nexport { ExactPredicate };","map":{"version":3,"names":["ESCAPE","PatternPredicate","pattern","_matchAll","_regexp","RegExp","escapePattern","prototype","match","str","test","replace","hasWildcard","includes","ExactPredicate","undefined","_pattern"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@opentelemetry/sdk-metrics/build/esm/view/Predicate.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// https://tc39.es/proposal-regex-escaping\n// escape ^ $ \\ .  + ? ( ) [ ] { } |\n// do not need to escape * as we interpret it as wildcard\nvar ESCAPE = /[\\^$\\\\.+?()[\\]{}|]/g;\n/**\n * Wildcard pattern predicate, supports patterns like `*`, `foo*`, `*bar`.\n */\nvar PatternPredicate = /** @class */ (function () {\n    function PatternPredicate(pattern) {\n        if (pattern === '*') {\n            this._matchAll = true;\n            this._regexp = /.*/;\n        }\n        else {\n            this._matchAll = false;\n            this._regexp = new RegExp(PatternPredicate.escapePattern(pattern));\n        }\n    }\n    PatternPredicate.prototype.match = function (str) {\n        if (this._matchAll) {\n            return true;\n        }\n        return this._regexp.test(str);\n    };\n    PatternPredicate.escapePattern = function (pattern) {\n        return \"^\" + pattern.replace(ESCAPE, '\\\\$&').replace('*', '.*') + \"$\";\n    };\n    PatternPredicate.hasWildcard = function (pattern) {\n        return pattern.includes('*');\n    };\n    return PatternPredicate;\n}());\nexport { PatternPredicate };\nvar ExactPredicate = /** @class */ (function () {\n    function ExactPredicate(pattern) {\n        this._matchAll = pattern === undefined;\n        this._pattern = pattern;\n    }\n    ExactPredicate.prototype.match = function (str) {\n        if (this._matchAll) {\n            return true;\n        }\n        if (str === this._pattern) {\n            return true;\n        }\n        return false;\n    };\n    return ExactPredicate;\n}());\nexport { ExactPredicate };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,MAAM,GAAG,qBAAqB;AAClC;AACA;AACA;AACA,IAAIC,gBAAgB,GAAG,aAAe,YAAY;EAC9C,SAASA,gBAAgB,CAACC,OAAO,EAAE;IAC/B,IAAIA,OAAO,KAAK,GAAG,EAAE;MACjB,IAAI,CAACC,SAAS,GAAG,IAAI;MACrB,IAAI,CAACC,OAAO,GAAG,IAAI;IACvB,CAAC,MACI;MACD,IAAI,CAACD,SAAS,GAAG,KAAK;MACtB,IAAI,CAACC,OAAO,GAAG,IAAIC,MAAM,CAACJ,gBAAgB,CAACK,aAAa,CAACJ,OAAO,CAAC,CAAC;IACtE;EACJ;EACAD,gBAAgB,CAACM,SAAS,CAACC,KAAK,GAAG,UAAUC,GAAG,EAAE;IAC9C,IAAI,IAAI,CAACN,SAAS,EAAE;MAChB,OAAO,IAAI;IACf;IACA,OAAO,IAAI,CAACC,OAAO,CAACM,IAAI,CAACD,GAAG,CAAC;EACjC,CAAC;EACDR,gBAAgB,CAACK,aAAa,GAAG,UAAUJ,OAAO,EAAE;IAChD,OAAO,GAAG,GAAGA,OAAO,CAACS,OAAO,CAACX,MAAM,EAAE,MAAM,CAAC,CAACW,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG;EACzE,CAAC;EACDV,gBAAgB,CAACW,WAAW,GAAG,UAAUV,OAAO,EAAE;IAC9C,OAAOA,OAAO,CAACW,QAAQ,CAAC,GAAG,CAAC;EAChC,CAAC;EACD,OAAOZ,gBAAgB;AAC3B,CAAC,EAAG;AACJ,SAASA,gBAAgB;AACzB,IAAIa,cAAc,GAAG,aAAe,YAAY;EAC5C,SAASA,cAAc,CAACZ,OAAO,EAAE;IAC7B,IAAI,CAACC,SAAS,GAAGD,OAAO,KAAKa,SAAS;IACtC,IAAI,CAACC,QAAQ,GAAGd,OAAO;EAC3B;EACAY,cAAc,CAACP,SAAS,CAACC,KAAK,GAAG,UAAUC,GAAG,EAAE;IAC5C,IAAI,IAAI,CAACN,SAAS,EAAE;MAChB,OAAO,IAAI;IACf;IACA,IAAIM,GAAG,KAAK,IAAI,CAACO,QAAQ,EAAE;MACvB,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB,CAAC;EACD,OAAOF,cAAc;AACzB,CAAC,EAAG;AACJ,SAASA,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}