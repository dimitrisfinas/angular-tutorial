{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { AggregatorKind } from './types';\nimport { DataPointType } from '../export/MetricData';\nimport { InstrumentType } from '../InstrumentDescriptor';\nfunction createNewEmptyCheckpoint(boundaries) {\n  var counts = boundaries.map(function () {\n    return 0;\n  });\n  counts.push(0);\n  return {\n    buckets: {\n      boundaries: boundaries,\n      counts: counts\n    },\n    sum: 0,\n    count: 0,\n    hasMinMax: false,\n    min: Infinity,\n    max: -Infinity\n  };\n}\nvar HistogramAccumulation = /** @class */function () {\n  function HistogramAccumulation(startTime, _boundaries, _recordMinMax, _current) {\n    if (_recordMinMax === void 0) {\n      _recordMinMax = true;\n    }\n    if (_current === void 0) {\n      _current = createNewEmptyCheckpoint(_boundaries);\n    }\n    this.startTime = startTime;\n    this._boundaries = _boundaries;\n    this._recordMinMax = _recordMinMax;\n    this._current = _current;\n  }\n  HistogramAccumulation.prototype.record = function (value) {\n    this._current.count += 1;\n    this._current.sum += value;\n    if (this._recordMinMax) {\n      this._current.min = Math.min(value, this._current.min);\n      this._current.max = Math.max(value, this._current.max);\n      this._current.hasMinMax = true;\n    }\n    for (var i = 0; i < this._boundaries.length; i++) {\n      if (value < this._boundaries[i]) {\n        this._current.buckets.counts[i] += 1;\n        return;\n      }\n    }\n    // value is above all observed boundaries\n    this._current.buckets.counts[this._boundaries.length] += 1;\n  };\n  HistogramAccumulation.prototype.setStartTime = function (startTime) {\n    this.startTime = startTime;\n  };\n  HistogramAccumulation.prototype.toPointValue = function () {\n    return this._current;\n  };\n  return HistogramAccumulation;\n}();\nexport { HistogramAccumulation };\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\nvar HistogramAggregator = /** @class */function () {\n  /**\n   * @param _boundaries upper bounds of recorded values.\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  function HistogramAggregator(_boundaries, _recordMinMax) {\n    this._boundaries = _boundaries;\n    this._recordMinMax = _recordMinMax;\n    this.kind = AggregatorKind.HISTOGRAM;\n  }\n  HistogramAggregator.prototype.createAccumulation = function (startTime) {\n    return new HistogramAccumulation(startTime, this._boundaries, this._recordMinMax);\n  };\n  /**\n   * Return the result of the merge of two histogram accumulations. As long as one Aggregator\n   * instance produces all Accumulations with constant boundaries we don't need to worry about\n   * merging accumulations with different boundaries.\n   */\n  HistogramAggregator.prototype.merge = function (previous, delta) {\n    var previousValue = previous.toPointValue();\n    var deltaValue = delta.toPointValue();\n    var previousCounts = previousValue.buckets.counts;\n    var deltaCounts = deltaValue.buckets.counts;\n    var mergedCounts = new Array(previousCounts.length);\n    for (var idx = 0; idx < previousCounts.length; idx++) {\n      mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];\n    }\n    var min = Infinity;\n    var max = -Infinity;\n    if (this._recordMinMax) {\n      if (previousValue.hasMinMax && deltaValue.hasMinMax) {\n        min = Math.min(previousValue.min, deltaValue.min);\n        max = Math.max(previousValue.max, deltaValue.max);\n      } else if (previousValue.hasMinMax) {\n        min = previousValue.min;\n        max = previousValue.max;\n      } else if (deltaValue.hasMinMax) {\n        min = deltaValue.min;\n        max = deltaValue.max;\n      }\n    }\n    return new HistogramAccumulation(previous.startTime, previousValue.buckets.boundaries, this._recordMinMax, {\n      buckets: {\n        boundaries: previousValue.buckets.boundaries,\n        counts: mergedCounts\n      },\n      count: previousValue.count + deltaValue.count,\n      sum: previousValue.sum + deltaValue.sum,\n      hasMinMax: this._recordMinMax && (previousValue.hasMinMax || deltaValue.hasMinMax),\n      min: min,\n      max: max\n    });\n  };\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  HistogramAggregator.prototype.diff = function (previous, current) {\n    var previousValue = previous.toPointValue();\n    var currentValue = current.toPointValue();\n    var previousCounts = previousValue.buckets.counts;\n    var currentCounts = currentValue.buckets.counts;\n    var diffedCounts = new Array(previousCounts.length);\n    for (var idx = 0; idx < previousCounts.length; idx++) {\n      diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];\n    }\n    return new HistogramAccumulation(current.startTime, previousValue.buckets.boundaries, this._recordMinMax, {\n      buckets: {\n        boundaries: previousValue.buckets.boundaries,\n        counts: diffedCounts\n      },\n      count: currentValue.count - previousValue.count,\n      sum: currentValue.sum - previousValue.sum,\n      hasMinMax: false,\n      min: Infinity,\n      max: -Infinity\n    });\n  };\n  HistogramAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor: descriptor,\n      aggregationTemporality: aggregationTemporality,\n      dataPointType: DataPointType.HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(function (_a) {\n        var _b = __read(_a, 2),\n          attributes = _b[0],\n          accumulation = _b[1];\n        var pointValue = accumulation.toPointValue();\n        // determine if instrument allows negative values.\n        var allowsNegativeValues = descriptor.type === InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n        return {\n          attributes: attributes,\n          startTime: accumulation.startTime,\n          endTime: endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            buckets: pointValue.buckets,\n            count: pointValue.count\n          }\n        };\n      })\n    };\n  };\n  return HistogramAggregator;\n}();\nexport { HistogramAggregator };","map":{"version":3,"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","AggregatorKind","DataPointType","InstrumentType","createNewEmptyCheckpoint","boundaries","counts","map","buckets","sum","count","hasMinMax","min","Infinity","max","HistogramAccumulation","startTime","_boundaries","_recordMinMax","_current","prototype","record","Math","length","setStartTime","toPointValue","HistogramAggregator","kind","HISTOGRAM","createAccumulation","merge","previous","delta","previousValue","deltaValue","previousCounts","deltaCounts","mergedCounts","Array","idx","diff","current","currentValue","currentCounts","diffedCounts","toMetricData","descriptor","aggregationTemporality","accumulationByAttributes","endTime","dataPointType","dataPoints","_a","_b","attributes","accumulation","pointValue","allowsNegativeValues","type","UP_DOWN_COUNTER","OBSERVABLE_GAUGE","OBSERVABLE_UP_DOWN_COUNTER","undefined"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@opentelemetry/sdk-metrics/build/esm/aggregator/Histogram.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { AggregatorKind } from './types';\nimport { DataPointType } from '../export/MetricData';\nimport { InstrumentType } from '../InstrumentDescriptor';\nfunction createNewEmptyCheckpoint(boundaries) {\n    var counts = boundaries.map(function () { return 0; });\n    counts.push(0);\n    return {\n        buckets: {\n            boundaries: boundaries,\n            counts: counts,\n        },\n        sum: 0,\n        count: 0,\n        hasMinMax: false,\n        min: Infinity,\n        max: -Infinity\n    };\n}\nvar HistogramAccumulation = /** @class */ (function () {\n    function HistogramAccumulation(startTime, _boundaries, _recordMinMax, _current) {\n        if (_recordMinMax === void 0) { _recordMinMax = true; }\n        if (_current === void 0) { _current = createNewEmptyCheckpoint(_boundaries); }\n        this.startTime = startTime;\n        this._boundaries = _boundaries;\n        this._recordMinMax = _recordMinMax;\n        this._current = _current;\n    }\n    HistogramAccumulation.prototype.record = function (value) {\n        this._current.count += 1;\n        this._current.sum += value;\n        if (this._recordMinMax) {\n            this._current.min = Math.min(value, this._current.min);\n            this._current.max = Math.max(value, this._current.max);\n            this._current.hasMinMax = true;\n        }\n        for (var i = 0; i < this._boundaries.length; i++) {\n            if (value < this._boundaries[i]) {\n                this._current.buckets.counts[i] += 1;\n                return;\n            }\n        }\n        // value is above all observed boundaries\n        this._current.buckets.counts[this._boundaries.length] += 1;\n    };\n    HistogramAccumulation.prototype.setStartTime = function (startTime) {\n        this.startTime = startTime;\n    };\n    HistogramAccumulation.prototype.toPointValue = function () {\n        return this._current;\n    };\n    return HistogramAccumulation;\n}());\nexport { HistogramAccumulation };\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\nvar HistogramAggregator = /** @class */ (function () {\n    /**\n     * @param _boundaries upper bounds of recorded values.\n     * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n     */\n    function HistogramAggregator(_boundaries, _recordMinMax) {\n        this._boundaries = _boundaries;\n        this._recordMinMax = _recordMinMax;\n        this.kind = AggregatorKind.HISTOGRAM;\n    }\n    HistogramAggregator.prototype.createAccumulation = function (startTime) {\n        return new HistogramAccumulation(startTime, this._boundaries, this._recordMinMax);\n    };\n    /**\n     * Return the result of the merge of two histogram accumulations. As long as one Aggregator\n     * instance produces all Accumulations with constant boundaries we don't need to worry about\n     * merging accumulations with different boundaries.\n     */\n    HistogramAggregator.prototype.merge = function (previous, delta) {\n        var previousValue = previous.toPointValue();\n        var deltaValue = delta.toPointValue();\n        var previousCounts = previousValue.buckets.counts;\n        var deltaCounts = deltaValue.buckets.counts;\n        var mergedCounts = new Array(previousCounts.length);\n        for (var idx = 0; idx < previousCounts.length; idx++) {\n            mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];\n        }\n        var min = Infinity;\n        var max = -Infinity;\n        if (this._recordMinMax) {\n            if (previousValue.hasMinMax && deltaValue.hasMinMax) {\n                min = Math.min(previousValue.min, deltaValue.min);\n                max = Math.max(previousValue.max, deltaValue.max);\n            }\n            else if (previousValue.hasMinMax) {\n                min = previousValue.min;\n                max = previousValue.max;\n            }\n            else if (deltaValue.hasMinMax) {\n                min = deltaValue.min;\n                max = deltaValue.max;\n            }\n        }\n        return new HistogramAccumulation(previous.startTime, previousValue.buckets.boundaries, this._recordMinMax, {\n            buckets: {\n                boundaries: previousValue.buckets.boundaries,\n                counts: mergedCounts,\n            },\n            count: previousValue.count + deltaValue.count,\n            sum: previousValue.sum + deltaValue.sum,\n            hasMinMax: this._recordMinMax && (previousValue.hasMinMax || deltaValue.hasMinMax),\n            min: min,\n            max: max\n        });\n    };\n    /**\n     * Returns a new DELTA aggregation by comparing two cumulative measurements.\n     */\n    HistogramAggregator.prototype.diff = function (previous, current) {\n        var previousValue = previous.toPointValue();\n        var currentValue = current.toPointValue();\n        var previousCounts = previousValue.buckets.counts;\n        var currentCounts = currentValue.buckets.counts;\n        var diffedCounts = new Array(previousCounts.length);\n        for (var idx = 0; idx < previousCounts.length; idx++) {\n            diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];\n        }\n        return new HistogramAccumulation(current.startTime, previousValue.buckets.boundaries, this._recordMinMax, {\n            buckets: {\n                boundaries: previousValue.buckets.boundaries,\n                counts: diffedCounts,\n            },\n            count: currentValue.count - previousValue.count,\n            sum: currentValue.sum - previousValue.sum,\n            hasMinMax: false,\n            min: Infinity,\n            max: -Infinity\n        });\n    };\n    HistogramAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n        return {\n            descriptor: descriptor,\n            aggregationTemporality: aggregationTemporality,\n            dataPointType: DataPointType.HISTOGRAM,\n            dataPoints: accumulationByAttributes.map(function (_a) {\n                var _b = __read(_a, 2), attributes = _b[0], accumulation = _b[1];\n                var pointValue = accumulation.toPointValue();\n                // determine if instrument allows negative values.\n                var allowsNegativeValues = (descriptor.type === InstrumentType.UP_DOWN_COUNTER) ||\n                    (descriptor.type === InstrumentType.OBSERVABLE_GAUGE) ||\n                    (descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER);\n                return {\n                    attributes: attributes,\n                    startTime: accumulation.startTime,\n                    endTime: endTime,\n                    value: {\n                        min: pointValue.hasMinMax ? pointValue.min : undefined,\n                        max: pointValue.hasMinMax ? pointValue.max : undefined,\n                        sum: !allowsNegativeValues ? pointValue.sum : undefined,\n                        buckets: pointValue.buckets,\n                        count: pointValue.count\n                    },\n                };\n            })\n        };\n    };\n    return HistogramAggregator;\n}());\nexport { HistogramAggregator };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}