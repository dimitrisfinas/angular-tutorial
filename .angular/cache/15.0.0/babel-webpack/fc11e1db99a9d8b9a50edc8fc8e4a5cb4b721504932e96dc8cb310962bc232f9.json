{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _asyncToGenerator = require(\"/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallCredentials = void 0;\nconst metadata_1 = require(\"./metadata\");\nfunction isCurrentOauth2Client(client) {\n  return 'getRequestHeaders' in client && typeof client.getRequestHeaders === 'function';\n}\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */\nclass CallCredentials {\n  /**\n   * Creates a new CallCredentials object from a given function that generates\n   * Metadata objects.\n   * @param metadataGenerator A function that accepts a set of options, and\n   * generates a Metadata object based on these options, which is passed back\n   * to the caller via a supplied (err, metadata) callback.\n   */\n  static createFromMetadataGenerator(metadataGenerator) {\n    return new SingleCallCredentials(metadataGenerator);\n  }\n  /**\n   * Create a gRPC credential from a Google credential object.\n   * @param googleCredentials The authentication client to use.\n   * @return The resulting CallCredentials object.\n   */\n  static createFromGoogleCredential(googleCredentials) {\n    return CallCredentials.createFromMetadataGenerator((options, callback) => {\n      let getHeaders;\n      if (isCurrentOauth2Client(googleCredentials)) {\n        getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n      } else {\n        getHeaders = new Promise((resolve, reject) => {\n          googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {\n            if (err) {\n              reject(err);\n              return;\n            }\n            resolve(headers);\n          });\n        });\n      }\n      getHeaders.then(headers => {\n        const metadata = new metadata_1.Metadata();\n        for (const key of Object.keys(headers)) {\n          metadata.add(key, headers[key]);\n        }\n        callback(null, metadata);\n      }, err => {\n        callback(err);\n      });\n    });\n  }\n  static createEmpty() {\n    return new EmptyCallCredentials();\n  }\n}\nexports.CallCredentials = CallCredentials;\nclass ComposedCallCredentials extends CallCredentials {\n  constructor(creds) {\n    super();\n    this.creds = creds;\n  }\n  generateMetadata(options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const base = new metadata_1.Metadata();\n      const generated = yield Promise.all(_this.creds.map(cred => cred.generateMetadata(options)));\n      for (const gen of generated) {\n        base.merge(gen);\n      }\n      return base;\n    })();\n  }\n  compose(other) {\n    return new ComposedCallCredentials(this.creds.concat([other]));\n  }\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof ComposedCallCredentials) {\n      return this.creds.every((value, index) => value._equals(other.creds[index]));\n    } else {\n      return false;\n    }\n  }\n}\nclass SingleCallCredentials extends CallCredentials {\n  constructor(metadataGenerator) {\n    super();\n    this.metadataGenerator = metadataGenerator;\n  }\n  generateMetadata(options) {\n    return new Promise((resolve, reject) => {\n      this.metadataGenerator(options, (err, metadata) => {\n        if (metadata !== undefined) {\n          resolve(metadata);\n        } else {\n          reject(err);\n        }\n      });\n    });\n  }\n  compose(other) {\n    return new ComposedCallCredentials([this, other]);\n  }\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof SingleCallCredentials) {\n      return this.metadataGenerator === other.metadataGenerator;\n    } else {\n      return false;\n    }\n  }\n}\nclass EmptyCallCredentials extends CallCredentials {\n  generateMetadata(options) {\n    return Promise.resolve(new metadata_1.Metadata());\n  }\n  compose(other) {\n    return other;\n  }\n  _equals(other) {\n    return other instanceof EmptyCallCredentials;\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","CallCredentials","metadata_1","require","isCurrentOauth2Client","client","getRequestHeaders","createFromMetadataGenerator","metadataGenerator","SingleCallCredentials","createFromGoogleCredential","googleCredentials","options","callback","getHeaders","service_url","Promise","resolve","reject","getRequestMetadata","err","headers","then","metadata","Metadata","key","keys","add","createEmpty","EmptyCallCredentials","ComposedCallCredentials","constructor","creds","generateMetadata","base","generated","all","map","cred","gen","merge","compose","other","concat","_equals","every","index","undefined"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/call-credentials.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CallCredentials = void 0;\nconst metadata_1 = require(\"./metadata\");\nfunction isCurrentOauth2Client(client) {\n    return ('getRequestHeaders' in client &&\n        typeof client.getRequestHeaders === 'function');\n}\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */\nclass CallCredentials {\n    /**\n     * Creates a new CallCredentials object from a given function that generates\n     * Metadata objects.\n     * @param metadataGenerator A function that accepts a set of options, and\n     * generates a Metadata object based on these options, which is passed back\n     * to the caller via a supplied (err, metadata) callback.\n     */\n    static createFromMetadataGenerator(metadataGenerator) {\n        return new SingleCallCredentials(metadataGenerator);\n    }\n    /**\n     * Create a gRPC credential from a Google credential object.\n     * @param googleCredentials The authentication client to use.\n     * @return The resulting CallCredentials object.\n     */\n    static createFromGoogleCredential(googleCredentials) {\n        return CallCredentials.createFromMetadataGenerator((options, callback) => {\n            let getHeaders;\n            if (isCurrentOauth2Client(googleCredentials)) {\n                getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n            }\n            else {\n                getHeaders = new Promise((resolve, reject) => {\n                    googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {\n                        if (err) {\n                            reject(err);\n                            return;\n                        }\n                        resolve(headers);\n                    });\n                });\n            }\n            getHeaders.then((headers) => {\n                const metadata = new metadata_1.Metadata();\n                for (const key of Object.keys(headers)) {\n                    metadata.add(key, headers[key]);\n                }\n                callback(null, metadata);\n            }, (err) => {\n                callback(err);\n            });\n        });\n    }\n    static createEmpty() {\n        return new EmptyCallCredentials();\n    }\n}\nexports.CallCredentials = CallCredentials;\nclass ComposedCallCredentials extends CallCredentials {\n    constructor(creds) {\n        super();\n        this.creds = creds;\n    }\n    async generateMetadata(options) {\n        const base = new metadata_1.Metadata();\n        const generated = await Promise.all(this.creds.map((cred) => cred.generateMetadata(options)));\n        for (const gen of generated) {\n            base.merge(gen);\n        }\n        return base;\n    }\n    compose(other) {\n        return new ComposedCallCredentials(this.creds.concat([other]));\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedCallCredentials) {\n            return this.creds.every((value, index) => value._equals(other.creds[index]));\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass SingleCallCredentials extends CallCredentials {\n    constructor(metadataGenerator) {\n        super();\n        this.metadataGenerator = metadataGenerator;\n    }\n    generateMetadata(options) {\n        return new Promise((resolve, reject) => {\n            this.metadataGenerator(options, (err, metadata) => {\n                if (metadata !== undefined) {\n                    resolve(metadata);\n                }\n                else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    compose(other) {\n        return new ComposedCallCredentials([this, other]);\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SingleCallCredentials) {\n            return this.metadataGenerator === other.metadataGenerator;\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass EmptyCallCredentials extends CallCredentials {\n    generateMetadata(options) {\n        return Promise.resolve(new metadata_1.Metadata());\n    }\n    compose(other) {\n        return other;\n    }\n    _equals(other) {\n        return other instanceof EmptyCallCredentials;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}