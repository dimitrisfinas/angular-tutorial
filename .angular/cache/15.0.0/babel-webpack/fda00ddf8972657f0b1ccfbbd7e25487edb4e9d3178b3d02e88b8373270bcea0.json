{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelImplementation = void 0;\nconst call_stream_1 = require(\"./call-stream\");\nconst channel_credentials_1 = require(\"./channel-credentials\");\nconst resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\nconst subchannel_pool_1 = require(\"./subchannel-pool\");\nconst picker_1 = require(\"./picker\");\nconst constants_1 = require(\"./constants\");\nconst filter_stack_1 = require(\"./filter-stack\");\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\nconst deadline_filter_1 = require(\"./deadline-filter\");\nconst compression_filter_1 = require(\"./compression-filter\");\nconst resolver_1 = require(\"./resolver\");\nconst logging_1 = require(\"./logging\");\nconst max_message_size_filter_1 = require(\"./max-message-size-filter\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst channelz_1 = require(\"./channelz\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\nlet nextCallNumber = 0;\nfunction getNewCallNumber() {\n  const callNumber = nextCallNumber;\n  nextCallNumber += 1;\n  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n    nextCallNumber = 0;\n  }\n  return callNumber;\n}\nconst INAPPROPRIATE_CONTROL_PLANE_CODES = [constants_1.Status.OK, constants_1.Status.INVALID_ARGUMENT, constants_1.Status.NOT_FOUND, constants_1.Status.ALREADY_EXISTS, constants_1.Status.FAILED_PRECONDITION, constants_1.Status.ABORTED, constants_1.Status.OUT_OF_RANGE, constants_1.Status.DATA_LOSS];\nfunction restrictControlPlaneStatusCode(code, details) {\n  if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\n    return {\n      code: constants_1.Status.INTERNAL,\n      details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`\n    };\n  } else {\n    return {\n      code,\n      details\n    };\n  }\n}\nclass ChannelImplementation {\n  constructor(target, credentials, options) {\n    var _a, _b, _c, _d;\n    this.credentials = credentials;\n    this.options = options;\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    this.currentPicker = new picker_1.UnavailablePicker();\n    /**\n     * Calls queued up to get a call config. Should only be populated before the\n     * first time the resolver returns a result, which includes the ConfigSelector.\n     */\n    this.configSelectionQueue = [];\n    this.pickQueue = [];\n    this.connectivityStateWatchers = [];\n    this.configSelector = null;\n    /**\n     * This is the error from the name resolver if it failed most recently. It\n     * is only used to end calls that start while there is no config selector\n     * and the name resolver is in backoff, so it should be nulled if\n     * configSelector becomes set or the channel state becomes anything other\n     * than TRANSIENT_FAILURE.\n     */\n    this.currentResolutionError = null;\n    // Channelz info\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n    if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n      throw new TypeError('Channel credentials must be a ChannelCredentials object');\n    }\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n    this.originalTarget = target;\n    const originalTargetUri = uri_parser_1.parseUri(target);\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n    const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);\n    if (defaultSchemeMapResult === null) {\n      throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n    }\n    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.channelzRef = channelz_1.registerChannelzChannel(target, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n    }\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'];\n    } else {\n      this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);\n    }\n    const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n    this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\n    const channelControlHelper = {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n        }\n        return subchannel;\n      },\n      updateState: (connectivityState, picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        this.callRefTimerUnref();\n        for (const {\n          callStream,\n          callMetadata,\n          callConfig,\n          dynamicFilters\n        } of queueCopy) {\n          this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n        }\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error('Resolving load balancer should never call requestReresolution');\n      },\n      addChannelzChild: child => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(child);\n        }\n      },\n      removeChannelzChild: child => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.unrefChild(child);\n        }\n      }\n    };\n    this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, configSelector => {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\n      }\n      this.configSelector = configSelector;\n      this.currentResolutionError = null;\n      /* We process the queue asynchronously to ensure that the corresponding\n       * load balancer update has completed. */\n      process.nextTick(() => {\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        this.callRefTimerUnref();\n        for (const {\n          callStream,\n          callMetadata\n        } of localQueue) {\n          this.tryGetConfig(callStream, callMetadata);\n        }\n        this.configSelectionQueue = [];\n      });\n    }, status => {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details \"' + status.details + '\"');\n      }\n      if (this.configSelectionQueue.length > 0) {\n        this.trace('Name resolution failed with calls queued for config selection');\n      }\n      if (this.configSelector === null) {\n        this.currentResolutionError = Object.assign(Object.assign({}, restrictControlPlaneStatusCode(status.code, status.details)), {\n          metadata: status.metadata\n        });\n      }\n      const localQueue = this.configSelectionQueue;\n      this.configSelectionQueue = [];\n      this.callRefTimerUnref();\n      for (const {\n        callStream,\n        callMetadata\n      } of localQueue) {\n        if (callMetadata.getOptions().waitForReady) {\n          this.callRefTimerRef();\n          this.configSelectionQueue.push({\n            callStream,\n            callMetadata\n          });\n        } else {\n          callStream.cancelWithStatus(status.code, status.details);\n        }\n      }\n    });\n    this.filterStackFactory = new filter_stack_1.FilterStackFactory([new call_credentials_filter_1.CallCredentialsFilterFactory(this), new deadline_filter_1.DeadlineFilterFactory(this), new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options), new compression_filter_1.CompressionFilterFactory(this, this.options)]);\n    this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));\n    const error = new Error();\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' + this.channelzRef.id + ') ' + 'Channel constructed \\n' + ((_d = error.stack) === null || _d === void 0 ? void 0 : _d.substring(error.stack.indexOf('\\n') + 1)));\n  }\n  getChannelzInfo() {\n    return {\n      target: this.originalTarget,\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists()\n    };\n  }\n  trace(text, verbosityOverride) {\n    logging_1.trace(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + uri_parser_1.uriToString(this.target) + ' ' + text);\n  }\n  callRefTimerRef() {\n    var _a, _b, _c, _d;\n    // If the hasRef function does not exist, always run the code\n    if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n      this.trace('callRefTimer.ref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n  }\n  callRefTimerUnref() {\n    var _a, _b;\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n      this.trace('callRefTimer.unref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n  pushPick(callStream, callMetadata, callConfig, dynamicFilters) {\n    this.pickQueue.push({\n      callStream,\n      callMetadata,\n      callConfig,\n      dynamicFilters\n    });\n    this.callRefTimerRef();\n  }\n  /**\n   * Check the picker output for the given call and corresponding metadata,\n   * and take any relevant actions. Should not be called while iterating\n   * over pickQueue.\n   * @param callStream\n   * @param callMetadata\n   */\n  tryPick(callStream, callMetadata, callConfig, dynamicFilters) {\n    var _a, _b;\n    const pickResult = this.currentPicker.pick({\n      metadata: callMetadata,\n      extraPickInfo: callConfig.pickInformation\n    });\n    const subchannelString = pickResult.subchannel ? '(' + pickResult.subchannel.getChannelzRef().id + ') ' + pickResult.subchannel.getAddress() : '' + pickResult.subchannel;\n    this.trace('Pick result for call [' + callStream.getCallNumber() + ']: ' + picker_1.PickResultType[pickResult.pickResultType] + ' subchannel: ' + subchannelString + ' status: ' + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) + ' ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n    switch (pickResult.pickResultType) {\n      case picker_1.PickResultType.COMPLETE:\n        if (pickResult.subchannel === null) {\n          callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy');\n          // End the call with an error\n        } else {\n          /* If the subchannel is not in the READY state, that indicates a bug\n           * somewhere in the load balancer or picker. So, we log an error and\n           * queue the pick to be tried again later. */\n          if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n            logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' + subchannelString + ' has state ' + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n            this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n            break;\n          }\n          /* We need to clone the callMetadata here because the transparent\n           * retry code in the promise resolution handler use the same\n           * callMetadata object, so it needs to stay unmodified */\n          callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then(finalMetadata => {\n            var _a, _b, _c;\n            const subchannelState = pickResult.subchannel.getConnectivityState();\n            if (subchannelState === connectivity_state_1.ConnectivityState.READY) {\n              try {\n                const pickExtraFilters = pickResult.extraFilterFactories.map(factory => factory.createFilter(callStream));\n                (_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getRealSubchannel().startCallStream(finalMetadata, callStream, [...dynamicFilters, ...pickExtraFilters]);\n                /* If we reach this point, the call stream has started\n                 * successfully */\n                (_b = callConfig.onCommitted) === null || _b === void 0 ? void 0 : _b.call(callConfig);\n                (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n              } catch (error) {\n                const errorCode = error.code;\n                if (errorCode === 'ERR_HTTP2_GOAWAY_SESSION' || errorCode === 'ERR_HTTP2_INVALID_SESSION') {\n                  /* An error here indicates that something went wrong with\n                   * the picked subchannel's http2 stream right before we\n                   * tried to start the stream. We are handling a promise\n                   * result here, so this is asynchronous with respect to the\n                   * original tryPick call, so calling it again is not\n                   * recursive. We call tryPick immediately instead of\n                   * queueing this pick again because handling the queue is\n                   * triggered by state changes, and we want to immediately\n                   * check if the state has already changed since the\n                   * previous tryPick call. We do this instead of cancelling\n                   * the stream because the correct behavior may be\n                   * re-queueing instead, based on the logic in the rest of\n                   * tryPick */\n                  this.trace('Failed to start call on picked subchannel ' + subchannelString + ' with error ' + error.message + '. Retrying pick', constants_1.LogVerbosity.INFO);\n                  this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                } else {\n                  this.trace('Failed to start call on picked subchanel ' + subchannelString + ' with error ' + error.message + '. Ending call', constants_1.LogVerbosity.INFO);\n                  callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);\n                }\n              }\n            } else {\n              /* The logic for doing this here is the same as in the catch\n               * block above */\n              this.trace('Picked subchannel ' + subchannelString + ' has state ' + connectivity_state_1.ConnectivityState[subchannelState] + ' after metadata filters. Retrying pick', constants_1.LogVerbosity.INFO);\n              this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n            }\n          }, error => {\n            // We assume the error code isn't 0 (Status.OK)\n            const {\n              code,\n              details\n            } = restrictControlPlaneStatusCode(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n            callStream.cancelWithStatus(code, details);\n          });\n        }\n        break;\n      case picker_1.PickResultType.QUEUE:\n        this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        break;\n      case picker_1.PickResultType.TRANSIENT_FAILURE:\n        if (callMetadata.getOptions().waitForReady) {\n          this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        } else {\n          const {\n            code,\n            details\n          } = restrictControlPlaneStatusCode(pickResult.status.code, pickResult.status.details);\n          callStream.cancelWithStatus(code, details);\n        }\n        break;\n      case picker_1.PickResultType.DROP:\n        const {\n          code,\n          details\n        } = restrictControlPlaneStatusCode(pickResult.status.code, pickResult.status.details);\n        callStream.cancelWithStatus(code, details);\n        break;\n      default:\n        throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n    }\n  }\n  removeConnectivityStateWatcher(watcherObject) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n  updateState(newState) {\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' + this.channelzRef.id + ') ' + uri_parser_1.uriToString(this.target) + ' ' + connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n    if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n      this.currentResolutionError = null;\n    }\n  }\n  tryGetConfig(stream, metadata) {\n    if (stream.getStatus() !== null) {\n      /* If the stream has a status, it has already finished and we don't need\n       * to take any more actions on it. */\n      return;\n    }\n    if (this.configSelector === null) {\n      /* This branch will only be taken at the beginning of the channel's life,\n       * before the resolver ever returns a result. So, the\n       * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n       * because it now has a pending request. */\n      this.resolvingLoadBalancer.exitIdle();\n      if (this.currentResolutionError && !metadata.getOptions().waitForReady) {\n        stream.cancelWithStatus(this.currentResolutionError.code, this.currentResolutionError.details);\n      } else {\n        this.configSelectionQueue.push({\n          callStream: stream,\n          callMetadata: metadata\n        });\n        this.callRefTimerRef();\n      }\n    } else {\n      const callConfig = this.configSelector(stream.getMethod(), metadata);\n      if (callConfig.status === constants_1.Status.OK) {\n        if (callConfig.methodConfig.timeout) {\n          const deadline = new Date();\n          deadline.setSeconds(deadline.getSeconds() + callConfig.methodConfig.timeout.seconds);\n          deadline.setMilliseconds(deadline.getMilliseconds() + callConfig.methodConfig.timeout.nanos / 1000000);\n          stream.setConfigDeadline(deadline);\n          // Refreshing the filters makes the deadline filter pick up the new deadline\n          stream.filterStack.refresh();\n        }\n        if (callConfig.dynamicFilterFactories.length > 0) {\n          /* These dynamicFilters are the mechanism for implementing gRFC A39:\n           * https://github.com/grpc/proposal/blob/master/A39-xds-http-filters.md\n           * We run them here instead of with the rest of the filters because\n           * that spec says \"the xDS HTTP filters will run in between name\n           * resolution and load balancing\".\n           *\n           * We use the filter stack here to simplify the multi-filter async\n           * waterfall logic, but we pass along the underlying list of filters\n           * to avoid having nested filter stacks when combining it with the\n           * original filter stack. We do not pass along the original filter\n           * factory list because these filters may need to persist data\n           * between sending headers and other operations. */\n          const dynamicFilterStackFactory = new filter_stack_1.FilterStackFactory(callConfig.dynamicFilterFactories);\n          const dynamicFilterStack = dynamicFilterStackFactory.createFilter(stream);\n          dynamicFilterStack.sendMetadata(Promise.resolve(metadata)).then(filteredMetadata => {\n            this.tryPick(stream, filteredMetadata, callConfig, dynamicFilterStack.getFilters());\n          });\n        } else {\n          this.tryPick(stream, metadata, callConfig, []);\n        }\n      } else {\n        const {\n          code,\n          details\n        } = restrictControlPlaneStatusCode(callConfig.status, 'Failed to route call to method ' + stream.getMethod());\n        stream.cancelWithStatus(code, details);\n      }\n    }\n  }\n  _startCallStream(stream, metadata) {\n    this.tryGetConfig(stream, metadata.clone());\n  }\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n    clearInterval(this.callRefTimer);\n    if (this.channelzEnabled) {\n      channelz_1.unregisterChannelzRef(this.channelzRef);\n    }\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n  getTarget() {\n    return uri_parser_1.uriToString(this.target);\n  }\n  getConnectivityState(tryToConnect) {\n    const connectivityState = this.connectivityState;\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n    return connectivityState;\n  }\n  watchConnectivityState(currentState, deadline, callback) {\n    if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    let timer = null;\n    if (deadline !== Infinity) {\n      const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n        return;\n      }\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(new Error('Deadline passed without connectivity state change'));\n      }, deadlineDate.getTime() - now.getTime());\n    }\n    const watcherObject = {\n      currentState,\n      callback,\n      timer\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns\n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError('Channel#createCall: deadline must be a number or Date');\n    }\n    if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    const callNumber = getNewCallNumber();\n    this.trace('createCall [' + callNumber + '] method=\"' + method + '\", deadline=' + deadline);\n    const finalOptions = {\n      deadline: deadline,\n      flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n      host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n      parentCall: parentCall\n    };\n    const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      stream.addStatusWatcher(status => {\n        if (status.code === constants_1.Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n    }\n    return stream;\n  }\n}\nexports.ChannelImplementation = ChannelImplementation;","map":{"version":3,"names":["Object","defineProperty","exports","value","ChannelImplementation","call_stream_1","require","channel_credentials_1","resolving_load_balancer_1","subchannel_pool_1","picker_1","constants_1","filter_stack_1","call_credentials_filter_1","deadline_filter_1","compression_filter_1","resolver_1","logging_1","max_message_size_filter_1","http_proxy_1","uri_parser_1","connectivity_state_1","channelz_1","MAX_TIMEOUT_TIME","nextCallNumber","getNewCallNumber","callNumber","Number","MAX_SAFE_INTEGER","INAPPROPRIATE_CONTROL_PLANE_CODES","Status","OK","INVALID_ARGUMENT","NOT_FOUND","ALREADY_EXISTS","FAILED_PRECONDITION","ABORTED","OUT_OF_RANGE","DATA_LOSS","restrictControlPlaneStatusCode","code","details","includes","INTERNAL","constructor","target","credentials","options","_a","_b","_c","_d","connectivityState","ConnectivityState","IDLE","currentPicker","UnavailablePicker","configSelectionQueue","pickQueue","connectivityStateWatchers","configSelector","currentResolutionError","channelzEnabled","callTracker","ChannelzCallTracker","childrenTracker","ChannelzChildrenTracker","TypeError","ChannelCredentials","originalTarget","originalTargetUri","parseUri","Error","defaultSchemeMapResult","mapUriDefaultScheme","callRefTimer","setInterval","unref","call","channelzTrace","ChannelzTrace","channelzRef","registerChannelzChannel","getChannelzInfo","addTrace","defaultAuthority","getDefaultAuthority","proxyMapResult","mapProxyName","assign","extraOptions","subchannelPool","getSubchannelPool","channelControlHelper","createSubchannel","subchannelAddress","subchannelArgs","subchannel","getOrCreateSubchannel","getChannelzRef","updateState","picker","queueCopy","slice","callRefTimerUnref","callStream","callMetadata","callConfig","dynamicFilters","tryPick","requestReresolution","addChannelzChild","child","refChild","removeChannelzChild","unrefChild","resolvingLoadBalancer","ResolvingLoadBalancer","process","nextTick","localQueue","tryGetConfig","status","length","trace","metadata","getOptions","waitForReady","callRefTimerRef","push","cancelWithStatus","filterStackFactory","FilterStackFactory","CallCredentialsFilterFactory","DeadlineFilterFactory","MaxMessageSizeFilterFactory","CompressionFilterFactory","JSON","stringify","undefined","error","LogVerbosity","DEBUG","id","stack","substring","indexOf","state","children","getChildLists","text","verbosityOverride","uriToString","hasRef","ref","pushPick","pickResult","pick","extraPickInfo","pickInformation","subchannelString","getAddress","getCallNumber","PickResultType","pickResultType","COMPLETE","UNAVAILABLE","getConnectivityState","READY","log","ERROR","filterStack","sendMetadata","Promise","resolve","clone","then","finalMetadata","subchannelState","pickExtraFilters","extraFilterFactories","map","factory","createFilter","getRealSubchannel","startCallStream","onCommitted","onCallStarted","errorCode","message","INFO","UNKNOWN","QUEUE","TRANSIENT_FAILURE","DROP","removeConnectivityStateWatcher","watcherObject","watcherIndex","findIndex","splice","newState","watchersCopy","currentState","timer","clearTimeout","callback","stream","getStatus","exitIdle","getMethod","methodConfig","timeout","deadline","Date","setSeconds","getSeconds","seconds","setMilliseconds","getMilliseconds","nanos","setConfigDeadline","refresh","dynamicFilterFactories","dynamicFilterStackFactory","dynamicFilterStack","filteredMetadata","getFilters","_startCallStream","close","destroy","SHUTDOWN","clearInterval","unregisterChannelzRef","unrefUnusedSubchannels","getTarget","tryToConnect","watchConnectivityState","Infinity","deadlineDate","now","setTimeout","getTime","createCall","method","host","parentCall","propagateFlags","finalOptions","flags","Propagate","DEFAULTS","Http2CallStream","_getCallCredentials","addCallStarted","addStatusWatcher","addCallSucceeded","addCallFailed"],"sources":["/Users/dimitris.finas/git/lightstep/cloud/aws/angular/angular-tutorial/node_modules/@grpc/grpc-js/build/src/channel.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChannelImplementation = void 0;\nconst call_stream_1 = require(\"./call-stream\");\nconst channel_credentials_1 = require(\"./channel-credentials\");\nconst resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\nconst subchannel_pool_1 = require(\"./subchannel-pool\");\nconst picker_1 = require(\"./picker\");\nconst constants_1 = require(\"./constants\");\nconst filter_stack_1 = require(\"./filter-stack\");\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\nconst deadline_filter_1 = require(\"./deadline-filter\");\nconst compression_filter_1 = require(\"./compression-filter\");\nconst resolver_1 = require(\"./resolver\");\nconst logging_1 = require(\"./logging\");\nconst max_message_size_filter_1 = require(\"./max-message-size-filter\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst channelz_1 = require(\"./channelz\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\nlet nextCallNumber = 0;\nfunction getNewCallNumber() {\n    const callNumber = nextCallNumber;\n    nextCallNumber += 1;\n    if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n        nextCallNumber = 0;\n    }\n    return callNumber;\n}\nconst INAPPROPRIATE_CONTROL_PLANE_CODES = [\n    constants_1.Status.OK,\n    constants_1.Status.INVALID_ARGUMENT,\n    constants_1.Status.NOT_FOUND,\n    constants_1.Status.ALREADY_EXISTS,\n    constants_1.Status.FAILED_PRECONDITION,\n    constants_1.Status.ABORTED,\n    constants_1.Status.OUT_OF_RANGE,\n    constants_1.Status.DATA_LOSS\n];\nfunction restrictControlPlaneStatusCode(code, details) {\n    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\n        return {\n            code: constants_1.Status.INTERNAL,\n            details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`\n        };\n    }\n    else {\n        return { code, details };\n    }\n}\nclass ChannelImplementation {\n    constructor(target, credentials, options) {\n        var _a, _b, _c, _d;\n        this.credentials = credentials;\n        this.options = options;\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentPicker = new picker_1.UnavailablePicker();\n        /**\n         * Calls queued up to get a call config. Should only be populated before the\n         * first time the resolver returns a result, which includes the ConfigSelector.\n         */\n        this.configSelectionQueue = [];\n        this.pickQueue = [];\n        this.connectivityStateWatchers = [];\n        this.configSelector = null;\n        /**\n         * This is the error from the name resolver if it failed most recently. It\n         * is only used to end calls that start while there is no config selector\n         * and the name resolver is in backoff, so it should be nulled if\n         * configSelector becomes set or the channel state becomes anything other\n         * than TRANSIENT_FAILURE.\n         */\n        this.currentResolutionError = null;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        if (typeof target !== 'string') {\n            throw new TypeError('Channel target must be a string');\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError('Channel credentials must be a ChannelCredentials object');\n        }\n        if (options) {\n            if (typeof options !== 'object') {\n                throw new TypeError('Channel options must be an object');\n            }\n        }\n        this.originalTarget = target;\n        const originalTargetUri = uri_parser_1.parseUri(target);\n        if (originalTargetUri === null) {\n            throw new Error(`Could not parse target name \"${target}\"`);\n        }\n        /* This ensures that the target has a scheme that is registered with the\n         * resolver */\n        const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);\n        if (defaultSchemeMapResult === null) {\n            throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n        }\n        this.callRefTimer = setInterval(() => { }, MAX_TIMEOUT_TIME);\n        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        if (this.options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = channelz_1.registerChannelzChannel(target, () => this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n        }\n        if (this.options['grpc.default_authority']) {\n            this.defaultAuthority = this.options['grpc.default_authority'];\n        }\n        else {\n            this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);\n        }\n        const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);\n        this.target = proxyMapResult.target;\n        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n         * the grpc.use_local_subchannel_pool channel option means. */\n        this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\n        const channelControlHelper = {\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\n                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n                if (this.channelzEnabled) {\n                    this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n                }\n                return subchannel;\n            },\n            updateState: (connectivityState, picker) => {\n                this.currentPicker = picker;\n                const queueCopy = this.pickQueue.slice();\n                this.pickQueue = [];\n                this.callRefTimerUnref();\n                for (const { callStream, callMetadata, callConfig, dynamicFilters } of queueCopy) {\n                    this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                }\n                this.updateState(connectivityState);\n            },\n            requestReresolution: () => {\n                // This should never be called.\n                throw new Error('Resolving load balancer should never call requestReresolution');\n            },\n            addChannelzChild: (child) => {\n                if (this.channelzEnabled) {\n                    this.childrenTracker.refChild(child);\n                }\n            },\n            removeChannelzChild: (child) => {\n                if (this.channelzEnabled) {\n                    this.childrenTracker.unrefChild(child);\n                }\n            }\n        };\n        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (configSelector) => {\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\n            }\n            this.configSelector = configSelector;\n            this.currentResolutionError = null;\n            /* We process the queue asynchronously to ensure that the corresponding\n             * load balancer update has completed. */\n            process.nextTick(() => {\n                const localQueue = this.configSelectionQueue;\n                this.configSelectionQueue = [];\n                this.callRefTimerUnref();\n                for (const { callStream, callMetadata } of localQueue) {\n                    this.tryGetConfig(callStream, callMetadata);\n                }\n                this.configSelectionQueue = [];\n            });\n        }, (status) => {\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details \"' + status.details + '\"');\n            }\n            if (this.configSelectionQueue.length > 0) {\n                this.trace('Name resolution failed with calls queued for config selection');\n            }\n            if (this.configSelector === null) {\n                this.currentResolutionError = Object.assign(Object.assign({}, restrictControlPlaneStatusCode(status.code, status.details)), { metadata: status.metadata });\n            }\n            const localQueue = this.configSelectionQueue;\n            this.configSelectionQueue = [];\n            this.callRefTimerUnref();\n            for (const { callStream, callMetadata } of localQueue) {\n                if (callMetadata.getOptions().waitForReady) {\n                    this.callRefTimerRef();\n                    this.configSelectionQueue.push({ callStream, callMetadata });\n                }\n                else {\n                    callStream.cancelWithStatus(status.code, status.details);\n                }\n            }\n        });\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\n            new call_credentials_filter_1.CallCredentialsFilterFactory(this),\n            new deadline_filter_1.DeadlineFilterFactory(this),\n            new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),\n            new compression_filter_1.CompressionFilterFactory(this, this.options),\n        ]);\n        this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));\n        const error = new Error();\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' + this.channelzRef.id + ') ' + 'Channel constructed \\n' + ((_d = error.stack) === null || _d === void 0 ? void 0 : _d.substring(error.stack.indexOf('\\n') + 1)));\n    }\n    getChannelzInfo() {\n        return {\n            target: this.originalTarget,\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists()\n        };\n    }\n    trace(text, verbosityOverride) {\n        logging_1.trace(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + uri_parser_1.uriToString(this.target) + ' ' + text);\n    }\n    callRefTimerRef() {\n        var _a, _b, _c, _d;\n        // If the hasRef function does not exist, always run the code\n        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n            this.trace('callRefTimer.ref | configSelectionQueue.length=' +\n                this.configSelectionQueue.length +\n                ' pickQueue.length=' +\n                this.pickQueue.length);\n            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n        }\n    }\n    callRefTimerUnref() {\n        var _a, _b;\n        // If the hasRef function does not exist, always run the code\n        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n            this.trace('callRefTimer.unref | configSelectionQueue.length=' +\n                this.configSelectionQueue.length +\n                ' pickQueue.length=' +\n                this.pickQueue.length);\n            (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    pushPick(callStream, callMetadata, callConfig, dynamicFilters) {\n        this.pickQueue.push({ callStream, callMetadata, callConfig, dynamicFilters });\n        this.callRefTimerRef();\n    }\n    /**\n     * Check the picker output for the given call and corresponding metadata,\n     * and take any relevant actions. Should not be called while iterating\n     * over pickQueue.\n     * @param callStream\n     * @param callMetadata\n     */\n    tryPick(callStream, callMetadata, callConfig, dynamicFilters) {\n        var _a, _b;\n        const pickResult = this.currentPicker.pick({\n            metadata: callMetadata,\n            extraPickInfo: callConfig.pickInformation,\n        });\n        const subchannelString = pickResult.subchannel ?\n            '(' + pickResult.subchannel.getChannelzRef().id + ') ' + pickResult.subchannel.getAddress() :\n            '' + pickResult.subchannel;\n        this.trace('Pick result for call [' +\n            callStream.getCallNumber() +\n            ']: ' +\n            picker_1.PickResultType[pickResult.pickResultType] +\n            ' subchannel: ' +\n            subchannelString +\n            ' status: ' + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) +\n            ' ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n        switch (pickResult.pickResultType) {\n            case picker_1.PickResultType.COMPLETE:\n                if (pickResult.subchannel === null) {\n                    callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy');\n                    // End the call with an error\n                }\n                else {\n                    /* If the subchannel is not in the READY state, that indicates a bug\n                     * somewhere in the load balancer or picker. So, we log an error and\n                     * queue the pick to be tried again later. */\n                    if (pickResult.subchannel.getConnectivityState() !==\n                        connectivity_state_1.ConnectivityState.READY) {\n                        logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' +\n                            subchannelString +\n                            ' has state ' +\n                            connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n                        this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n                        break;\n                    }\n                    /* We need to clone the callMetadata here because the transparent\n                     * retry code in the promise resolution handler use the same\n                     * callMetadata object, so it needs to stay unmodified */\n                    callStream.filterStack\n                        .sendMetadata(Promise.resolve(callMetadata.clone()))\n                        .then((finalMetadata) => {\n                        var _a, _b, _c;\n                        const subchannelState = pickResult.subchannel.getConnectivityState();\n                        if (subchannelState === connectivity_state_1.ConnectivityState.READY) {\n                            try {\n                                const pickExtraFilters = pickResult.extraFilterFactories.map(factory => factory.createFilter(callStream));\n                                (_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getRealSubchannel().startCallStream(finalMetadata, callStream, [...dynamicFilters, ...pickExtraFilters]);\n                                /* If we reach this point, the call stream has started\n                                 * successfully */\n                                (_b = callConfig.onCommitted) === null || _b === void 0 ? void 0 : _b.call(callConfig);\n                                (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n                            }\n                            catch (error) {\n                                const errorCode = error.code;\n                                if (errorCode === 'ERR_HTTP2_GOAWAY_SESSION' ||\n                                    errorCode === 'ERR_HTTP2_INVALID_SESSION') {\n                                    /* An error here indicates that something went wrong with\n                                     * the picked subchannel's http2 stream right before we\n                                     * tried to start the stream. We are handling a promise\n                                     * result here, so this is asynchronous with respect to the\n                                     * original tryPick call, so calling it again is not\n                                     * recursive. We call tryPick immediately instead of\n                                     * queueing this pick again because handling the queue is\n                                     * triggered by state changes, and we want to immediately\n                                     * check if the state has already changed since the\n                                     * previous tryPick call. We do this instead of cancelling\n                                     * the stream because the correct behavior may be\n                                     * re-queueing instead, based on the logic in the rest of\n                                     * tryPick */\n                                    this.trace('Failed to start call on picked subchannel ' +\n                                        subchannelString +\n                                        ' with error ' +\n                                        error.message +\n                                        '. Retrying pick', constants_1.LogVerbosity.INFO);\n                                    this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                                }\n                                else {\n                                    this.trace('Failed to start call on picked subchanel ' +\n                                        subchannelString +\n                                        ' with error ' +\n                                        error.message +\n                                        '. Ending call', constants_1.LogVerbosity.INFO);\n                                    callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);\n                                }\n                            }\n                        }\n                        else {\n                            /* The logic for doing this here is the same as in the catch\n                             * block above */\n                            this.trace('Picked subchannel ' +\n                                subchannelString +\n                                ' has state ' +\n                                connectivity_state_1.ConnectivityState[subchannelState] +\n                                ' after metadata filters. Retrying pick', constants_1.LogVerbosity.INFO);\n                            this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                        }\n                    }, (error) => {\n                        // We assume the error code isn't 0 (Status.OK)\n                        const { code, details } = restrictControlPlaneStatusCode(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n                        callStream.cancelWithStatus(code, details);\n                    });\n                }\n                break;\n            case picker_1.PickResultType.QUEUE:\n                this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n                break;\n            case picker_1.PickResultType.TRANSIENT_FAILURE:\n                if (callMetadata.getOptions().waitForReady) {\n                    this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n                }\n                else {\n                    const { code, details } = restrictControlPlaneStatusCode(pickResult.status.code, pickResult.status.details);\n                    callStream.cancelWithStatus(code, details);\n                }\n                break;\n            case picker_1.PickResultType.DROP:\n                const { code, details } = restrictControlPlaneStatusCode(pickResult.status.code, pickResult.status.details);\n                callStream.cancelWithStatus(code, details);\n                break;\n            default:\n                throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n        }\n    }\n    removeConnectivityStateWatcher(watcherObject) {\n        const watcherIndex = this.connectivityStateWatchers.findIndex((value) => value === watcherObject);\n        if (watcherIndex >= 0) {\n            this.connectivityStateWatchers.splice(watcherIndex, 1);\n        }\n    }\n    updateState(newState) {\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' + this.channelzRef.id + ') ' +\n            uri_parser_1.uriToString(this.target) +\n            ' ' +\n            connectivity_state_1.ConnectivityState[this.connectivityState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n        }\n        this.connectivityState = newState;\n        const watchersCopy = this.connectivityStateWatchers.slice();\n        for (const watcherObject of watchersCopy) {\n            if (newState !== watcherObject.currentState) {\n                if (watcherObject.timer) {\n                    clearTimeout(watcherObject.timer);\n                }\n                this.removeConnectivityStateWatcher(watcherObject);\n                watcherObject.callback();\n            }\n        }\n        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            this.currentResolutionError = null;\n        }\n    }\n    tryGetConfig(stream, metadata) {\n        if (stream.getStatus() !== null) {\n            /* If the stream has a status, it has already finished and we don't need\n             * to take any more actions on it. */\n            return;\n        }\n        if (this.configSelector === null) {\n            /* This branch will only be taken at the beginning of the channel's life,\n             * before the resolver ever returns a result. So, the\n             * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n             * because it now has a pending request. */\n            this.resolvingLoadBalancer.exitIdle();\n            if (this.currentResolutionError && !metadata.getOptions().waitForReady) {\n                stream.cancelWithStatus(this.currentResolutionError.code, this.currentResolutionError.details);\n            }\n            else {\n                this.configSelectionQueue.push({\n                    callStream: stream,\n                    callMetadata: metadata,\n                });\n                this.callRefTimerRef();\n            }\n        }\n        else {\n            const callConfig = this.configSelector(stream.getMethod(), metadata);\n            if (callConfig.status === constants_1.Status.OK) {\n                if (callConfig.methodConfig.timeout) {\n                    const deadline = new Date();\n                    deadline.setSeconds(deadline.getSeconds() + callConfig.methodConfig.timeout.seconds);\n                    deadline.setMilliseconds(deadline.getMilliseconds() +\n                        callConfig.methodConfig.timeout.nanos / 1000000);\n                    stream.setConfigDeadline(deadline);\n                    // Refreshing the filters makes the deadline filter pick up the new deadline\n                    stream.filterStack.refresh();\n                }\n                if (callConfig.dynamicFilterFactories.length > 0) {\n                    /* These dynamicFilters are the mechanism for implementing gRFC A39:\n                     * https://github.com/grpc/proposal/blob/master/A39-xds-http-filters.md\n                     * We run them here instead of with the rest of the filters because\n                     * that spec says \"the xDS HTTP filters will run in between name\n                     * resolution and load balancing\".\n                     *\n                     * We use the filter stack here to simplify the multi-filter async\n                     * waterfall logic, but we pass along the underlying list of filters\n                     * to avoid having nested filter stacks when combining it with the\n                     * original filter stack. We do not pass along the original filter\n                     * factory list because these filters may need to persist data\n                     * between sending headers and other operations. */\n                    const dynamicFilterStackFactory = new filter_stack_1.FilterStackFactory(callConfig.dynamicFilterFactories);\n                    const dynamicFilterStack = dynamicFilterStackFactory.createFilter(stream);\n                    dynamicFilterStack.sendMetadata(Promise.resolve(metadata)).then(filteredMetadata => {\n                        this.tryPick(stream, filteredMetadata, callConfig, dynamicFilterStack.getFilters());\n                    });\n                }\n                else {\n                    this.tryPick(stream, metadata, callConfig, []);\n                }\n            }\n            else {\n                const { code, details } = restrictControlPlaneStatusCode(callConfig.status, 'Failed to route call to method ' + stream.getMethod());\n                stream.cancelWithStatus(code, details);\n            }\n        }\n    }\n    _startCallStream(stream, metadata) {\n        this.tryGetConfig(stream, metadata.clone());\n    }\n    close() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n        clearInterval(this.callRefTimer);\n        if (this.channelzEnabled) {\n            channelz_1.unregisterChannelzRef(this.channelzRef);\n        }\n        this.subchannelPool.unrefUnusedSubchannels();\n    }\n    getTarget() {\n        return uri_parser_1.uriToString(this.target);\n    }\n    getConnectivityState(tryToConnect) {\n        const connectivityState = this.connectivityState;\n        if (tryToConnect) {\n            this.resolvingLoadBalancer.exitIdle();\n        }\n        return connectivityState;\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        let timer = null;\n        if (deadline !== Infinity) {\n            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n            const now = new Date();\n            if (deadline === -Infinity || deadlineDate <= now) {\n                process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n                return;\n            }\n            timer = setTimeout(() => {\n                this.removeConnectivityStateWatcher(watcherObject);\n                callback(new Error('Deadline passed without connectivity state change'));\n            }, deadlineDate.getTime() - now.getTime());\n        }\n        const watcherObject = {\n            currentState,\n            callback,\n            timer,\n        };\n        this.connectivityStateWatchers.push(watcherObject);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== 'string') {\n            throw new TypeError('Channel#createCall: method must be a string');\n        }\n        if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n            throw new TypeError('Channel#createCall: deadline must be a number or Date');\n        }\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        const callNumber = getNewCallNumber();\n        this.trace('createCall [' +\n            callNumber +\n            '] method=\"' +\n            method +\n            '\", deadline=' +\n            deadline);\n        const finalOptions = {\n            deadline: deadline,\n            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n            host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n            parentCall: parentCall,\n        };\n        const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n            stream.addStatusWatcher(status => {\n                if (status.code === constants_1.Status.OK) {\n                    this.callTracker.addCallSucceeded();\n                }\n                else {\n                    this.callTracker.addCallFailed();\n                }\n            });\n        }\n        return stream;\n    }\n}\nexports.ChannelImplementation = ChannelImplementation;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}